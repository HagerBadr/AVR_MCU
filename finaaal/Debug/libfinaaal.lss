In archive libfinaaal.a:

WTD_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000258  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000038a  00000000  00000000  0000028c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.M_WDT_void_enable 0000001c  00000000  00000000  00000616  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.M_WDT_void_disable 00000022  00000000  00000000  00000632  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.M_WDT_void_sleep 00000032  00000000  00000000  00000654  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.M_WDT_void_refresh 00000010  00000000  00000000  00000686  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text.M_WDT_void_enable:

00000000 <M_WDT_void_enable>:

#include"STD_TYPES.h"

#include"BIT_MATH.h"
void M_WDT_void_enable(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(WDTCR_REG,WDE_BIT);
   8:	a1 e4       	ldi	r26, 0x41	; 65
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e1 e4       	ldi	r30, 0x41	; 65
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	88 60       	ori	r24, 0x08	; 8
  14:	8c 93       	st	X, r24
}
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.M_WDT_void_disable:

00000000 <M_WDT_void_disable>:

#include"STD_TYPES.h"

#include"BIT_MATH.h"
void M_WDT_void_enable(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(WDTCR_REG,WDE_BIT);
   8:	a1 e4       	ldi	r26, 0x41	; 65
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e1 e4       	ldi	r30, 0x41	; 65
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	88 61       	ori	r24, 0x18	; 24
  14:	8c 93       	st	X, r24
}
  16:	e1 e4       	ldi	r30, 0x41	; 65
  18:	f0 e0       	ldi	r31, 0x00	; 0
  1a:	10 82       	st	Z, r1
  1c:	cf 91       	pop	r28
  1e:	df 91       	pop	r29
  20:	08 95       	ret

Disassembly of section .text.M_WDT_void_sleep:

00000000 <M_WDT_void_sleep>:

#include"STD_TYPES.h"

#include"BIT_MATH.h"
void M_WDT_void_enable(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
	SET_BIT(WDTCR_REG,WDE_BIT);
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	a1 e4       	ldi	r26, 0x41	; 65
   e:	b0 e0       	ldi	r27, 0x00	; 0
  10:	e1 e4       	ldi	r30, 0x41	; 65
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	80 81       	ld	r24, Z
}
  16:	88 7f       	andi	r24, 0xF8	; 248
  18:	8c 93       	st	X, r24
  1a:	a1 e4       	ldi	r26, 0x41	; 65
  1c:	b0 e0       	ldi	r27, 0x00	; 0
  1e:	e1 e4       	ldi	r30, 0x41	; 65
  20:	f0 e0       	ldi	r31, 0x00	; 0
  22:	90 81       	ld	r25, Z
  24:	89 81       	ldd	r24, Y+1	; 0x01
  26:	89 2b       	or	r24, r25
  28:	8c 93       	st	X, r24
  2a:	0f 90       	pop	r0
  2c:	cf 91       	pop	r28
  2e:	df 91       	pop	r29
  30:	08 95       	ret

Disassembly of section .text.M_WDT_void_refresh:

00000000 <M_WDT_void_refresh>:

#include"STD_TYPES.h"

#include"BIT_MATH.h"
void M_WDT_void_enable(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(WDTCR_REG,WDE_BIT);
   8:	a8 95       	wdr
   a:	cf 91       	pop	r28
   c:	df 91       	pop	r29
   e:	08 95       	ret

TIMER1_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000005f4  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000091a  00000000  00000000  00000628  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.Arr_CallBack 00000008  00000000  00000000  00000f42  2**0
                  ALLOC
  6 .text.M_TIMER1_void_init 00000046  00000000  00000000  00000f42  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .text.M_TIMER1_void_start 00000038  00000000  00000000  00000f88  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  8 .text.M_TIMER1_void_stop 00000040  00000000  00000000  00000fc0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.M_TIMER1_ICU_void_init 0000001c  00000000  00000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.M_TIMER1_ICU_void_IntEnable 0000001c  00000000  00000000  0000101c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .text.M_TIMER1_ICU_void_IntDisable 0000001c  00000000  00000000  00001038  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 12 .text.M_TIMER1_ICU_void_setTrigg 00000056  00000000  00000000  00001054  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.M_TIMER1_ICU_u16_takeReading 00000016  00000000  00000000  000010aa  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .text.M_TIMER1_ICU_void_setCallBack 0000002c  00000000  00000000  000010c0  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.__vector_6 00000066  00000000  00000000  000010ec  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.M_TIMER1_void_init:

00000000 <M_TIMER1_void_init>:
		Arr_CallBack[0] = ptrfun;
	}
}

ISR(TIMER1_CAPT_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	af e4       	ldi	r26, 0x4F	; 79
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	ef e4       	ldi	r30, 0x4F	; 79
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	8e 7f       	andi	r24, 0xFE	; 254
  14:	8c 93       	st	X, r24
  16:	af e4       	ldi	r26, 0x4F	; 79
  18:	b0 e0       	ldi	r27, 0x00	; 0
  1a:	ef e4       	ldi	r30, 0x4F	; 79
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	8d 7f       	andi	r24, 0xFD	; 253
  22:	8c 93       	st	X, r24
  24:	ae e4       	ldi	r26, 0x4E	; 78
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	ee e4       	ldi	r30, 0x4E	; 78
	if(Arr_CallBack[0] != NULL)
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	87 7f       	andi	r24, 0xF7	; 247
  30:	8c 93       	st	X, r24
  32:	ae e4       	ldi	r26, 0x4E	; 78
  34:	b0 e0       	ldi	r27, 0x00	; 0
	{
		Arr_CallBack[0]();
  36:	ee e4       	ldi	r30, 0x4E	; 78
  38:	f0 e0       	ldi	r31, 0x00	; 0
  3a:	80 81       	ld	r24, Z
  3c:	8f 7e       	andi	r24, 0xEF	; 239
  3e:	8c 93       	st	X, r24
	}
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	08 95       	ret

Disassembly of section .text.M_TIMER1_void_start:

00000000 <M_TIMER1_void_start>:
		Arr_CallBack[0] = ptrfun;
	}
}

ISR(TIMER1_CAPT_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	ae e4       	ldi	r26, 0x4E	; 78
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	ee e4       	ldi	r30, 0x4E	; 78
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	8e 7f       	andi	r24, 0xFE	; 254
  14:	8c 93       	st	X, r24
  16:	ae e4       	ldi	r26, 0x4E	; 78
  18:	b0 e0       	ldi	r27, 0x00	; 0
  1a:	ee e4       	ldi	r30, 0x4E	; 78
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	8d 7f       	andi	r24, 0xFD	; 253
  22:	8c 93       	st	X, r24
  24:	ae e4       	ldi	r26, 0x4E	; 78
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	ee e4       	ldi	r30, 0x4E	; 78
	if(Arr_CallBack[0] != NULL)
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	84 60       	ori	r24, 0x04	; 4
  30:	8c 93       	st	X, r24
  32:	cf 91       	pop	r28
  34:	df 91       	pop	r29
	{
		Arr_CallBack[0]();
  36:	08 95       	ret

Disassembly of section .text.M_TIMER1_void_stop:

00000000 <M_TIMER1_void_stop>:
		Arr_CallBack[0] = ptrfun;
	}
}

ISR(TIMER1_CAPT_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	ae e4       	ldi	r26, 0x4E	; 78
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	ee e4       	ldi	r30, 0x4E	; 78
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	8e 7f       	andi	r24, 0xFE	; 254
  14:	8c 93       	st	X, r24
  16:	ae e4       	ldi	r26, 0x4E	; 78
  18:	b0 e0       	ldi	r27, 0x00	; 0
  1a:	ee e4       	ldi	r30, 0x4E	; 78
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	8d 7f       	andi	r24, 0xFD	; 253
  22:	8c 93       	st	X, r24
  24:	ae e4       	ldi	r26, 0x4E	; 78
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	ee e4       	ldi	r30, 0x4E	; 78
	if(Arr_CallBack[0] != NULL)
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	8b 7f       	andi	r24, 0xFB	; 251
  30:	8c 93       	st	X, r24
  32:	ec e4       	ldi	r30, 0x4C	; 76
  34:	f0 e0       	ldi	r31, 0x00	; 0
	{
		Arr_CallBack[0]();
  36:	11 82       	std	Z+1, r1	; 0x01
  38:	10 82       	st	Z, r1
  3a:	cf 91       	pop	r28
  3c:	df 91       	pop	r29
  3e:	08 95       	ret

Disassembly of section .text.M_TIMER1_ICU_void_init:

00000000 <M_TIMER1_ICU_void_init>:
		Arr_CallBack[0] = ptrfun;
	}
}

ISR(TIMER1_CAPT_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	ae e4       	ldi	r26, 0x4E	; 78
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	ee e4       	ldi	r30, 0x4E	; 78
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	80 64       	ori	r24, 0x40	; 64
  14:	8c 93       	st	X, r24
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.M_TIMER1_ICU_void_IntEnable:

00000000 <M_TIMER1_ICU_void_IntEnable>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a9 e5       	ldi	r26, 0x59	; 89
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e9 e5       	ldi	r30, 0x59	; 89
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	80 62       	ori	r24, 0x20	; 32
  14:	8c 93       	st	X, r24
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.M_TIMER1_ICU_void_IntDisable:

00000000 <M_TIMER1_ICU_void_IntDisable>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a9 e5       	ldi	r26, 0x59	; 89
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e9 e5       	ldi	r30, 0x59	; 89
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	8f 7d       	andi	r24, 0xDF	; 223
  14:	8c 93       	st	X, r24
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.M_TIMER1_ICU_void_setTrigg:

00000000 <M_TIMER1_ICU_void_setTrigg>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <M_TIMER1_ICU_void_setTrigg+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	00 97       	sbiw	r24, 0x00	; 0
  1e:	01 f0       	breq	.+0      	; 0x20 <M_TIMER1_ICU_void_setTrigg+0x20>
  20:	2a 81       	ldd	r18, Y+2	; 0x02
  22:	3b 81       	ldd	r19, Y+3	; 0x03
  24:	21 30       	cpi	r18, 0x01	; 1
  26:	31 05       	cpc	r19, r1
  28:	01 f0       	breq	.+0      	; 0x2a <M_TIMER1_ICU_void_setTrigg+0x2a>
	if(Arr_CallBack[0] != NULL)
  2a:	00 c0       	rjmp	.+0      	; 0x2c <M_TIMER1_ICU_void_setTrigg+0x2c>
  2c:	ae e4       	ldi	r26, 0x4E	; 78
  2e:	b0 e0       	ldi	r27, 0x00	; 0
  30:	ee e4       	ldi	r30, 0x4E	; 78
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	80 81       	ld	r24, Z
	{
		Arr_CallBack[0]();
  36:	8f 7b       	andi	r24, 0xBF	; 191
  38:	8c 93       	st	X, r24
  3a:	00 c0       	rjmp	.+0      	; 0x3c <M_TIMER1_ICU_void_setTrigg+0x3c>
  3c:	ae e4       	ldi	r26, 0x4E	; 78
  3e:	b0 e0       	ldi	r27, 0x00	; 0
	}
}
  40:	ee e4       	ldi	r30, 0x4E	; 78
  42:	f0 e0       	ldi	r31, 0x00	; 0
  44:	80 81       	ld	r24, Z
  46:	80 64       	ori	r24, 0x40	; 64
  48:	8c 93       	st	X, r24
  4a:	0f 90       	pop	r0
  4c:	0f 90       	pop	r0
  4e:	0f 90       	pop	r0
  50:	cf 91       	pop	r28
  52:	df 91       	pop	r29
  54:	08 95       	ret

Disassembly of section .text.M_TIMER1_ICU_u16_takeReading:

00000000 <M_TIMER1_ICU_u16_takeReading>:
		Arr_CallBack[0] = ptrfun;
	}
}

ISR(TIMER1_CAPT_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e6 e4       	ldi	r30, 0x46	; 70
   a:	f0 e0       	ldi	r31, 0x00	; 0
   c:	80 81       	ld	r24, Z
   e:	91 81       	ldd	r25, Z+1	; 0x01
  10:	cf 91       	pop	r28
  12:	df 91       	pop	r29
  14:	08 95       	ret

Disassembly of section .text.M_TIMER1_ICU_void_setCallBack:

00000000 <M_TIMER1_ICU_void_setCallBack>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <M_TIMER1_ICU_void_setCallBack+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	9a 81       	ldd	r25, Y+2	; 0x02
  12:	00 97       	sbiw	r24, 0x00	; 0
  14:	01 f0       	breq	.+0      	; 0x16 <M_TIMER1_ICU_void_setCallBack+0x16>
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	9a 81       	ldd	r25, Y+2	; 0x02
  1a:	90 93 00 00 	sts	0x0000, r25
  1e:	80 93 00 00 	sts	0x0000, r24
  22:	0f 90       	pop	r0
  24:	0f 90       	pop	r0
  26:	cf 91       	pop	r28
  28:	df 91       	pop	r29
	if(Arr_CallBack[0] != NULL)
  2a:	08 95       	ret

Disassembly of section .text.__vector_6:

00000000 <__vector_6>:
		Arr_CallBack[0] = ptrfun;
	}
}

ISR(TIMER1_CAPT_vect)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	if(Arr_CallBack[0] != NULL)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_6+0x36>
	{
		Arr_CallBack[0]();
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
	}
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

TIMER_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000744  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000b85  00000000  00000000  00000778  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.NumberOFOverflows 00000004  00000000  00000000  000012fd  2**0
                  ALLOC
  6 .bss.NumberOFRemainingTicks 00000004  00000000  00000000  000012fd  2**0
                  ALLOC
  7 .bss.Arr_CallBack 00000004  00000000  00000000  000012fd  2**0
                  ALLOC
  8 .text.M_TIMER0_void_Init 00000046  00000000  00000000  000012fd  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.M_TIMER0_void_start 0000002a  00000000  00000000  00001343  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 10 .text.M_TIMER0_void_stop 0000001c  00000000  00000000  0000136d  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 11 .rodata.C.0.1395 00000014  00000000  00000000  00001389  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
 12 .text.M_TIMER0_void_setTime 000000ee  00000000  00000000  0000139d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.M_TIMER0_void_EnableInt 0000003a  00000000  00000000  0000148b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 14 .text.M_TIMER0_void_DisableInt 0000003c  00000000  00000000  000014c5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 15 .text.M_TIMER0_void_setCallBack 00000036  00000000  00000000  00001501  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 16 .text.M_TIMER0_void_setFastPWM 00000062  00000000  00000000  00001537  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 17 .text.M_TIMER0_void_setphaseCorrectPWM 00000014  00000000  00000000  00001599  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 18 .bss.Loc_OVFCaounter.1454 00000004  00000000  00000000  000015ad  2**0
                  ALLOC
 19 .text.__vector_11 000000de  00000000  00000000  000015ad  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 20 .text.__vector_10 00000066  00000000  00000000  0000168b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.M_TIMER0_void_Init:

00000000 <M_TIMER0_void_Init>:
	}


}
ISR(TIMER0_COMP_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a3 e5       	ldi	r26, 0x53	; 83
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e3 e5       	ldi	r30, 0x53	; 83
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	80 64       	ori	r24, 0x40	; 64
  14:	8c 93       	st	X, r24
  16:	a3 e5       	ldi	r26, 0x53	; 83
  18:	b0 e0       	ldi	r27, 0x00	; 0
  1a:	e3 e5       	ldi	r30, 0x53	; 83
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	88 60       	ori	r24, 0x08	; 8
  22:	8c 93       	st	X, r24
  24:	a3 e5       	ldi	r26, 0x53	; 83
  26:	b0 e0       	ldi	r27, 0x00	; 0
  28:	e3 e5       	ldi	r30, 0x53	; 83
	if(Arr_CallBack[TIMER0_CMP_INT_ID] != NULL)
  2a:	f0 e0       	ldi	r31, 0x00	; 0
  2c:	80 81       	ld	r24, Z
  2e:	8f 7c       	andi	r24, 0xCF	; 207
  30:	8c 93       	st	X, r24
  32:	a3 e5       	ldi	r26, 0x53	; 83
  34:	b0 e0       	ldi	r27, 0x00	; 0
		Arr_CallBack[TIMER0_CMP_INT_ID]();
  36:	e3 e5       	ldi	r30, 0x53	; 83
  38:	f0 e0       	ldi	r31, 0x00	; 0
  3a:	80 81       	ld	r24, Z
  3c:	80 62       	ori	r24, 0x20	; 32
  3e:	8c 93       	st	X, r24
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	08 95       	ret

Disassembly of section .text.M_TIMER0_void_start:

00000000 <M_TIMER0_void_start>:
	}


}
ISR(TIMER0_COMP_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a3 e5       	ldi	r26, 0x53	; 83
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e3 e5       	ldi	r30, 0x53	; 83
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	88 7f       	andi	r24, 0xF8	; 248
  14:	8c 93       	st	X, r24
  16:	a3 e5       	ldi	r26, 0x53	; 83
  18:	b0 e0       	ldi	r27, 0x00	; 0
  1a:	e3 e5       	ldi	r30, 0x53	; 83
  1c:	f0 e0       	ldi	r31, 0x00	; 0
  1e:	80 81       	ld	r24, Z
  20:	84 60       	ori	r24, 0x04	; 4
  22:	8c 93       	st	X, r24
  24:	cf 91       	pop	r28
  26:	df 91       	pop	r29
  28:	08 95       	ret

Disassembly of section .text.M_TIMER0_void_stop:

00000000 <M_TIMER0_void_stop>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a3 e5       	ldi	r26, 0x53	; 83
   a:	b0 e0       	ldi	r27, 0x00	; 0
   c:	e3 e5       	ldi	r30, 0x53	; 83
   e:	f0 e0       	ldi	r31, 0x00	; 0
  10:	80 81       	ld	r24, Z
  12:	88 7f       	andi	r24, 0xF8	; 248
  14:	8c 93       	st	X, r24
  16:	cf 91       	pop	r28
  18:	df 91       	pop	r29
  1a:	08 95       	ret

Disassembly of section .text.M_TIMER0_void_setTime:

00000000 <M_TIMER0_void_setTime>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a5 97       	sbiw	r28, 0x25	; 37
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	6d 8f       	std	Y+29, r22	; 0x1d
  16:	7e 8f       	std	Y+30, r23	; 0x1e
  18:	8f 8f       	std	Y+31, r24	; 0x1f
  1a:	98 a3       	std	Y+32, r25	; 0x20
  1c:	ce 01       	movw	r24, r28
  1e:	09 96       	adiw	r24, 0x09	; 9
  20:	9a a3       	std	Y+34, r25	; 0x22
  22:	89 a3       	std	Y+33, r24	; 0x21
  24:	e0 e0       	ldi	r30, 0x00	; 0
  26:	f0 e0       	ldi	r31, 0x00	; 0
  28:	fc a3       	std	Y+36, r31	; 0x24
	if(Arr_CallBack[TIMER0_CMP_INT_ID] != NULL)
  2a:	eb a3       	std	Y+35, r30	; 0x23
  2c:	f4 e1       	ldi	r31, 0x14	; 20
  2e:	fd a3       	std	Y+37, r31	; 0x25
  30:	eb a1       	ldd	r30, Y+35	; 0x23
  32:	fc a1       	ldd	r31, Y+36	; 0x24
  34:	00 80       	ld	r0, Z
		Arr_CallBack[TIMER0_CMP_INT_ID]();
  36:	8b a1       	ldd	r24, Y+35	; 0x23
  38:	9c a1       	ldd	r25, Y+36	; 0x24
  3a:	01 96       	adiw	r24, 0x01	; 1
  3c:	9c a3       	std	Y+36, r25	; 0x24
  3e:	8b a3       	std	Y+35, r24	; 0x23
}
  40:	e9 a1       	ldd	r30, Y+33	; 0x21
  42:	fa a1       	ldd	r31, Y+34	; 0x22
  44:	00 82       	st	Z, r0
  46:	89 a1       	ldd	r24, Y+33	; 0x21
  48:	9a a1       	ldd	r25, Y+34	; 0x22
  4a:	01 96       	adiw	r24, 0x01	; 1
  4c:	9a a3       	std	Y+34, r25	; 0x22
  4e:	89 a3       	std	Y+33, r24	; 0x21
  50:	9d a1       	ldd	r25, Y+37	; 0x25
  52:	91 50       	subi	r25, 0x01	; 1
  54:	9d a3       	std	Y+37, r25	; 0x25
  56:	ed a1       	ldd	r30, Y+37	; 0x25
  58:	ee 23       	and	r30, r30
  5a:	01 f4       	brne	.+0      	; 0x5c <M_TIMER0_void_setTime+0x5c>
  5c:	8d 89       	ldd	r24, Y+21	; 0x15
  5e:	9e 89       	ldd	r25, Y+22	; 0x16
  60:	af 89       	ldd	r26, Y+23	; 0x17
  62:	b8 8d       	ldd	r27, Y+24	; 0x18
  64:	bc 01       	movw	r22, r24
  66:	cd 01       	movw	r24, r26
  68:	0e 94 00 00 	call	0	; 0x0 <M_TIMER0_void_setTime>
  6c:	dc 01       	movw	r26, r24
  6e:	cb 01       	movw	r24, r22
  70:	bc 01       	movw	r22, r24
  72:	cd 01       	movw	r24, r26
  74:	20 e0       	ldi	r18, 0x00	; 0
  76:	30 e0       	ldi	r19, 0x00	; 0
  78:	40 e8       	ldi	r20, 0x80	; 128
  7a:	51 e4       	ldi	r21, 0x41	; 65
  7c:	0e 94 00 00 	call	0	; 0x0 <M_TIMER0_void_setTime>
  80:	dc 01       	movw	r26, r24
  82:	cb 01       	movw	r24, r22
  84:	8d 83       	std	Y+5, r24	; 0x05
  86:	9e 83       	std	Y+6, r25	; 0x06
  88:	af 83       	std	Y+7, r26	; 0x07
  8a:	b8 87       	std	Y+8, r27	; 0x08
  8c:	8d 8d       	ldd	r24, Y+29	; 0x1d
  8e:	9e 8d       	ldd	r25, Y+30	; 0x1e
  90:	af 8d       	ldd	r26, Y+31	; 0x1f
  92:	b8 a1       	ldd	r27, Y+32	; 0x20
  94:	28 ee       	ldi	r18, 0xE8	; 232
  96:	33 e0       	ldi	r19, 0x03	; 3
  98:	40 e0       	ldi	r20, 0x00	; 0
  9a:	50 e0       	ldi	r21, 0x00	; 0
  9c:	bc 01       	movw	r22, r24
  9e:	cd 01       	movw	r24, r26
  a0:	0e 94 00 00 	call	0	; 0x0 <M_TIMER0_void_setTime>
  a4:	dc 01       	movw	r26, r24
  a6:	cb 01       	movw	r24, r22
  a8:	bc 01       	movw	r22, r24
  aa:	cd 01       	movw	r24, r26
  ac:	0e 94 00 00 	call	0	; 0x0 <M_TIMER0_void_setTime>
  b0:	dc 01       	movw	r26, r24
  b2:	cb 01       	movw	r24, r22
  b4:	bc 01       	movw	r22, r24
  b6:	cd 01       	movw	r24, r26
  b8:	2d 81       	ldd	r18, Y+5	; 0x05
  ba:	3e 81       	ldd	r19, Y+6	; 0x06
  bc:	4f 81       	ldd	r20, Y+7	; 0x07
  be:	58 85       	ldd	r21, Y+8	; 0x08
  c0:	0e 94 00 00 	call	0	; 0x0 <M_TIMER0_void_setTime>
  c4:	dc 01       	movw	r26, r24
  c6:	cb 01       	movw	r24, r22
  c8:	bc 01       	movw	r22, r24
  ca:	cd 01       	movw	r24, r26
  cc:	0e 94 00 00 	call	0	; 0x0 <M_TIMER0_void_setTime>
  d0:	dc 01       	movw	r26, r24
  d2:	cb 01       	movw	r24, r22
  d4:	89 83       	std	Y+1, r24	; 0x01
  d6:	9a 83       	std	Y+2, r25	; 0x02
  d8:	ab 83       	std	Y+3, r26	; 0x03
  da:	bc 83       	std	Y+4, r27	; 0x04
  dc:	a5 96       	adiw	r28, 0x25	; 37
  de:	0f b6       	in	r0, 0x3f	; 63
  e0:	f8 94       	cli
  e2:	de bf       	out	0x3e, r29	; 62
  e4:	0f be       	out	0x3f, r0	; 63
  e6:	cd bf       	out	0x3d, r28	; 61
  e8:	cf 91       	pop	r28
  ea:	df 91       	pop	r29
  ec:	08 95       	ret

Disassembly of section .text.M_TIMER0_void_EnableInt:

00000000 <M_TIMER0_void_EnableInt>:
	}


}
ISR(TIMER0_COMP_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	a9 e5       	ldi	r26, 0x59	; 89
   e:	b0 e0       	ldi	r27, 0x00	; 0
  10:	e9 e5       	ldi	r30, 0x59	; 89
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	80 81       	ld	r24, Z
  16:	48 2f       	mov	r20, r24
  18:	89 81       	ldd	r24, Y+1	; 0x01
  1a:	28 2f       	mov	r18, r24
  1c:	30 e0       	ldi	r19, 0x00	; 0
  1e:	81 e0       	ldi	r24, 0x01	; 1
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	02 2e       	mov	r0, r18
  24:	00 c0       	rjmp	.+0      	; 0x26 <M_TIMER0_void_EnableInt+0x26>
  26:	88 0f       	add	r24, r24
  28:	99 1f       	adc	r25, r25
	if(Arr_CallBack[TIMER0_CMP_INT_ID] != NULL)
  2a:	0a 94       	dec	r0
  2c:	02 f4       	brpl	.+0      	; 0x2e <M_TIMER0_void_EnableInt+0x2e>
  2e:	84 2b       	or	r24, r20
  30:	8c 93       	st	X, r24
  32:	0f 90       	pop	r0
  34:	cf 91       	pop	r28
		Arr_CallBack[TIMER0_CMP_INT_ID]();
  36:	df 91       	pop	r29
  38:	08 95       	ret

Disassembly of section .text.M_TIMER0_void_DisableInt:

00000000 <M_TIMER0_void_DisableInt>:
	}


}
ISR(TIMER0_COMP_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	a9 e5       	ldi	r26, 0x59	; 89
   e:	b0 e0       	ldi	r27, 0x00	; 0
  10:	e9 e5       	ldi	r30, 0x59	; 89
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	80 81       	ld	r24, Z
  16:	48 2f       	mov	r20, r24
  18:	89 81       	ldd	r24, Y+1	; 0x01
  1a:	28 2f       	mov	r18, r24
  1c:	30 e0       	ldi	r19, 0x00	; 0
  1e:	81 e0       	ldi	r24, 0x01	; 1
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	02 2e       	mov	r0, r18
  24:	00 c0       	rjmp	.+0      	; 0x26 <M_TIMER0_void_DisableInt+0x26>
  26:	88 0f       	add	r24, r24
  28:	99 1f       	adc	r25, r25
	if(Arr_CallBack[TIMER0_CMP_INT_ID] != NULL)
  2a:	0a 94       	dec	r0
  2c:	02 f4       	brpl	.+0      	; 0x2e <M_TIMER0_void_DisableInt+0x2e>
  2e:	80 95       	com	r24
  30:	84 23       	and	r24, r20
  32:	8c 93       	st	X, r24
  34:	0f 90       	pop	r0
		Arr_CallBack[TIMER0_CMP_INT_ID]();
  36:	cf 91       	pop	r28
  38:	df 91       	pop	r29
  3a:	08 95       	ret

Disassembly of section .text.M_TIMER0_void_setCallBack:

00000000 <M_TIMER0_void_setCallBack>:
	}


}
ISR(TIMER0_COMP_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <M_TIMER0_void_setCallBack+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9a 83       	std	Y+2, r25	; 0x02
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6b 83       	std	Y+3, r22	; 0x03
  12:	8b 81       	ldd	r24, Y+3	; 0x03
  14:	88 2f       	mov	r24, r24
  16:	90 e0       	ldi	r25, 0x00	; 0
  18:	88 0f       	add	r24, r24
  1a:	99 1f       	adc	r25, r25
  1c:	fc 01       	movw	r30, r24
  1e:	e0 50       	subi	r30, 0x00	; 0
  20:	f0 40       	sbci	r31, 0x00	; 0
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	9a 81       	ldd	r25, Y+2	; 0x02
  26:	91 83       	std	Z+1, r25	; 0x01
  28:	80 83       	st	Z, r24
	if(Arr_CallBack[TIMER0_CMP_INT_ID] != NULL)
  2a:	0f 90       	pop	r0
  2c:	0f 90       	pop	r0
  2e:	0f 90       	pop	r0
  30:	cf 91       	pop	r28
  32:	df 91       	pop	r29
  34:	08 95       	ret

Disassembly of section .text.M_TIMER0_void_setFastPWM:

00000000 <M_TIMER0_void_setFastPWM>:
	}


}
ISR(TIMER0_COMP_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <M_TIMER0_void_setFastPWM+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <M_TIMER0_void_setFastPWM+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	8c e5       	ldi	r24, 0x5C	; 92
  12:	90 e0       	ldi	r25, 0x00	; 0
  14:	9d 83       	std	Y+5, r25	; 0x05
  16:	8c 83       	std	Y+4, r24	; 0x04
  18:	89 81       	ldd	r24, Y+1	; 0x01
  1a:	88 2f       	mov	r24, r24
  1c:	90 e0       	ldi	r25, 0x00	; 0
  1e:	98 2f       	mov	r25, r24
  20:	88 27       	eor	r24, r24
  22:	24 e6       	ldi	r18, 0x64	; 100
  24:	30 e0       	ldi	r19, 0x00	; 0
  26:	b9 01       	movw	r22, r18
  28:	0e 94 00 00 	call	0	; 0x0 <M_TIMER0_void_setFastPWM>
	if(Arr_CallBack[TIMER0_CMP_INT_ID] != NULL)
  2c:	cb 01       	movw	r24, r22
  2e:	01 97       	sbiw	r24, 0x01	; 1
  30:	9b 83       	std	Y+3, r25	; 0x03
  32:	8a 83       	std	Y+2, r24	; 0x02
  34:	ea 81       	ldd	r30, Y+2	; 0x02
		Arr_CallBack[TIMER0_CMP_INT_ID]();
  36:	fb 81       	ldd	r31, Y+3	; 0x03
  38:	ff 23       	and	r31, r31
  3a:	04 f4       	brge	.+0      	; 0x3c <M_TIMER0_void_setFastPWM+0x3c>
  3c:	8a 81       	ldd	r24, Y+2	; 0x02
  3e:	9b 81       	ldd	r25, Y+3	; 0x03
}
  40:	90 95       	com	r25
  42:	81 95       	neg	r24
  44:	9f 4f       	sbci	r25, 0xFF	; 255
  46:	9b 83       	std	Y+3, r25	; 0x03
  48:	8a 83       	std	Y+2, r24	; 0x02
  4a:	8a 81       	ldd	r24, Y+2	; 0x02
  4c:	ec 81       	ldd	r30, Y+4	; 0x04
  4e:	fd 81       	ldd	r31, Y+5	; 0x05
  50:	80 83       	st	Z, r24
  52:	0f 90       	pop	r0
  54:	0f 90       	pop	r0
  56:	0f 90       	pop	r0
  58:	0f 90       	pop	r0
  5a:	0f 90       	pop	r0
  5c:	cf 91       	pop	r28
  5e:	df 91       	pop	r29
  60:	08 95       	ret

Disassembly of section .text.M_TIMER0_void_setphaseCorrectPWM:

00000000 <M_TIMER0_void_setphaseCorrectPWM>:
	}


}
ISR(TIMER0_COMP_vect)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	0f 90       	pop	r0
   e:	cf 91       	pop	r28
  10:	df 91       	pop	r29
  12:	08 95       	ret

Disassembly of section .text.__vector_11:

00000000 <__vector_11>:
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	if(Arr_CallBack[TIMER0_CMP_INT_ID] != NULL)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	a0 91 00 00 	lds	r26, 0x0000
		Arr_CallBack[TIMER0_CMP_INT_ID]();
  36:	b0 91 00 00 	lds	r27, 0x0000
  3a:	01 96       	adiw	r24, 0x01	; 1
  3c:	a1 1d       	adc	r26, r1
  3e:	b1 1d       	adc	r27, r1
}
  40:	80 93 00 00 	sts	0x0000, r24
  44:	90 93 00 00 	sts	0x0000, r25
  48:	a0 93 00 00 	sts	0x0000, r26
  4c:	b0 93 00 00 	sts	0x0000, r27
  50:	20 91 00 00 	lds	r18, 0x0000
  54:	30 91 00 00 	lds	r19, 0x0000
  58:	40 91 00 00 	lds	r20, 0x0000
  5c:	50 91 00 00 	lds	r21, 0x0000
  60:	80 91 00 00 	lds	r24, 0x0000
  64:	90 91 00 00 	lds	r25, 0x0000
  68:	a0 91 00 00 	lds	r26, 0x0000
  6c:	b0 91 00 00 	lds	r27, 0x0000
  70:	28 17       	cp	r18, r24
  72:	39 07       	cpc	r19, r25
  74:	4a 07       	cpc	r20, r26
  76:	5b 07       	cpc	r21, r27
  78:	01 f4       	brne	.+0      	; 0x7a <__vector_11+0x7a>
  7a:	e2 e5       	ldi	r30, 0x52	; 82
  7c:	f0 e0       	ldi	r31, 0x00	; 0
  7e:	80 91 00 00 	lds	r24, 0x0000
  82:	90 91 00 00 	lds	r25, 0x0000
  86:	a0 91 00 00 	lds	r26, 0x0000
  8a:	b0 91 00 00 	lds	r27, 0x0000
  8e:	81 95       	neg	r24
  90:	80 83       	st	Z, r24
  92:	10 92 00 00 	sts	0x0000, r1
  96:	10 92 00 00 	sts	0x0000, r1
  9a:	10 92 00 00 	sts	0x0000, r1
  9e:	10 92 00 00 	sts	0x0000, r1
  a2:	80 91 00 00 	lds	r24, 0x0000
  a6:	90 91 00 00 	lds	r25, 0x0000
  aa:	00 97       	sbiw	r24, 0x00	; 0
  ac:	01 f0       	breq	.+0      	; 0xae <__vector_11+0xae>
  ae:	e0 91 00 00 	lds	r30, 0x0000
  b2:	f0 91 00 00 	lds	r31, 0x0000
  b6:	09 95       	icall
  b8:	cf 91       	pop	r28
  ba:	df 91       	pop	r29
  bc:	ff 91       	pop	r31
  be:	ef 91       	pop	r30
  c0:	bf 91       	pop	r27
  c2:	af 91       	pop	r26
  c4:	9f 91       	pop	r25
  c6:	8f 91       	pop	r24
  c8:	7f 91       	pop	r23
  ca:	6f 91       	pop	r22
  cc:	5f 91       	pop	r21
  ce:	4f 91       	pop	r20
  d0:	3f 91       	pop	r19
  d2:	2f 91       	pop	r18
  d4:	0f 90       	pop	r0
  d6:	0f be       	out	0x3f, r0	; 63
  d8:	0f 90       	pop	r0
  da:	1f 90       	pop	r1
  dc:	18 95       	reti

Disassembly of section .text.__vector_10:

00000000 <__vector_10>:
	}


}
ISR(TIMER0_COMP_vect)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
	if(Arr_CallBack[TIMER0_CMP_INT_ID] != NULL)
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_10+0x36>
		Arr_CallBack[TIMER0_CMP_INT_ID]();
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
}
  40:	cf 91       	pop	r28
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
  62:	1f 90       	pop	r1
  64:	18 95       	reti

GIE_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000001bc  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000032c  00000000  00000000  000001f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.M_GIE_void_enable 00000010  00000000  00000000  0000051c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text.M_GIE_void_disable 00000010  00000000  00000000  0000052c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text.M_GIE_void_enable:

00000000 <M_GIE_void_enable>:

#include "GIE_priv.h"
#include "GIE_config.h"
#include "GIE_int.h"
void M_GIE_void_enable(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
  // Method 1 :
  // SET_BIT(SREG_REG,I_BIT);

 // Method 2:
	asm("SEI");
   8:	78 94       	sei
}
   a:	cf 91       	pop	r28
   c:	df 91       	pop	r29
   e:	08 95       	ret

Disassembly of section .text.M_GIE_void_disable:

00000000 <M_GIE_void_disable>:

#include "GIE_priv.h"
#include "GIE_config.h"
#include "GIE_int.h"
void M_GIE_void_enable(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
  // Method 1 :
  // SET_BIT(SREG_REG,I_BIT);

 // Method 2:
	asm("SEI");
   8:	f8 94       	cli
}
   a:	cf 91       	pop	r28
   c:	df 91       	pop	r29
   e:	08 95       	ret

EXTI_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000588  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000008b7  00000000  00000000  000005bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.Arr_CallBack 00000006  00000000  00000000  00000e73  2**0
                  ALLOC
  6 .text.M_EXTI_void_Enable 0000010a  00000000  00000000  00000e73  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.M_EXTI_void_Disable 00000048  00000000  00000000  00000f7d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.M_EXTI_void_setCallBack 00000076  00000000  00000000  00000fc5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.__vector_1 00000066  00000000  00000000  0000103b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.__vector_2 00000066  00000000  00000000  000010a1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.__vector_3 00000066  00000000  00000000  00001107  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.M_EXTI_void_Enable:

00000000 <M_EXTI_void_Enable>:

// array of 3 pointers to functions (Call Back fn )
static void (*Arr_CallBack[3]) (void)={NULL,NULL,NULL};

void M_EXTI_void_Enable(u8 copy_u8IntID, u8 copy_u8Sense)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <M_EXTI_void_Enable+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <M_EXTI_void_Enable+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
    // step 1 : config Sense
	if(copy_u8Sense < EXTI_TRIG_LOW_LEVEL  || copy_u8Sense > EXTI_TRIG_RAIS_EDGE )
  10:	8a 81       	ldd	r24, Y+2	; 0x02
  12:	84 30       	cpi	r24, 0x04	; 4
  14:	00 f0       	brcs	.+0      	; 0x16 <M_EXTI_void_Enable+0x16>
  16:	00 c0       	rjmp	.+0      	; 0x18 <M_EXTI_void_Enable+0x18>
	{
		return ;
	}
	switch(copy_u8IntID)
  18:	89 81       	ldd	r24, Y+1	; 0x01
  1a:	28 2f       	mov	r18, r24
  1c:	30 e0       	ldi	r19, 0x00	; 0
  1e:	3c 83       	std	Y+4, r19	; 0x04
  20:	2b 83       	std	Y+3, r18	; 0x03
  22:	8b 81       	ldd	r24, Y+3	; 0x03
  24:	9c 81       	ldd	r25, Y+4	; 0x04
  26:	86 30       	cpi	r24, 0x06	; 6
  28:	91 05       	cpc	r25, r1
  2a:	01 f0       	breq	.+0      	; 0x2c <M_EXTI_void_Enable+0x2c>
  2c:	2b 81       	ldd	r18, Y+3	; 0x03
  2e:	3c 81       	ldd	r19, Y+4	; 0x04
  30:	27 30       	cpi	r18, 0x07	; 7
  32:	31 05       	cpc	r19, r1
  34:	01 f0       	breq	.+0      	; 0x36 <M_EXTI_void_Enable+0x36>
  36:	8b 81       	ldd	r24, Y+3	; 0x03
  38:	9c 81       	ldd	r25, Y+4	; 0x04
  3a:	85 30       	cpi	r24, 0x05	; 5
  3c:	91 05       	cpc	r25, r1
  3e:	01 f0       	breq	.+0      	; 0x40 <M_EXTI_void_Enable+0x40>
  40:	00 c0       	rjmp	.+0      	; 0x42 <M_EXTI_void_Enable+0x42>
	{
	case EXTI_INT0_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT0_TRIG_MASK;
  42:	a5 e5       	ldi	r26, 0x55	; 85
  44:	b0 e0       	ldi	r27, 0x00	; 0
  46:	e5 e5       	ldi	r30, 0x55	; 85
  48:	f0 e0       	ldi	r31, 0x00	; 0
  4a:	80 81       	ld	r24, Z
  4c:	8c 7f       	andi	r24, 0xFC	; 252
  4e:	8c 93       	st	X, r24
		// step 2 : insert value
		MCUCR_REG |= copy_u8Sense;
  50:	a5 e5       	ldi	r26, 0x55	; 85
  52:	b0 e0       	ldi	r27, 0x00	; 0
  54:	e5 e5       	ldi	r30, 0x55	; 85
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	90 81       	ld	r25, Z
  5a:	8a 81       	ldd	r24, Y+2	; 0x02
  5c:	89 2b       	or	r24, r25
  5e:	8c 93       	st	X, r24
  60:	00 c0       	rjmp	.+0      	; 0x62 <M_EXTI_void_Enable+0x62>
		break;
	case EXTI_INT1_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT1_TRIG_MASK;
  62:	a5 e5       	ldi	r26, 0x55	; 85
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e5 e5       	ldi	r30, 0x55	; 85
  68:	f0 e0       	ldi	r31, 0x00	; 0
  6a:	80 81       	ld	r24, Z
  6c:	83 7f       	andi	r24, 0xF3	; 243
  6e:	8c 93       	st	X, r24
		// step 2 : insert value
		MCUCR_REG |= copy_u8Sense << EXTI_INT1_TRIG_SHIFT ;
  70:	a5 e5       	ldi	r26, 0x55	; 85
  72:	b0 e0       	ldi	r27, 0x00	; 0
  74:	e5 e5       	ldi	r30, 0x55	; 85
  76:	f0 e0       	ldi	r31, 0x00	; 0
  78:	80 81       	ld	r24, Z
  7a:	28 2f       	mov	r18, r24
  7c:	8a 81       	ldd	r24, Y+2	; 0x02
  7e:	88 2f       	mov	r24, r24
  80:	90 e0       	ldi	r25, 0x00	; 0
  82:	88 0f       	add	r24, r24
  84:	99 1f       	adc	r25, r25
  86:	88 0f       	add	r24, r24
  88:	99 1f       	adc	r25, r25
  8a:	82 2b       	or	r24, r18
  8c:	8c 93       	st	X, r24
  8e:	00 c0       	rjmp	.+0      	; 0x90 <M_EXTI_void_Enable+0x90>
		break;
	case EXTI_INT2_ID:
		// step 1 : Apply Mask
		CLR_BIT(MCUCSR_REG , ISC2_BIT);
  90:	a4 e5       	ldi	r26, 0x54	; 84
  92:	b0 e0       	ldi	r27, 0x00	; 0
  94:	e4 e5       	ldi	r30, 0x54	; 84
  96:	f0 e0       	ldi	r31, 0x00	; 0
  98:	80 81       	ld	r24, Z
  9a:	8f 7b       	andi	r24, 0xBF	; 191
  9c:	8c 93       	st	X, r24
		// step 2 : insert value
		MCUCSR_REG |= (GET_BIT(copy_u8Sense,0))<< EXTI_INT2_TRIG_SHIFT;
  9e:	a4 e5       	ldi	r26, 0x54	; 84
  a0:	b0 e0       	ldi	r27, 0x00	; 0
  a2:	e4 e5       	ldi	r30, 0x54	; 84
  a4:	f0 e0       	ldi	r31, 0x00	; 0
  a6:	80 81       	ld	r24, Z
  a8:	28 2f       	mov	r18, r24
  aa:	8a 81       	ldd	r24, Y+2	; 0x02
  ac:	88 2f       	mov	r24, r24
  ae:	90 e0       	ldi	r25, 0x00	; 0
  b0:	81 70       	andi	r24, 0x01	; 1
  b2:	90 70       	andi	r25, 0x00	; 0
  b4:	00 24       	eor	r0, r0
  b6:	96 95       	lsr	r25
  b8:	87 95       	ror	r24
  ba:	07 94       	ror	r0
  bc:	96 95       	lsr	r25
  be:	87 95       	ror	r24
  c0:	07 94       	ror	r0
  c2:	98 2f       	mov	r25, r24
  c4:	80 2d       	mov	r24, r0
  c6:	82 2b       	or	r24, r18
  c8:	8c 93       	st	X, r24
		break;
	}

	// step 2 : Enable PIE
	if(copy_u8IntID>= EXTI_INT2_ID && copy_u8IntID <= EXTI_INT1_ID)
  ca:	89 81       	ldd	r24, Y+1	; 0x01
  cc:	85 30       	cpi	r24, 0x05	; 5
  ce:	00 f0       	brcs	.+0      	; 0xd0 <M_EXTI_void_Enable+0xd0>
  d0:	89 81       	ldd	r24, Y+1	; 0x01
  d2:	88 30       	cpi	r24, 0x08	; 8
  d4:	00 f4       	brcc	.+0      	; 0xd6 <M_EXTI_void_Enable+0xd6>
	   SET_BIT(GICR_REG ,copy_u8IntID);
  d6:	ab e5       	ldi	r26, 0x5B	; 91
  d8:	b0 e0       	ldi	r27, 0x00	; 0
  da:	eb e5       	ldi	r30, 0x5B	; 91
  dc:	f0 e0       	ldi	r31, 0x00	; 0
  de:	80 81       	ld	r24, Z
  e0:	48 2f       	mov	r20, r24
  e2:	89 81       	ldd	r24, Y+1	; 0x01
  e4:	28 2f       	mov	r18, r24
  e6:	30 e0       	ldi	r19, 0x00	; 0
  e8:	81 e0       	ldi	r24, 0x01	; 1
  ea:	90 e0       	ldi	r25, 0x00	; 0
  ec:	02 2e       	mov	r0, r18
  ee:	00 c0       	rjmp	.+0      	; 0xf0 <M_EXTI_void_Enable+0xf0>
  f0:	88 0f       	add	r24, r24
  f2:	99 1f       	adc	r25, r25
  f4:	0a 94       	dec	r0
  f6:	02 f4       	brpl	.+0      	; 0xf8 <M_EXTI_void_Enable+0xf8>
  f8:	84 2b       	or	r24, r20
  fa:	8c 93       	st	X, r24
}
  fc:	0f 90       	pop	r0
  fe:	0f 90       	pop	r0
 100:	0f 90       	pop	r0
 102:	0f 90       	pop	r0
 104:	cf 91       	pop	r28
 106:	df 91       	pop	r29
 108:	08 95       	ret

Disassembly of section .text.M_EXTI_void_Disable:

00000000 <M_EXTI_void_Disable>:

// array of 3 pointers to functions (Call Back fn )
static void (*Arr_CallBack[3]) (void)={NULL,NULL,NULL};

void M_EXTI_void_Enable(u8 copy_u8IntID, u8 copy_u8Sense)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	89 81       	ldd	r24, Y+1	; 0x01
   e:	85 30       	cpi	r24, 0x05	; 5
    // step 1 : config Sense
	if(copy_u8Sense < EXTI_TRIG_LOW_LEVEL  || copy_u8Sense > EXTI_TRIG_RAIS_EDGE )
  10:	00 f0       	brcs	.+0      	; 0x12 <M_EXTI_void_Disable+0x12>
  12:	89 81       	ldd	r24, Y+1	; 0x01
  14:	88 30       	cpi	r24, 0x08	; 8
  16:	00 f4       	brcc	.+0      	; 0x18 <M_EXTI_void_Disable+0x18>
	{
		return ;
	}
	switch(copy_u8IntID)
  18:	ab e5       	ldi	r26, 0x5B	; 91
  1a:	b0 e0       	ldi	r27, 0x00	; 0
  1c:	eb e5       	ldi	r30, 0x5B	; 91
  1e:	f0 e0       	ldi	r31, 0x00	; 0
  20:	80 81       	ld	r24, Z
  22:	48 2f       	mov	r20, r24
  24:	89 81       	ldd	r24, Y+1	; 0x01
  26:	28 2f       	mov	r18, r24
  28:	30 e0       	ldi	r19, 0x00	; 0
  2a:	81 e0       	ldi	r24, 0x01	; 1
  2c:	90 e0       	ldi	r25, 0x00	; 0
  2e:	02 2e       	mov	r0, r18
  30:	00 c0       	rjmp	.+0      	; 0x32 <M_EXTI_void_Disable+0x32>
  32:	88 0f       	add	r24, r24
  34:	99 1f       	adc	r25, r25
  36:	0a 94       	dec	r0
  38:	02 f4       	brpl	.+0      	; 0x3a <M_EXTI_void_Disable+0x3a>
  3a:	80 95       	com	r24
  3c:	84 23       	and	r24, r20
  3e:	8c 93       	st	X, r24
  40:	0f 90       	pop	r0
	{
	case EXTI_INT0_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT0_TRIG_MASK;
  42:	cf 91       	pop	r28
  44:	df 91       	pop	r29
  46:	08 95       	ret

Disassembly of section .text.M_EXTI_void_setCallBack:

00000000 <M_EXTI_void_setCallBack>:

// array of 3 pointers to functions (Call Back fn )
static void (*Arr_CallBack[3]) (void)={NULL,NULL,NULL};

void M_EXTI_void_Enable(u8 copy_u8IntID, u8 copy_u8Sense)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <M_EXTI_void_setCallBack+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <M_EXTI_void_setCallBack+0x8>
   8:	0f 92       	push	r0
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	9a 83       	std	Y+2, r25	; 0x02
    // step 1 : config Sense
	if(copy_u8Sense < EXTI_TRIG_LOW_LEVEL  || copy_u8Sense > EXTI_TRIG_RAIS_EDGE )
  10:	89 83       	std	Y+1, r24	; 0x01
  12:	6b 83       	std	Y+3, r22	; 0x03
  14:	8b 81       	ldd	r24, Y+3	; 0x03
  16:	28 2f       	mov	r18, r24
	{
		return ;
	}
	switch(copy_u8IntID)
  18:	30 e0       	ldi	r19, 0x00	; 0
  1a:	3d 83       	std	Y+5, r19	; 0x05
  1c:	2c 83       	std	Y+4, r18	; 0x04
  1e:	8c 81       	ldd	r24, Y+4	; 0x04
  20:	9d 81       	ldd	r25, Y+5	; 0x05
  22:	86 30       	cpi	r24, 0x06	; 6
  24:	91 05       	cpc	r25, r1
  26:	01 f0       	breq	.+0      	; 0x28 <M_EXTI_void_setCallBack+0x28>
  28:	2c 81       	ldd	r18, Y+4	; 0x04
  2a:	3d 81       	ldd	r19, Y+5	; 0x05
  2c:	27 30       	cpi	r18, 0x07	; 7
  2e:	31 05       	cpc	r19, r1
  30:	01 f0       	breq	.+0      	; 0x32 <M_EXTI_void_setCallBack+0x32>
  32:	8c 81       	ldd	r24, Y+4	; 0x04
  34:	9d 81       	ldd	r25, Y+5	; 0x05
  36:	85 30       	cpi	r24, 0x05	; 5
  38:	91 05       	cpc	r25, r1
  3a:	01 f0       	breq	.+0      	; 0x3c <M_EXTI_void_setCallBack+0x3c>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <M_EXTI_void_setCallBack+0x3e>
  3e:	89 81       	ldd	r24, Y+1	; 0x01
  40:	9a 81       	ldd	r25, Y+2	; 0x02
	{
	case EXTI_INT0_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT0_TRIG_MASK;
  42:	90 93 00 00 	sts	0x0000, r25
  46:	80 93 00 00 	sts	0x0000, r24
  4a:	00 c0       	rjmp	.+0      	; 0x4c <M_EXTI_void_setCallBack+0x4c>
  4c:	89 81       	ldd	r24, Y+1	; 0x01
  4e:	9a 81       	ldd	r25, Y+2	; 0x02
		// step 2 : insert value
		MCUCR_REG |= copy_u8Sense;
  50:	90 93 00 00 	sts	0x0000, r25
  54:	80 93 00 00 	sts	0x0000, r24
  58:	00 c0       	rjmp	.+0      	; 0x5a <M_EXTI_void_setCallBack+0x5a>
  5a:	89 81       	ldd	r24, Y+1	; 0x01
  5c:	9a 81       	ldd	r25, Y+2	; 0x02
  5e:	90 93 00 00 	sts	0x0000, r25
		break;
	case EXTI_INT1_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT1_TRIG_MASK;
  62:	80 93 00 00 	sts	0x0000, r24
  66:	0f 90       	pop	r0
  68:	0f 90       	pop	r0
  6a:	0f 90       	pop	r0
  6c:	0f 90       	pop	r0
  6e:	0f 90       	pop	r0
		// step 2 : insert value
		MCUCR_REG |= copy_u8Sense << EXTI_INT1_TRIG_SHIFT ;
  70:	cf 91       	pop	r28
  72:	df 91       	pop	r29
  74:	08 95       	ret

Disassembly of section .text.__vector_1:

00000000 <__vector_1>:

// array of 3 pointers to functions (Call Back fn )
static void (*Arr_CallBack[3]) (void)={NULL,NULL,NULL};

void M_EXTI_void_Enable(u8 copy_u8IntID, u8 copy_u8Sense)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
    // step 1 : config Sense
	if(copy_u8Sense < EXTI_TRIG_LOW_LEVEL  || copy_u8Sense > EXTI_TRIG_RAIS_EDGE )
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
	{
		return ;
	}
	switch(copy_u8IntID)
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_1+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
  40:	cf 91       	pop	r28
	{
	case EXTI_INT0_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT0_TRIG_MASK;
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
		// step 2 : insert value
		MCUCR_REG |= copy_u8Sense;
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
		break;
	case EXTI_INT1_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT1_TRIG_MASK;
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_2:

00000000 <__vector_2>:

// array of 3 pointers to functions (Call Back fn )
static void (*Arr_CallBack[3]) (void)={NULL,NULL,NULL};

void M_EXTI_void_Enable(u8 copy_u8IntID, u8 copy_u8Sense)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
    // step 1 : config Sense
	if(copy_u8Sense < EXTI_TRIG_LOW_LEVEL  || copy_u8Sense > EXTI_TRIG_RAIS_EDGE )
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
	{
		return ;
	}
	switch(copy_u8IntID)
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_2+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
  40:	cf 91       	pop	r28
	{
	case EXTI_INT0_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT0_TRIG_MASK;
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
		// step 2 : insert value
		MCUCR_REG |= copy_u8Sense;
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
		break;
	case EXTI_INT1_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT1_TRIG_MASK;
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Disassembly of section .text.__vector_3:

00000000 <__vector_3>:

// array of 3 pointers to functions (Call Back fn )
static void (*Arr_CallBack[3]) (void)={NULL,NULL,NULL};

void M_EXTI_void_Enable(u8 copy_u8IntID, u8 copy_u8Sense)
{
   0:	1f 92       	push	r1
   2:	0f 92       	push	r0
   4:	0f b6       	in	r0, 0x3f	; 63
   6:	0f 92       	push	r0
   8:	11 24       	eor	r1, r1
   a:	2f 93       	push	r18
   c:	3f 93       	push	r19
   e:	4f 93       	push	r20
    // step 1 : config Sense
	if(copy_u8Sense < EXTI_TRIG_LOW_LEVEL  || copy_u8Sense > EXTI_TRIG_RAIS_EDGE )
  10:	5f 93       	push	r21
  12:	6f 93       	push	r22
  14:	7f 93       	push	r23
  16:	8f 93       	push	r24
	{
		return ;
	}
	switch(copy_u8IntID)
  18:	9f 93       	push	r25
  1a:	af 93       	push	r26
  1c:	bf 93       	push	r27
  1e:	ef 93       	push	r30
  20:	ff 93       	push	r31
  22:	df 93       	push	r29
  24:	cf 93       	push	r28
  26:	cd b7       	in	r28, 0x3d	; 61
  28:	de b7       	in	r29, 0x3e	; 62
  2a:	80 91 00 00 	lds	r24, 0x0000
  2e:	90 91 00 00 	lds	r25, 0x0000
  32:	00 97       	sbiw	r24, 0x00	; 0
  34:	01 f0       	breq	.+0      	; 0x36 <__vector_3+0x36>
  36:	e0 91 00 00 	lds	r30, 0x0000
  3a:	f0 91 00 00 	lds	r31, 0x0000
  3e:	09 95       	icall
  40:	cf 91       	pop	r28
	{
	case EXTI_INT0_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT0_TRIG_MASK;
  42:	df 91       	pop	r29
  44:	ff 91       	pop	r31
  46:	ef 91       	pop	r30
  48:	bf 91       	pop	r27
  4a:	af 91       	pop	r26
  4c:	9f 91       	pop	r25
  4e:	8f 91       	pop	r24
		// step 2 : insert value
		MCUCR_REG |= copy_u8Sense;
  50:	7f 91       	pop	r23
  52:	6f 91       	pop	r22
  54:	5f 91       	pop	r21
  56:	4f 91       	pop	r20
  58:	3f 91       	pop	r19
  5a:	2f 91       	pop	r18
  5c:	0f 90       	pop	r0
  5e:	0f be       	out	0x3f, r0	; 63
  60:	0f 90       	pop	r0
		break;
	case EXTI_INT1_ID:
		// step 1 : Apply Mask
		MCUCR_REG &= EXTI_INT1_TRIG_MASK;
  62:	1f 90       	pop	r1
  64:	18 95       	reti

Dio_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000420  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000003fb  00000000  00000000  00000454  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.M_Dio_void_setPinDir 00000230  00000000  00000000  0000084f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.M_Dio_void_setPinValue 0000022e  00000000  00000000  00000a7f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.M_Dio_void_getPinValue 00000108  00000000  00000000  00000cad  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.M_Dio_void_TogPinValue 000000fc  00000000  00000000  00000db5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.M_Dio_void_setPinDir:

00000000 <M_Dio_void_setPinDir>:
#include "Dio_config.h"
#include "Dio_int.h"


void M_Dio_void_setPinDir(u8 port,u8 pin,u8 dir )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	2d 97       	sbiw	r28, 0x0d	; 13
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 83       	std	Y+1, r24	; 0x01
  16:	6a 83       	std	Y+2, r22	; 0x02
  18:	4b 83       	std	Y+3, r20	; 0x03
  switch (port)
  1a:	89 81       	ldd	r24, Y+1	; 0x01
  1c:	28 2f       	mov	r18, r24
  1e:	30 e0       	ldi	r19, 0x00	; 0
  20:	3d 87       	std	Y+13, r19	; 0x0d
  22:	2c 87       	std	Y+12, r18	; 0x0c
  24:	8c 85       	ldd	r24, Y+12	; 0x0c
  26:	9d 85       	ldd	r25, Y+13	; 0x0d
  28:	82 30       	cpi	r24, 0x02	; 2
  2a:	91 05       	cpc	r25, r1
  2c:	01 f4       	brne	.+0      	; 0x2e <M_Dio_void_setPinDir+0x2e>
  2e:	00 c0       	rjmp	.+0      	; 0x30 <M_Dio_void_setPinDir+0x30>
  30:	2c 85       	ldd	r18, Y+12	; 0x0c
  32:	3d 85       	ldd	r19, Y+13	; 0x0d
  34:	23 30       	cpi	r18, 0x03	; 3
  36:	31 05       	cpc	r19, r1
  38:	04 f4       	brge	.+0      	; 0x3a <M_Dio_void_setPinDir+0x3a>
  3a:	8c 85       	ldd	r24, Y+12	; 0x0c
  3c:	9d 85       	ldd	r25, Y+13	; 0x0d
  3e:	81 30       	cpi	r24, 0x01	; 1
  40:	91 05       	cpc	r25, r1
  42:	01 f0       	breq	.+0      	; 0x44 <M_Dio_void_setPinDir+0x44>
  44:	00 c0       	rjmp	.+0      	; 0x46 <M_Dio_void_setPinDir+0x46>
  46:	2c 85       	ldd	r18, Y+12	; 0x0c
  48:	3d 85       	ldd	r19, Y+13	; 0x0d
  4a:	23 30       	cpi	r18, 0x03	; 3
  4c:	31 05       	cpc	r19, r1
  4e:	01 f4       	brne	.+0      	; 0x50 <M_Dio_void_setPinDir+0x50>
  50:	00 c0       	rjmp	.+0      	; 0x52 <M_Dio_void_setPinDir+0x52>
  52:	8c 85       	ldd	r24, Y+12	; 0x0c
  54:	9d 85       	ldd	r25, Y+13	; 0x0d
  56:	84 30       	cpi	r24, 0x04	; 4
  58:	91 05       	cpc	r25, r1
  5a:	01 f4       	brne	.+0      	; 0x5c <M_Dio_void_setPinDir+0x5c>
  5c:	00 c0       	rjmp	.+0      	; 0x5e <M_Dio_void_setPinDir+0x5e>
  5e:	00 c0       	rjmp	.+0      	; 0x60 <M_Dio_void_setPinDir+0x60>
  {
  case PORTA_ID:
	  switch(dir)
  60:	8b 81       	ldd	r24, Y+3	; 0x03
  62:	28 2f       	mov	r18, r24
  64:	30 e0       	ldi	r19, 0x00	; 0
  66:	3b 87       	std	Y+11, r19	; 0x0b
  68:	2a 87       	std	Y+10, r18	; 0x0a
  6a:	8a 85       	ldd	r24, Y+10	; 0x0a
  6c:	9b 85       	ldd	r25, Y+11	; 0x0b
  6e:	00 97       	sbiw	r24, 0x00	; 0
  70:	01 f0       	breq	.+0      	; 0x72 <M_Dio_void_setPinDir+0x72>
  72:	2a 85       	ldd	r18, Y+10	; 0x0a
  74:	3b 85       	ldd	r19, Y+11	; 0x0b
  76:	21 30       	cpi	r18, 0x01	; 1
  78:	31 05       	cpc	r19, r1
  7a:	01 f0       	breq	.+0      	; 0x7c <M_Dio_void_setPinDir+0x7c>
  7c:	00 c0       	rjmp	.+0      	; 0x7e <M_Dio_void_setPinDir+0x7e>
	  {
	  case  INPUT:
		  CLR_BIT(DDRA_REG,pin);
  7e:	aa e3       	ldi	r26, 0x3A	; 58
  80:	b0 e0       	ldi	r27, 0x00	; 0
  82:	ea e3       	ldi	r30, 0x3A	; 58
  84:	f0 e0       	ldi	r31, 0x00	; 0
  86:	80 81       	ld	r24, Z
  88:	48 2f       	mov	r20, r24
  8a:	8a 81       	ldd	r24, Y+2	; 0x02
  8c:	28 2f       	mov	r18, r24
  8e:	30 e0       	ldi	r19, 0x00	; 0
  90:	81 e0       	ldi	r24, 0x01	; 1
  92:	90 e0       	ldi	r25, 0x00	; 0
  94:	02 2e       	mov	r0, r18
  96:	00 c0       	rjmp	.+0      	; 0x98 <M_Dio_void_setPinDir+0x98>
  98:	88 0f       	add	r24, r24
  9a:	99 1f       	adc	r25, r25
  9c:	0a 94       	dec	r0
  9e:	02 f4       	brpl	.+0      	; 0xa0 <M_Dio_void_setPinDir+0xa0>
  a0:	80 95       	com	r24
  a2:	84 23       	and	r24, r20
  a4:	8c 93       	st	X, r24
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <M_Dio_void_setPinDir+0xa8>
		  break;
	  case  OUPUT:
		  SET_BIT(DDRA_REG,pin);
  a8:	aa e3       	ldi	r26, 0x3A	; 58
  aa:	b0 e0       	ldi	r27, 0x00	; 0
  ac:	ea e3       	ldi	r30, 0x3A	; 58
  ae:	f0 e0       	ldi	r31, 0x00	; 0
  b0:	80 81       	ld	r24, Z
  b2:	48 2f       	mov	r20, r24
  b4:	8a 81       	ldd	r24, Y+2	; 0x02
  b6:	28 2f       	mov	r18, r24
  b8:	30 e0       	ldi	r19, 0x00	; 0
  ba:	81 e0       	ldi	r24, 0x01	; 1
  bc:	90 e0       	ldi	r25, 0x00	; 0
  be:	02 2e       	mov	r0, r18
  c0:	00 c0       	rjmp	.+0      	; 0xc2 <M_Dio_void_setPinDir+0xc2>
  c2:	88 0f       	add	r24, r24
  c4:	99 1f       	adc	r25, r25
  c6:	0a 94       	dec	r0
  c8:	02 f4       	brpl	.+0      	; 0xca <M_Dio_void_setPinDir+0xca>
  ca:	84 2b       	or	r24, r20
  cc:	8c 93       	st	X, r24
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <M_Dio_void_setPinDir+0xd0>
		  break;

	  }
	  break;
  case PORTB_ID:
	  switch(dir)
  d0:	8b 81       	ldd	r24, Y+3	; 0x03
  d2:	28 2f       	mov	r18, r24
  d4:	30 e0       	ldi	r19, 0x00	; 0
  d6:	39 87       	std	Y+9, r19	; 0x09
  d8:	28 87       	std	Y+8, r18	; 0x08
  da:	88 85       	ldd	r24, Y+8	; 0x08
  dc:	99 85       	ldd	r25, Y+9	; 0x09
  de:	00 97       	sbiw	r24, 0x00	; 0
  e0:	01 f0       	breq	.+0      	; 0xe2 <M_Dio_void_setPinDir+0xe2>
  e2:	28 85       	ldd	r18, Y+8	; 0x08
  e4:	39 85       	ldd	r19, Y+9	; 0x09
  e6:	21 30       	cpi	r18, 0x01	; 1
  e8:	31 05       	cpc	r19, r1
  ea:	01 f0       	breq	.+0      	; 0xec <M_Dio_void_setPinDir+0xec>
  ec:	00 c0       	rjmp	.+0      	; 0xee <M_Dio_void_setPinDir+0xee>
	  	  {
	  	  case  INPUT:
	  		  CLR_BIT(DDRB_REG,pin);
  ee:	a7 e3       	ldi	r26, 0x37	; 55
  f0:	b0 e0       	ldi	r27, 0x00	; 0
  f2:	e7 e3       	ldi	r30, 0x37	; 55
  f4:	f0 e0       	ldi	r31, 0x00	; 0
  f6:	80 81       	ld	r24, Z
  f8:	48 2f       	mov	r20, r24
  fa:	8a 81       	ldd	r24, Y+2	; 0x02
  fc:	28 2f       	mov	r18, r24
  fe:	30 e0       	ldi	r19, 0x00	; 0
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	02 2e       	mov	r0, r18
 106:	00 c0       	rjmp	.+0      	; 0x108 <M_Dio_void_setPinDir+0x108>
 108:	88 0f       	add	r24, r24
 10a:	99 1f       	adc	r25, r25
 10c:	0a 94       	dec	r0
 10e:	02 f4       	brpl	.+0      	; 0x110 <M_Dio_void_setPinDir+0x110>
 110:	80 95       	com	r24
 112:	84 23       	and	r24, r20
 114:	8c 93       	st	X, r24
 116:	00 c0       	rjmp	.+0      	; 0x118 <M_Dio_void_setPinDir+0x118>
	  		  break;
	  	  case  OUPUT:
	  		  SET_BIT(DDRB_REG,pin);
 118:	a7 e3       	ldi	r26, 0x37	; 55
 11a:	b0 e0       	ldi	r27, 0x00	; 0
 11c:	e7 e3       	ldi	r30, 0x37	; 55
 11e:	f0 e0       	ldi	r31, 0x00	; 0
 120:	80 81       	ld	r24, Z
 122:	48 2f       	mov	r20, r24
 124:	8a 81       	ldd	r24, Y+2	; 0x02
 126:	28 2f       	mov	r18, r24
 128:	30 e0       	ldi	r19, 0x00	; 0
 12a:	81 e0       	ldi	r24, 0x01	; 1
 12c:	90 e0       	ldi	r25, 0x00	; 0
 12e:	02 2e       	mov	r0, r18
 130:	00 c0       	rjmp	.+0      	; 0x132 <M_Dio_void_setPinDir+0x132>
 132:	88 0f       	add	r24, r24
 134:	99 1f       	adc	r25, r25
 136:	0a 94       	dec	r0
 138:	02 f4       	brpl	.+0      	; 0x13a <M_Dio_void_setPinDir+0x13a>
 13a:	84 2b       	or	r24, r20
 13c:	8c 93       	st	X, r24
 13e:	00 c0       	rjmp	.+0      	; 0x140 <M_Dio_void_setPinDir+0x140>
	  		  break;

	  	  }
 	  break;
  case PORTC_ID:
	  switch(dir)
 140:	8b 81       	ldd	r24, Y+3	; 0x03
 142:	28 2f       	mov	r18, r24
 144:	30 e0       	ldi	r19, 0x00	; 0
 146:	3f 83       	std	Y+7, r19	; 0x07
 148:	2e 83       	std	Y+6, r18	; 0x06
 14a:	8e 81       	ldd	r24, Y+6	; 0x06
 14c:	9f 81       	ldd	r25, Y+7	; 0x07
 14e:	00 97       	sbiw	r24, 0x00	; 0
 150:	01 f0       	breq	.+0      	; 0x152 <M_Dio_void_setPinDir+0x152>
 152:	2e 81       	ldd	r18, Y+6	; 0x06
 154:	3f 81       	ldd	r19, Y+7	; 0x07
 156:	21 30       	cpi	r18, 0x01	; 1
 158:	31 05       	cpc	r19, r1
 15a:	01 f0       	breq	.+0      	; 0x15c <M_Dio_void_setPinDir+0x15c>
 15c:	00 c0       	rjmp	.+0      	; 0x15e <M_Dio_void_setPinDir+0x15e>
	  	  {
	  	  case  INPUT:
	  		  CLR_BIT(DDRC_REG,pin);
 15e:	a4 e3       	ldi	r26, 0x34	; 52
 160:	b0 e0       	ldi	r27, 0x00	; 0
 162:	e4 e3       	ldi	r30, 0x34	; 52
 164:	f0 e0       	ldi	r31, 0x00	; 0
 166:	80 81       	ld	r24, Z
 168:	48 2f       	mov	r20, r24
 16a:	8a 81       	ldd	r24, Y+2	; 0x02
 16c:	28 2f       	mov	r18, r24
 16e:	30 e0       	ldi	r19, 0x00	; 0
 170:	81 e0       	ldi	r24, 0x01	; 1
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	02 2e       	mov	r0, r18
 176:	00 c0       	rjmp	.+0      	; 0x178 <M_Dio_void_setPinDir+0x178>
 178:	88 0f       	add	r24, r24
 17a:	99 1f       	adc	r25, r25
 17c:	0a 94       	dec	r0
 17e:	02 f4       	brpl	.+0      	; 0x180 <M_Dio_void_setPinDir+0x180>
 180:	80 95       	com	r24
 182:	84 23       	and	r24, r20
 184:	8c 93       	st	X, r24
 186:	00 c0       	rjmp	.+0      	; 0x188 <M_Dio_void_setPinDir+0x188>
	  		  break;
	  	  case  OUPUT:
	  		  SET_BIT(DDRC_REG,pin);
 188:	a4 e3       	ldi	r26, 0x34	; 52
 18a:	b0 e0       	ldi	r27, 0x00	; 0
 18c:	e4 e3       	ldi	r30, 0x34	; 52
 18e:	f0 e0       	ldi	r31, 0x00	; 0
 190:	80 81       	ld	r24, Z
 192:	48 2f       	mov	r20, r24
 194:	8a 81       	ldd	r24, Y+2	; 0x02
 196:	28 2f       	mov	r18, r24
 198:	30 e0       	ldi	r19, 0x00	; 0
 19a:	81 e0       	ldi	r24, 0x01	; 1
 19c:	90 e0       	ldi	r25, 0x00	; 0
 19e:	02 2e       	mov	r0, r18
 1a0:	00 c0       	rjmp	.+0      	; 0x1a2 <M_Dio_void_setPinDir+0x1a2>
 1a2:	88 0f       	add	r24, r24
 1a4:	99 1f       	adc	r25, r25
 1a6:	0a 94       	dec	r0
 1a8:	02 f4       	brpl	.+0      	; 0x1aa <M_Dio_void_setPinDir+0x1aa>
 1aa:	84 2b       	or	r24, r20
 1ac:	8c 93       	st	X, r24
 1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <M_Dio_void_setPinDir+0x1b0>
	  		  break;

	  	  }
 	  break;
  case PORTD_ID:
	  switch(dir)
 1b0:	8b 81       	ldd	r24, Y+3	; 0x03
 1b2:	28 2f       	mov	r18, r24
 1b4:	30 e0       	ldi	r19, 0x00	; 0
 1b6:	3d 83       	std	Y+5, r19	; 0x05
 1b8:	2c 83       	std	Y+4, r18	; 0x04
 1ba:	8c 81       	ldd	r24, Y+4	; 0x04
 1bc:	9d 81       	ldd	r25, Y+5	; 0x05
 1be:	00 97       	sbiw	r24, 0x00	; 0
 1c0:	01 f0       	breq	.+0      	; 0x1c2 <M_Dio_void_setPinDir+0x1c2>
 1c2:	2c 81       	ldd	r18, Y+4	; 0x04
 1c4:	3d 81       	ldd	r19, Y+5	; 0x05
 1c6:	21 30       	cpi	r18, 0x01	; 1
 1c8:	31 05       	cpc	r19, r1
 1ca:	01 f0       	breq	.+0      	; 0x1cc <M_Dio_void_setPinDir+0x1cc>
 1cc:	00 c0       	rjmp	.+0      	; 0x1ce <M_Dio_void_setPinDir+0x1ce>
	  	  {
	  	  case  INPUT:
	  		  CLR_BIT(DDRD_REG,pin);
 1ce:	a1 e3       	ldi	r26, 0x31	; 49
 1d0:	b0 e0       	ldi	r27, 0x00	; 0
 1d2:	e1 e3       	ldi	r30, 0x31	; 49
 1d4:	f0 e0       	ldi	r31, 0x00	; 0
 1d6:	80 81       	ld	r24, Z
 1d8:	48 2f       	mov	r20, r24
 1da:	8a 81       	ldd	r24, Y+2	; 0x02
 1dc:	28 2f       	mov	r18, r24
 1de:	30 e0       	ldi	r19, 0x00	; 0
 1e0:	81 e0       	ldi	r24, 0x01	; 1
 1e2:	90 e0       	ldi	r25, 0x00	; 0
 1e4:	02 2e       	mov	r0, r18
 1e6:	00 c0       	rjmp	.+0      	; 0x1e8 <M_Dio_void_setPinDir+0x1e8>
 1e8:	88 0f       	add	r24, r24
 1ea:	99 1f       	adc	r25, r25
 1ec:	0a 94       	dec	r0
 1ee:	02 f4       	brpl	.+0      	; 0x1f0 <M_Dio_void_setPinDir+0x1f0>
 1f0:	80 95       	com	r24
 1f2:	84 23       	and	r24, r20
 1f4:	8c 93       	st	X, r24
 1f6:	00 c0       	rjmp	.+0      	; 0x1f8 <M_Dio_void_setPinDir+0x1f8>
	  		  break;
	  	  case  OUPUT:
	  		  SET_BIT(DDRD_REG,pin);
 1f8:	a1 e3       	ldi	r26, 0x31	; 49
 1fa:	b0 e0       	ldi	r27, 0x00	; 0
 1fc:	e1 e3       	ldi	r30, 0x31	; 49
 1fe:	f0 e0       	ldi	r31, 0x00	; 0
 200:	80 81       	ld	r24, Z
 202:	48 2f       	mov	r20, r24
 204:	8a 81       	ldd	r24, Y+2	; 0x02
 206:	28 2f       	mov	r18, r24
 208:	30 e0       	ldi	r19, 0x00	; 0
 20a:	81 e0       	ldi	r24, 0x01	; 1
 20c:	90 e0       	ldi	r25, 0x00	; 0
 20e:	02 2e       	mov	r0, r18
 210:	00 c0       	rjmp	.+0      	; 0x212 <M_Dio_void_setPinDir+0x212>
 212:	88 0f       	add	r24, r24
 214:	99 1f       	adc	r25, r25
 216:	0a 94       	dec	r0
 218:	02 f4       	brpl	.+0      	; 0x21a <M_Dio_void_setPinDir+0x21a>
 21a:	84 2b       	or	r24, r20
 21c:	8c 93       	st	X, r24
	  	  }
 	  break;
  }


}
 21e:	2d 96       	adiw	r28, 0x0d	; 13
 220:	0f b6       	in	r0, 0x3f	; 63
 222:	f8 94       	cli
 224:	de bf       	out	0x3e, r29	; 62
 226:	0f be       	out	0x3f, r0	; 63
 228:	cd bf       	out	0x3d, r28	; 61
 22a:	cf 91       	pop	r28
 22c:	df 91       	pop	r29
 22e:	08 95       	ret

Disassembly of section .text.M_Dio_void_setPinValue:

00000000 <M_Dio_void_setPinValue>:
#include "Dio_config.h"
#include "Dio_int.h"


void M_Dio_void_setPinDir(u8 port,u8 pin,u8 dir )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	2d 97       	sbiw	r28, 0x0d	; 13
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 83       	std	Y+1, r24	; 0x01
  16:	6a 83       	std	Y+2, r22	; 0x02
  18:	4b 83       	std	Y+3, r20	; 0x03
  switch (port)
  1a:	89 81       	ldd	r24, Y+1	; 0x01
  1c:	28 2f       	mov	r18, r24
  1e:	30 e0       	ldi	r19, 0x00	; 0
  20:	3d 87       	std	Y+13, r19	; 0x0d
  22:	2c 87       	std	Y+12, r18	; 0x0c
  24:	8c 85       	ldd	r24, Y+12	; 0x0c
  26:	9d 85       	ldd	r25, Y+13	; 0x0d
  28:	82 30       	cpi	r24, 0x02	; 2
  2a:	91 05       	cpc	r25, r1
  2c:	01 f4       	brne	.+0      	; 0x2e <M_Dio_void_setPinValue+0x2e>
  2e:	00 c0       	rjmp	.+0      	; 0x30 <M_Dio_void_setPinValue+0x30>
  30:	2c 85       	ldd	r18, Y+12	; 0x0c
  32:	3d 85       	ldd	r19, Y+13	; 0x0d
  34:	23 30       	cpi	r18, 0x03	; 3
  36:	31 05       	cpc	r19, r1
  38:	04 f4       	brge	.+0      	; 0x3a <M_Dio_void_setPinValue+0x3a>
  3a:	8c 85       	ldd	r24, Y+12	; 0x0c
  3c:	9d 85       	ldd	r25, Y+13	; 0x0d
  3e:	81 30       	cpi	r24, 0x01	; 1
  40:	91 05       	cpc	r25, r1
  42:	01 f0       	breq	.+0      	; 0x44 <M_Dio_void_setPinValue+0x44>
  44:	00 c0       	rjmp	.+0      	; 0x46 <M_Dio_void_setPinValue+0x46>
  46:	2c 85       	ldd	r18, Y+12	; 0x0c
  48:	3d 85       	ldd	r19, Y+13	; 0x0d
  4a:	23 30       	cpi	r18, 0x03	; 3
  4c:	31 05       	cpc	r19, r1
  4e:	01 f4       	brne	.+0      	; 0x50 <M_Dio_void_setPinValue+0x50>
  50:	00 c0       	rjmp	.+0      	; 0x52 <M_Dio_void_setPinValue+0x52>
  52:	8c 85       	ldd	r24, Y+12	; 0x0c
  54:	9d 85       	ldd	r25, Y+13	; 0x0d
  56:	84 30       	cpi	r24, 0x04	; 4
  58:	91 05       	cpc	r25, r1
  5a:	01 f4       	brne	.+0      	; 0x5c <M_Dio_void_setPinValue+0x5c>
  5c:	00 c0       	rjmp	.+0      	; 0x5e <M_Dio_void_setPinValue+0x5e>
  5e:	00 c0       	rjmp	.+0      	; 0x60 <M_Dio_void_setPinValue+0x60>
  {
  case PORTA_ID:
	  switch(dir)
  60:	8b 81       	ldd	r24, Y+3	; 0x03
  62:	28 2f       	mov	r18, r24
  64:	30 e0       	ldi	r19, 0x00	; 0
  66:	3b 87       	std	Y+11, r19	; 0x0b
  68:	2a 87       	std	Y+10, r18	; 0x0a
  6a:	8a 85       	ldd	r24, Y+10	; 0x0a
  6c:	9b 85       	ldd	r25, Y+11	; 0x0b
  6e:	00 97       	sbiw	r24, 0x00	; 0
  70:	01 f0       	breq	.+0      	; 0x72 <M_Dio_void_setPinValue+0x72>
  72:	2a 85       	ldd	r18, Y+10	; 0x0a
  74:	3b 85       	ldd	r19, Y+11	; 0x0b
  76:	21 30       	cpi	r18, 0x01	; 1
  78:	31 05       	cpc	r19, r1
  7a:	01 f0       	breq	.+0      	; 0x7c <M_Dio_void_setPinValue+0x7c>
  7c:	00 c0       	rjmp	.+0      	; 0x7e <M_Dio_void_setPinValue+0x7e>
	  {
	  case  INPUT:
		  CLR_BIT(DDRA_REG,pin);
  7e:	ab e3       	ldi	r26, 0x3B	; 59
  80:	b0 e0       	ldi	r27, 0x00	; 0
  82:	eb e3       	ldi	r30, 0x3B	; 59
  84:	f0 e0       	ldi	r31, 0x00	; 0
  86:	80 81       	ld	r24, Z
  88:	48 2f       	mov	r20, r24
  8a:	8a 81       	ldd	r24, Y+2	; 0x02
  8c:	28 2f       	mov	r18, r24
  8e:	30 e0       	ldi	r19, 0x00	; 0
  90:	81 e0       	ldi	r24, 0x01	; 1
  92:	90 e0       	ldi	r25, 0x00	; 0
  94:	02 2e       	mov	r0, r18
  96:	00 c0       	rjmp	.+0      	; 0x98 <M_Dio_void_setPinValue+0x98>
  98:	88 0f       	add	r24, r24
  9a:	99 1f       	adc	r25, r25
  9c:	0a 94       	dec	r0
  9e:	02 f4       	brpl	.+0      	; 0xa0 <M_Dio_void_setPinValue+0xa0>
  a0:	84 2b       	or	r24, r20
  a2:	8c 93       	st	X, r24
  a4:	00 c0       	rjmp	.+0      	; 0xa6 <M_Dio_void_setPinValue+0xa6>
  a6:	ab e3       	ldi	r26, 0x3B	; 59
		  break;
	  case  OUPUT:
		  SET_BIT(DDRA_REG,pin);
  a8:	b0 e0       	ldi	r27, 0x00	; 0
  aa:	eb e3       	ldi	r30, 0x3B	; 59
  ac:	f0 e0       	ldi	r31, 0x00	; 0
  ae:	80 81       	ld	r24, Z
  b0:	48 2f       	mov	r20, r24
  b2:	8a 81       	ldd	r24, Y+2	; 0x02
  b4:	28 2f       	mov	r18, r24
  b6:	30 e0       	ldi	r19, 0x00	; 0
  b8:	81 e0       	ldi	r24, 0x01	; 1
  ba:	90 e0       	ldi	r25, 0x00	; 0
  bc:	02 2e       	mov	r0, r18
  be:	00 c0       	rjmp	.+0      	; 0xc0 <M_Dio_void_setPinValue+0xc0>
  c0:	88 0f       	add	r24, r24
  c2:	99 1f       	adc	r25, r25
  c4:	0a 94       	dec	r0
  c6:	02 f4       	brpl	.+0      	; 0xc8 <M_Dio_void_setPinValue+0xc8>
  c8:	80 95       	com	r24
  ca:	84 23       	and	r24, r20
  cc:	8c 93       	st	X, r24
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <M_Dio_void_setPinValue+0xd0>
		  break;

	  }
	  break;
  case PORTB_ID:
	  switch(dir)
  d0:	8b 81       	ldd	r24, Y+3	; 0x03
  d2:	28 2f       	mov	r18, r24
  d4:	30 e0       	ldi	r19, 0x00	; 0
  d6:	39 87       	std	Y+9, r19	; 0x09
  d8:	28 87       	std	Y+8, r18	; 0x08
  da:	88 85       	ldd	r24, Y+8	; 0x08
  dc:	99 85       	ldd	r25, Y+9	; 0x09
  de:	00 97       	sbiw	r24, 0x00	; 0
  e0:	01 f0       	breq	.+0      	; 0xe2 <M_Dio_void_setPinValue+0xe2>
  e2:	28 85       	ldd	r18, Y+8	; 0x08
  e4:	39 85       	ldd	r19, Y+9	; 0x09
  e6:	21 30       	cpi	r18, 0x01	; 1
  e8:	31 05       	cpc	r19, r1
  ea:	01 f0       	breq	.+0      	; 0xec <M_Dio_void_setPinValue+0xec>
  ec:	00 c0       	rjmp	.+0      	; 0xee <M_Dio_void_setPinValue+0xee>
	  	  {
	  	  case  INPUT:
	  		  CLR_BIT(DDRB_REG,pin);
  ee:	a8 e3       	ldi	r26, 0x38	; 56
  f0:	b0 e0       	ldi	r27, 0x00	; 0
  f2:	e8 e3       	ldi	r30, 0x38	; 56
  f4:	f0 e0       	ldi	r31, 0x00	; 0
  f6:	80 81       	ld	r24, Z
  f8:	48 2f       	mov	r20, r24
  fa:	8a 81       	ldd	r24, Y+2	; 0x02
  fc:	28 2f       	mov	r18, r24
  fe:	30 e0       	ldi	r19, 0x00	; 0
 100:	81 e0       	ldi	r24, 0x01	; 1
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	02 2e       	mov	r0, r18
 106:	00 c0       	rjmp	.+0      	; 0x108 <M_Dio_void_setPinValue+0x108>
 108:	88 0f       	add	r24, r24
 10a:	99 1f       	adc	r25, r25
 10c:	0a 94       	dec	r0
 10e:	02 f4       	brpl	.+0      	; 0x110 <M_Dio_void_setPinValue+0x110>
 110:	84 2b       	or	r24, r20
 112:	8c 93       	st	X, r24
 114:	00 c0       	rjmp	.+0      	; 0x116 <M_Dio_void_setPinValue+0x116>
 116:	a8 e3       	ldi	r26, 0x38	; 56
	  		  break;
	  	  case  OUPUT:
	  		  SET_BIT(DDRB_REG,pin);
 118:	b0 e0       	ldi	r27, 0x00	; 0
 11a:	e8 e3       	ldi	r30, 0x38	; 56
 11c:	f0 e0       	ldi	r31, 0x00	; 0
 11e:	80 81       	ld	r24, Z
 120:	48 2f       	mov	r20, r24
 122:	8a 81       	ldd	r24, Y+2	; 0x02
 124:	28 2f       	mov	r18, r24
 126:	30 e0       	ldi	r19, 0x00	; 0
 128:	81 e0       	ldi	r24, 0x01	; 1
 12a:	90 e0       	ldi	r25, 0x00	; 0
 12c:	02 2e       	mov	r0, r18
 12e:	00 c0       	rjmp	.+0      	; 0x130 <M_Dio_void_setPinValue+0x130>
 130:	88 0f       	add	r24, r24
 132:	99 1f       	adc	r25, r25
 134:	0a 94       	dec	r0
 136:	02 f4       	brpl	.+0      	; 0x138 <M_Dio_void_setPinValue+0x138>
 138:	80 95       	com	r24
 13a:	84 23       	and	r24, r20
 13c:	8c 93       	st	X, r24
 13e:	00 c0       	rjmp	.+0      	; 0x140 <M_Dio_void_setPinValue+0x140>
	  		  break;

	  	  }
 	  break;
  case PORTC_ID:
	  switch(dir)
 140:	8b 81       	ldd	r24, Y+3	; 0x03
 142:	28 2f       	mov	r18, r24
 144:	30 e0       	ldi	r19, 0x00	; 0
 146:	3f 83       	std	Y+7, r19	; 0x07
 148:	2e 83       	std	Y+6, r18	; 0x06
 14a:	8e 81       	ldd	r24, Y+6	; 0x06
 14c:	9f 81       	ldd	r25, Y+7	; 0x07
 14e:	00 97       	sbiw	r24, 0x00	; 0
 150:	01 f0       	breq	.+0      	; 0x152 <M_Dio_void_setPinValue+0x152>
 152:	2e 81       	ldd	r18, Y+6	; 0x06
 154:	3f 81       	ldd	r19, Y+7	; 0x07
 156:	21 30       	cpi	r18, 0x01	; 1
 158:	31 05       	cpc	r19, r1
 15a:	01 f0       	breq	.+0      	; 0x15c <M_Dio_void_setPinValue+0x15c>
 15c:	00 c0       	rjmp	.+0      	; 0x15e <M_Dio_void_setPinValue+0x15e>
	  	  {
	  	  case  INPUT:
	  		  CLR_BIT(DDRC_REG,pin);
 15e:	a5 e3       	ldi	r26, 0x35	; 53
 160:	b0 e0       	ldi	r27, 0x00	; 0
 162:	e5 e3       	ldi	r30, 0x35	; 53
 164:	f0 e0       	ldi	r31, 0x00	; 0
 166:	80 81       	ld	r24, Z
 168:	48 2f       	mov	r20, r24
 16a:	8a 81       	ldd	r24, Y+2	; 0x02
 16c:	28 2f       	mov	r18, r24
 16e:	30 e0       	ldi	r19, 0x00	; 0
 170:	81 e0       	ldi	r24, 0x01	; 1
 172:	90 e0       	ldi	r25, 0x00	; 0
 174:	02 2e       	mov	r0, r18
 176:	00 c0       	rjmp	.+0      	; 0x178 <M_Dio_void_setPinValue+0x178>
 178:	88 0f       	add	r24, r24
 17a:	99 1f       	adc	r25, r25
 17c:	0a 94       	dec	r0
 17e:	02 f4       	brpl	.+0      	; 0x180 <M_Dio_void_setPinValue+0x180>
 180:	84 2b       	or	r24, r20
 182:	8c 93       	st	X, r24
 184:	00 c0       	rjmp	.+0      	; 0x186 <M_Dio_void_setPinValue+0x186>
 186:	a5 e3       	ldi	r26, 0x35	; 53
	  		  break;
	  	  case  OUPUT:
	  		  SET_BIT(DDRC_REG,pin);
 188:	b0 e0       	ldi	r27, 0x00	; 0
 18a:	e5 e3       	ldi	r30, 0x35	; 53
 18c:	f0 e0       	ldi	r31, 0x00	; 0
 18e:	80 81       	ld	r24, Z
 190:	48 2f       	mov	r20, r24
 192:	8a 81       	ldd	r24, Y+2	; 0x02
 194:	28 2f       	mov	r18, r24
 196:	30 e0       	ldi	r19, 0x00	; 0
 198:	81 e0       	ldi	r24, 0x01	; 1
 19a:	90 e0       	ldi	r25, 0x00	; 0
 19c:	02 2e       	mov	r0, r18
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <M_Dio_void_setPinValue+0x1a0>
 1a0:	88 0f       	add	r24, r24
 1a2:	99 1f       	adc	r25, r25
 1a4:	0a 94       	dec	r0
 1a6:	02 f4       	brpl	.+0      	; 0x1a8 <M_Dio_void_setPinValue+0x1a8>
 1a8:	80 95       	com	r24
 1aa:	84 23       	and	r24, r20
 1ac:	8c 93       	st	X, r24
 1ae:	00 c0       	rjmp	.+0      	; 0x1b0 <M_Dio_void_setPinValue+0x1b0>
	  		  break;

	  	  }
 	  break;
  case PORTD_ID:
	  switch(dir)
 1b0:	8b 81       	ldd	r24, Y+3	; 0x03
 1b2:	28 2f       	mov	r18, r24
 1b4:	30 e0       	ldi	r19, 0x00	; 0
 1b6:	3d 83       	std	Y+5, r19	; 0x05
 1b8:	2c 83       	std	Y+4, r18	; 0x04
 1ba:	8c 81       	ldd	r24, Y+4	; 0x04
 1bc:	9d 81       	ldd	r25, Y+5	; 0x05
 1be:	00 97       	sbiw	r24, 0x00	; 0
 1c0:	01 f0       	breq	.+0      	; 0x1c2 <M_Dio_void_setPinValue+0x1c2>
 1c2:	2c 81       	ldd	r18, Y+4	; 0x04
 1c4:	3d 81       	ldd	r19, Y+5	; 0x05
 1c6:	21 30       	cpi	r18, 0x01	; 1
 1c8:	31 05       	cpc	r19, r1
 1ca:	01 f4       	brne	.+0      	; 0x1cc <M_Dio_void_setPinValue+0x1cc>
 1cc:	a2 e3       	ldi	r26, 0x32	; 50
	  	  {
	  	  case  INPUT:
	  		  CLR_BIT(DDRD_REG,pin);
 1ce:	b0 e0       	ldi	r27, 0x00	; 0
 1d0:	e2 e3       	ldi	r30, 0x32	; 50
 1d2:	f0 e0       	ldi	r31, 0x00	; 0
 1d4:	80 81       	ld	r24, Z
 1d6:	48 2f       	mov	r20, r24
 1d8:	8a 81       	ldd	r24, Y+2	; 0x02
 1da:	28 2f       	mov	r18, r24
 1dc:	30 e0       	ldi	r19, 0x00	; 0
 1de:	81 e0       	ldi	r24, 0x01	; 1
 1e0:	90 e0       	ldi	r25, 0x00	; 0
 1e2:	02 2e       	mov	r0, r18
 1e4:	00 c0       	rjmp	.+0      	; 0x1e6 <M_Dio_void_setPinValue+0x1e6>
 1e6:	88 0f       	add	r24, r24
 1e8:	99 1f       	adc	r25, r25
 1ea:	0a 94       	dec	r0
 1ec:	02 f4       	brpl	.+0      	; 0x1ee <M_Dio_void_setPinValue+0x1ee>
 1ee:	84 2b       	or	r24, r20
 1f0:	8c 93       	st	X, r24
 1f2:	00 c0       	rjmp	.+0      	; 0x1f4 <M_Dio_void_setPinValue+0x1f4>
 1f4:	a2 e3       	ldi	r26, 0x32	; 50
 1f6:	b0 e0       	ldi	r27, 0x00	; 0
	  		  break;
	  	  case  OUPUT:
	  		  SET_BIT(DDRD_REG,pin);
 1f8:	e2 e3       	ldi	r30, 0x32	; 50
 1fa:	f0 e0       	ldi	r31, 0x00	; 0
 1fc:	80 81       	ld	r24, Z
 1fe:	48 2f       	mov	r20, r24
 200:	8a 81       	ldd	r24, Y+2	; 0x02
 202:	28 2f       	mov	r18, r24
 204:	30 e0       	ldi	r19, 0x00	; 0
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	90 e0       	ldi	r25, 0x00	; 0
 20a:	02 2e       	mov	r0, r18
 20c:	00 c0       	rjmp	.+0      	; 0x20e <M_Dio_void_setPinValue+0x20e>
 20e:	88 0f       	add	r24, r24
 210:	99 1f       	adc	r25, r25
 212:	0a 94       	dec	r0
 214:	02 f4       	brpl	.+0      	; 0x216 <M_Dio_void_setPinValue+0x216>
 216:	80 95       	com	r24
 218:	84 23       	and	r24, r20
 21a:	8c 93       	st	X, r24
 21c:	2d 96       	adiw	r28, 0x0d	; 13
	  	  }
 	  break;
  }


}
 21e:	0f b6       	in	r0, 0x3f	; 63
 220:	f8 94       	cli
 222:	de bf       	out	0x3e, r29	; 62
 224:	0f be       	out	0x3f, r0	; 63
 226:	cd bf       	out	0x3d, r28	; 61
 228:	cf 91       	pop	r28
 22a:	df 91       	pop	r29
 22c:	08 95       	ret

Disassembly of section .text.M_Dio_void_getPinValue:

00000000 <M_Dio_void_getPinValue>:
#include "Dio_config.h"
#include "Dio_int.h"


void M_Dio_void_setPinDir(u8 port,u8 pin,u8 dir )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <M_Dio_void_getPinValue+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <M_Dio_void_getPinValue+0x8>
   8:	00 d0       	rcall	.+0      	; 0xa <M_Dio_void_getPinValue+0xa>
   a:	cd b7       	in	r28, 0x3d	; 61
   c:	de b7       	in	r29, 0x3e	; 62
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6a 83       	std	Y+2, r22	; 0x02
  12:	5c 83       	std	Y+4, r21	; 0x04
  14:	4b 83       	std	Y+3, r20	; 0x03
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	28 2f       	mov	r18, r24
  switch (port)
  1a:	30 e0       	ldi	r19, 0x00	; 0
  1c:	3e 83       	std	Y+6, r19	; 0x06
  1e:	2d 83       	std	Y+5, r18	; 0x05
  20:	4d 81       	ldd	r20, Y+5	; 0x05
  22:	5e 81       	ldd	r21, Y+6	; 0x06
  24:	42 30       	cpi	r20, 0x02	; 2
  26:	51 05       	cpc	r21, r1
  28:	01 f0       	breq	.+0      	; 0x2a <M_Dio_void_getPinValue+0x2a>
  2a:	8d 81       	ldd	r24, Y+5	; 0x05
  2c:	9e 81       	ldd	r25, Y+6	; 0x06
  2e:	83 30       	cpi	r24, 0x03	; 3
  30:	91 05       	cpc	r25, r1
  32:	04 f4       	brge	.+0      	; 0x34 <M_Dio_void_getPinValue+0x34>
  34:	2d 81       	ldd	r18, Y+5	; 0x05
  36:	3e 81       	ldd	r19, Y+6	; 0x06
  38:	21 30       	cpi	r18, 0x01	; 1
  3a:	31 05       	cpc	r19, r1
  3c:	01 f0       	breq	.+0      	; 0x3e <M_Dio_void_getPinValue+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <M_Dio_void_getPinValue+0x40>
  40:	4d 81       	ldd	r20, Y+5	; 0x05
  42:	5e 81       	ldd	r21, Y+6	; 0x06
  44:	43 30       	cpi	r20, 0x03	; 3
  46:	51 05       	cpc	r21, r1
  48:	01 f0       	breq	.+0      	; 0x4a <M_Dio_void_getPinValue+0x4a>
  4a:	8d 81       	ldd	r24, Y+5	; 0x05
  4c:	9e 81       	ldd	r25, Y+6	; 0x06
  4e:	84 30       	cpi	r24, 0x04	; 4
  50:	91 05       	cpc	r25, r1
  52:	01 f4       	brne	.+0      	; 0x54 <M_Dio_void_getPinValue+0x54>
  54:	00 c0       	rjmp	.+0      	; 0x56 <M_Dio_void_getPinValue+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <M_Dio_void_getPinValue+0x58>
  58:	e9 e3       	ldi	r30, 0x39	; 57
  5a:	f0 e0       	ldi	r31, 0x00	; 0
  5c:	80 81       	ld	r24, Z
  5e:	28 2f       	mov	r18, r24
  {
  case PORTA_ID:
	  switch(dir)
  60:	30 e0       	ldi	r19, 0x00	; 0
  62:	8a 81       	ldd	r24, Y+2	; 0x02
  64:	88 2f       	mov	r24, r24
  66:	90 e0       	ldi	r25, 0x00	; 0
  68:	a9 01       	movw	r20, r18
  6a:	00 c0       	rjmp	.+0      	; 0x6c <M_Dio_void_getPinValue+0x6c>
  6c:	55 95       	asr	r21
  6e:	47 95       	ror	r20
  70:	8a 95       	dec	r24
  72:	02 f4       	brpl	.+0      	; 0x74 <M_Dio_void_getPinValue+0x74>
  74:	ca 01       	movw	r24, r20
  76:	81 70       	andi	r24, 0x01	; 1
  78:	eb 81       	ldd	r30, Y+3	; 0x03
  7a:	fc 81       	ldd	r31, Y+4	; 0x04
  7c:	80 83       	st	Z, r24
	  {
	  case  INPUT:
		  CLR_BIT(DDRA_REG,pin);
  7e:	00 c0       	rjmp	.+0      	; 0x80 <M_Dio_void_getPinValue+0x80>
  80:	e6 e3       	ldi	r30, 0x36	; 54
  82:	f0 e0       	ldi	r31, 0x00	; 0
  84:	80 81       	ld	r24, Z
  86:	28 2f       	mov	r18, r24
  88:	30 e0       	ldi	r19, 0x00	; 0
  8a:	8a 81       	ldd	r24, Y+2	; 0x02
  8c:	88 2f       	mov	r24, r24
  8e:	90 e0       	ldi	r25, 0x00	; 0
  90:	a9 01       	movw	r20, r18
  92:	00 c0       	rjmp	.+0      	; 0x94 <M_Dio_void_getPinValue+0x94>
  94:	55 95       	asr	r21
  96:	47 95       	ror	r20
  98:	8a 95       	dec	r24
  9a:	02 f4       	brpl	.+0      	; 0x9c <M_Dio_void_getPinValue+0x9c>
  9c:	ca 01       	movw	r24, r20
  9e:	81 70       	andi	r24, 0x01	; 1
  a0:	eb 81       	ldd	r30, Y+3	; 0x03
  a2:	fc 81       	ldd	r31, Y+4	; 0x04
  a4:	80 83       	st	Z, r24
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <M_Dio_void_getPinValue+0xa8>
		  break;
	  case  OUPUT:
		  SET_BIT(DDRA_REG,pin);
  a8:	e3 e3       	ldi	r30, 0x33	; 51
  aa:	f0 e0       	ldi	r31, 0x00	; 0
  ac:	80 81       	ld	r24, Z
  ae:	28 2f       	mov	r18, r24
  b0:	30 e0       	ldi	r19, 0x00	; 0
  b2:	8a 81       	ldd	r24, Y+2	; 0x02
  b4:	88 2f       	mov	r24, r24
  b6:	90 e0       	ldi	r25, 0x00	; 0
  b8:	a9 01       	movw	r20, r18
  ba:	00 c0       	rjmp	.+0      	; 0xbc <M_Dio_void_getPinValue+0xbc>
  bc:	55 95       	asr	r21
  be:	47 95       	ror	r20
  c0:	8a 95       	dec	r24
  c2:	02 f4       	brpl	.+0      	; 0xc4 <M_Dio_void_getPinValue+0xc4>
  c4:	ca 01       	movw	r24, r20
  c6:	81 70       	andi	r24, 0x01	; 1
  c8:	eb 81       	ldd	r30, Y+3	; 0x03
  ca:	fc 81       	ldd	r31, Y+4	; 0x04
  cc:	80 83       	st	Z, r24
  ce:	00 c0       	rjmp	.+0      	; 0xd0 <M_Dio_void_getPinValue+0xd0>
		  break;

	  }
	  break;
  case PORTB_ID:
	  switch(dir)
  d0:	e0 e3       	ldi	r30, 0x30	; 48
  d2:	f0 e0       	ldi	r31, 0x00	; 0
  d4:	80 81       	ld	r24, Z
  d6:	28 2f       	mov	r18, r24
  d8:	30 e0       	ldi	r19, 0x00	; 0
  da:	8a 81       	ldd	r24, Y+2	; 0x02
  dc:	88 2f       	mov	r24, r24
  de:	90 e0       	ldi	r25, 0x00	; 0
  e0:	a9 01       	movw	r20, r18
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <M_Dio_void_getPinValue+0xe4>
  e4:	55 95       	asr	r21
  e6:	47 95       	ror	r20
  e8:	8a 95       	dec	r24
  ea:	02 f4       	brpl	.+0      	; 0xec <M_Dio_void_getPinValue+0xec>
  ec:	ca 01       	movw	r24, r20
	  	  {
	  	  case  INPUT:
	  		  CLR_BIT(DDRB_REG,pin);
  ee:	81 70       	andi	r24, 0x01	; 1
  f0:	eb 81       	ldd	r30, Y+3	; 0x03
  f2:	fc 81       	ldd	r31, Y+4	; 0x04
  f4:	80 83       	st	Z, r24
  f6:	26 96       	adiw	r28, 0x06	; 6
  f8:	0f b6       	in	r0, 0x3f	; 63
  fa:	f8 94       	cli
  fc:	de bf       	out	0x3e, r29	; 62
  fe:	0f be       	out	0x3f, r0	; 63
 100:	cd bf       	out	0x3d, r28	; 61
 102:	cf 91       	pop	r28
 104:	df 91       	pop	r29
 106:	08 95       	ret

Disassembly of section .text.M_Dio_void_TogPinValue:

00000000 <M_Dio_void_TogPinValue>:
#include "Dio_config.h"
#include "Dio_int.h"


void M_Dio_void_setPinDir(u8 port,u8 pin,u8 dir )
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <M_Dio_void_TogPinValue+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <M_Dio_void_TogPinValue+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	28 2f       	mov	r18, r24
  14:	30 e0       	ldi	r19, 0x00	; 0
  16:	3c 83       	std	Y+4, r19	; 0x04
  18:	2b 83       	std	Y+3, r18	; 0x03
  switch (port)
  1a:	8b 81       	ldd	r24, Y+3	; 0x03
  1c:	9c 81       	ldd	r25, Y+4	; 0x04
  1e:	82 30       	cpi	r24, 0x02	; 2
  20:	91 05       	cpc	r25, r1
  22:	01 f0       	breq	.+0      	; 0x24 <M_Dio_void_TogPinValue+0x24>
  24:	2b 81       	ldd	r18, Y+3	; 0x03
  26:	3c 81       	ldd	r19, Y+4	; 0x04
  28:	23 30       	cpi	r18, 0x03	; 3
  2a:	31 05       	cpc	r19, r1
  2c:	04 f4       	brge	.+0      	; 0x2e <M_Dio_void_TogPinValue+0x2e>
  2e:	8b 81       	ldd	r24, Y+3	; 0x03
  30:	9c 81       	ldd	r25, Y+4	; 0x04
  32:	81 30       	cpi	r24, 0x01	; 1
  34:	91 05       	cpc	r25, r1
  36:	01 f0       	breq	.+0      	; 0x38 <M_Dio_void_TogPinValue+0x38>
  38:	00 c0       	rjmp	.+0      	; 0x3a <M_Dio_void_TogPinValue+0x3a>
  3a:	2b 81       	ldd	r18, Y+3	; 0x03
  3c:	3c 81       	ldd	r19, Y+4	; 0x04
  3e:	23 30       	cpi	r18, 0x03	; 3
  40:	31 05       	cpc	r19, r1
  42:	01 f0       	breq	.+0      	; 0x44 <M_Dio_void_TogPinValue+0x44>
  44:	8b 81       	ldd	r24, Y+3	; 0x03
  46:	9c 81       	ldd	r25, Y+4	; 0x04
  48:	84 30       	cpi	r24, 0x04	; 4
  4a:	91 05       	cpc	r25, r1
  4c:	01 f0       	breq	.+0      	; 0x4e <M_Dio_void_TogPinValue+0x4e>
  4e:	00 c0       	rjmp	.+0      	; 0x50 <M_Dio_void_TogPinValue+0x50>
  50:	ab e3       	ldi	r26, 0x3B	; 59
  52:	b0 e0       	ldi	r27, 0x00	; 0
  54:	eb e3       	ldi	r30, 0x3B	; 59
  56:	f0 e0       	ldi	r31, 0x00	; 0
  58:	80 81       	ld	r24, Z
  5a:	48 2f       	mov	r20, r24
  5c:	8a 81       	ldd	r24, Y+2	; 0x02
  5e:	28 2f       	mov	r18, r24
  {
  case PORTA_ID:
	  switch(dir)
  60:	30 e0       	ldi	r19, 0x00	; 0
  62:	81 e0       	ldi	r24, 0x01	; 1
  64:	90 e0       	ldi	r25, 0x00	; 0
  66:	02 2e       	mov	r0, r18
  68:	00 c0       	rjmp	.+0      	; 0x6a <M_Dio_void_TogPinValue+0x6a>
  6a:	88 0f       	add	r24, r24
  6c:	99 1f       	adc	r25, r25
  6e:	0a 94       	dec	r0
  70:	02 f4       	brpl	.+0      	; 0x72 <M_Dio_void_TogPinValue+0x72>
  72:	84 27       	eor	r24, r20
  74:	8c 93       	st	X, r24
  76:	00 c0       	rjmp	.+0      	; 0x78 <M_Dio_void_TogPinValue+0x78>
  78:	a8 e3       	ldi	r26, 0x38	; 56
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	e8 e3       	ldi	r30, 0x38	; 56
	  {
	  case  INPUT:
		  CLR_BIT(DDRA_REG,pin);
  7e:	f0 e0       	ldi	r31, 0x00	; 0
  80:	80 81       	ld	r24, Z
  82:	48 2f       	mov	r20, r24
  84:	8a 81       	ldd	r24, Y+2	; 0x02
  86:	28 2f       	mov	r18, r24
  88:	30 e0       	ldi	r19, 0x00	; 0
  8a:	81 e0       	ldi	r24, 0x01	; 1
  8c:	90 e0       	ldi	r25, 0x00	; 0
  8e:	02 2e       	mov	r0, r18
  90:	00 c0       	rjmp	.+0      	; 0x92 <M_Dio_void_TogPinValue+0x92>
  92:	88 0f       	add	r24, r24
  94:	99 1f       	adc	r25, r25
  96:	0a 94       	dec	r0
  98:	02 f4       	brpl	.+0      	; 0x9a <M_Dio_void_TogPinValue+0x9a>
  9a:	84 27       	eor	r24, r20
  9c:	8c 93       	st	X, r24
  9e:	00 c0       	rjmp	.+0      	; 0xa0 <M_Dio_void_TogPinValue+0xa0>
  a0:	a5 e3       	ldi	r26, 0x35	; 53
  a2:	b0 e0       	ldi	r27, 0x00	; 0
  a4:	e5 e3       	ldi	r30, 0x35	; 53
  a6:	f0 e0       	ldi	r31, 0x00	; 0
		  break;
	  case  OUPUT:
		  SET_BIT(DDRA_REG,pin);
  a8:	80 81       	ld	r24, Z
  aa:	48 2f       	mov	r20, r24
  ac:	8a 81       	ldd	r24, Y+2	; 0x02
  ae:	28 2f       	mov	r18, r24
  b0:	30 e0       	ldi	r19, 0x00	; 0
  b2:	81 e0       	ldi	r24, 0x01	; 1
  b4:	90 e0       	ldi	r25, 0x00	; 0
  b6:	02 2e       	mov	r0, r18
  b8:	00 c0       	rjmp	.+0      	; 0xba <M_Dio_void_TogPinValue+0xba>
  ba:	88 0f       	add	r24, r24
  bc:	99 1f       	adc	r25, r25
  be:	0a 94       	dec	r0
  c0:	02 f4       	brpl	.+0      	; 0xc2 <M_Dio_void_TogPinValue+0xc2>
  c2:	84 27       	eor	r24, r20
  c4:	8c 93       	st	X, r24
  c6:	00 c0       	rjmp	.+0      	; 0xc8 <M_Dio_void_TogPinValue+0xc8>
  c8:	ab e3       	ldi	r26, 0x3B	; 59
  ca:	b0 e0       	ldi	r27, 0x00	; 0
  cc:	eb e3       	ldi	r30, 0x3B	; 59
  ce:	f0 e0       	ldi	r31, 0x00	; 0
		  break;

	  }
	  break;
  case PORTB_ID:
	  switch(dir)
  d0:	80 81       	ld	r24, Z
  d2:	48 2f       	mov	r20, r24
  d4:	8a 81       	ldd	r24, Y+2	; 0x02
  d6:	28 2f       	mov	r18, r24
  d8:	30 e0       	ldi	r19, 0x00	; 0
  da:	81 e0       	ldi	r24, 0x01	; 1
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	02 2e       	mov	r0, r18
  e0:	00 c0       	rjmp	.+0      	; 0xe2 <M_Dio_void_TogPinValue+0xe2>
  e2:	88 0f       	add	r24, r24
  e4:	99 1f       	adc	r25, r25
  e6:	0a 94       	dec	r0
  e8:	02 f4       	brpl	.+0      	; 0xea <M_Dio_void_TogPinValue+0xea>
  ea:	84 27       	eor	r24, r20
  ec:	8c 93       	st	X, r24
	  	  {
	  	  case  INPUT:
	  		  CLR_BIT(DDRB_REG,pin);
  ee:	0f 90       	pop	r0
  f0:	0f 90       	pop	r0
  f2:	0f 90       	pop	r0
  f4:	0f 90       	pop	r0
  f6:	cf 91       	pop	r28
  f8:	df 91       	pop	r29
  fa:	08 95       	ret

Ultrasonic_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000600  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000008fb  00000000  00000000  00000634  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .bss.Reading1 00000002  00000000  00000000  00000f2f  2**0
                  ALLOC
  6 .bss.Reading2 00000002  00000000  00000000  00000f2f  2**0
                  ALLOC
  7 .bss.stateCounter 00000001  00000000  00000000  00000f2f  2**0
                  ALLOC
  8 .text.H_ULTRASONIC_void_init 00000042  00000000  00000000  00000f2f  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.H_ULTRASONIC_void_getDistance 0000026c  00000000  00000000  00000f71  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.ICU_HW  00000068  00000000  00000000  000011dd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.H_ULTRASONIC_void_init:

00000000 <H_ULTRASONIC_void_init>:
static u16 Reading1 	= 0;
static u16 Reading2 	= 0;
static u8  stateCounter = 0;
void ICU_HW(void);
void	H_ULTRASONIC_void_init			(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	// set direction for trigg to be OUTPUT
	M_DIO_void_setPinDir(PORTC_ID,PIN5_ID, OUPUT);
   8:	83 e0       	ldi	r24, 0x03	; 3
   a:	90 e0       	ldi	r25, 0x00	; 0
   c:	65 e0       	ldi	r22, 0x05	; 5
   e:	70 e0       	ldi	r23, 0x00	; 0
  10:	41 e0       	ldi	r20, 0x01	; 1
  12:	50 e0       	ldi	r21, 0x00	; 0
  14:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_init>
	// set ICP1 pin as INPUT
	M_DIO_void_setPinDir(PORTD_ID,PIN6_ID, INPUT);
  18:	84 e0       	ldi	r24, 0x04	; 4
  1a:	90 e0       	ldi	r25, 0x00	; 0
  1c:	66 e0       	ldi	r22, 0x06	; 6
  1e:	70 e0       	ldi	r23, 0x00	; 0
  20:	40 e0       	ldi	r20, 0x00	; 0
  22:	50 e0       	ldi	r21, 0x00	; 0
  24:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_init>
	// ICU init
	M_TIMER1_ICU_void_init();
  28:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_init>
	// Call back
	M_TIMER1_ICU_void_setCallBack(ICU_HW);
  2c:	80 e0       	ldi	r24, 0x00	; 0
  2e:	90 e0       	ldi	r25, 0x00	; 0
  30:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_init>
	// Enable ICU int
	M_TIMER1_ICU_void_IntEnable();
  34:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_init>

	M_TIMER1_void_init(); // timer1 start
  38:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_init>
}
  3c:	cf 91       	pop	r28
  3e:	df 91       	pop	r29
  40:	08 95       	ret

Disassembly of section .text.H_ULTRASONIC_void_getDistance:

00000000 <H_ULTRASONIC_void_getDistance>:
static u16 Reading1 	= 0;
static u16 Reading2 	= 0;
static u8  stateCounter = 0;
void ICU_HW(void);
void	H_ULTRASONIC_void_init			(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	// set direction for trigg to be OUTPUT
	M_DIO_void_setPinDir(PORTC_ID,PIN5_ID, OUPUT);
   8:	a0 97       	sbiw	r28, 0x20	; 32
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
	// set ICP1 pin as INPUT
	M_DIO_void_setPinDir(PORTD_ID,PIN6_ID, INPUT);
  18:	83 e0       	ldi	r24, 0x03	; 3
  1a:	90 e0       	ldi	r25, 0x00	; 0
  1c:	65 e0       	ldi	r22, 0x05	; 5
  1e:	70 e0       	ldi	r23, 0x00	; 0
  20:	41 e0       	ldi	r20, 0x01	; 1
  22:	50 e0       	ldi	r21, 0x00	; 0
  24:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
	// ICU init
	M_TIMER1_ICU_void_init();
  28:	80 e0       	ldi	r24, 0x00	; 0
  2a:	90 e0       	ldi	r25, 0x00	; 0
	// Call back
	M_TIMER1_ICU_void_setCallBack(ICU_HW);
  2c:	a0 e2       	ldi	r26, 0x20	; 32
  2e:	b1 e4       	ldi	r27, 0x41	; 65
  30:	8d 8b       	std	Y+21, r24	; 0x15
  32:	9e 8b       	std	Y+22, r25	; 0x16
	// Enable ICU int
	M_TIMER1_ICU_void_IntEnable();
  34:	af 8b       	std	Y+23, r26	; 0x17
  36:	b8 8f       	std	Y+24, r27	; 0x18

	M_TIMER1_void_init(); // timer1 start
  38:	6d 89       	ldd	r22, Y+21	; 0x15
  3a:	7e 89       	ldd	r23, Y+22	; 0x16
}
  3c:	8f 89       	ldd	r24, Y+23	; 0x17
  3e:	98 8d       	ldd	r25, Y+24	; 0x18
  40:	2b ea       	ldi	r18, 0xAB	; 171
  42:	3a ea       	ldi	r19, 0xAA	; 170
  44:	4a ea       	ldi	r20, 0xAA	; 170
  46:	50 e4       	ldi	r21, 0x40	; 64
  48:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
  4c:	dc 01       	movw	r26, r24
  4e:	cb 01       	movw	r24, r22
  50:	89 8b       	std	Y+17, r24	; 0x11
  52:	9a 8b       	std	Y+18, r25	; 0x12
  54:	ab 8b       	std	Y+19, r26	; 0x13
  56:	bc 8b       	std	Y+20, r27	; 0x14
  58:	69 89       	ldd	r22, Y+17	; 0x11
  5a:	7a 89       	ldd	r23, Y+18	; 0x12
  5c:	8b 89       	ldd	r24, Y+19	; 0x13
  5e:	9c 89       	ldd	r25, Y+20	; 0x14
  60:	20 e0       	ldi	r18, 0x00	; 0
  62:	30 e0       	ldi	r19, 0x00	; 0
  64:	40 e8       	ldi	r20, 0x80	; 128
  66:	5f e3       	ldi	r21, 0x3F	; 63
  68:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
  6c:	88 23       	and	r24, r24
  6e:	04 f4       	brge	.+0      	; 0x70 <H_ULTRASONIC_void_getDistance+0x70>
  70:	81 e0       	ldi	r24, 0x01	; 1
  72:	88 8b       	std	Y+16, r24	; 0x10
  74:	00 c0       	rjmp	.+0      	; 0x76 <H_ULTRASONIC_void_getDistance+0x76>
  76:	69 89       	ldd	r22, Y+17	; 0x11
  78:	7a 89       	ldd	r23, Y+18	; 0x12
  7a:	8b 89       	ldd	r24, Y+19	; 0x13
  7c:	9c 89       	ldd	r25, Y+20	; 0x14
  7e:	20 e0       	ldi	r18, 0x00	; 0
  80:	30 e0       	ldi	r19, 0x00	; 0
  82:	4f e7       	ldi	r20, 0x7F	; 127
  84:	53 e4       	ldi	r21, 0x43	; 67
  86:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
  8a:	18 16       	cp	r1, r24
  8c:	04 f0       	brlt	.+0      	; 0x8e <H_ULTRASONIC_void_getDistance+0x8e>
  8e:	00 c0       	rjmp	.+0      	; 0x90 <H_ULTRASONIC_void_getDistance+0x90>
  90:	6d 89       	ldd	r22, Y+21	; 0x15
  92:	7e 89       	ldd	r23, Y+22	; 0x16
  94:	8f 89       	ldd	r24, Y+23	; 0x17
  96:	98 8d       	ldd	r25, Y+24	; 0x18
  98:	20 e0       	ldi	r18, 0x00	; 0
  9a:	30 e0       	ldi	r19, 0x00	; 0
  9c:	4a e7       	ldi	r20, 0x7A	; 122
  9e:	54 e4       	ldi	r21, 0x44	; 68
  a0:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
  a4:	dc 01       	movw	r26, r24
  a6:	cb 01       	movw	r24, r22
  a8:	8c 87       	std	Y+12, r24	; 0x0c
  aa:	9d 87       	std	Y+13, r25	; 0x0d
  ac:	ae 87       	std	Y+14, r26	; 0x0e
  ae:	bf 87       	std	Y+15, r27	; 0x0f
  b0:	6c 85       	ldd	r22, Y+12	; 0x0c
  b2:	7d 85       	ldd	r23, Y+13	; 0x0d
  b4:	8e 85       	ldd	r24, Y+14	; 0x0e
  b6:	9f 85       	ldd	r25, Y+15	; 0x0f
  b8:	20 e0       	ldi	r18, 0x00	; 0
  ba:	30 e0       	ldi	r19, 0x00	; 0
  bc:	4a e7       	ldi	r20, 0x7A	; 122
  be:	55 e4       	ldi	r21, 0x45	; 69
  c0:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
  c4:	dc 01       	movw	r26, r24
  c6:	cb 01       	movw	r24, r22
  c8:	88 87       	std	Y+8, r24	; 0x08
  ca:	99 87       	std	Y+9, r25	; 0x09
  cc:	aa 87       	std	Y+10, r26	; 0x0a
  ce:	bb 87       	std	Y+11, r27	; 0x0b
  d0:	68 85       	ldd	r22, Y+8	; 0x08
  d2:	79 85       	ldd	r23, Y+9	; 0x09
  d4:	8a 85       	ldd	r24, Y+10	; 0x0a
  d6:	9b 85       	ldd	r25, Y+11	; 0x0b
  d8:	20 e0       	ldi	r18, 0x00	; 0
  da:	30 e0       	ldi	r19, 0x00	; 0
  dc:	40 e8       	ldi	r20, 0x80	; 128
  de:	5f e3       	ldi	r21, 0x3F	; 63
  e0:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
  e4:	88 23       	and	r24, r24
  e6:	04 f4       	brge	.+0      	; 0xe8 <H_ULTRASONIC_void_getDistance+0xe8>
  e8:	81 e0       	ldi	r24, 0x01	; 1
  ea:	90 e0       	ldi	r25, 0x00	; 0
  ec:	9f 83       	std	Y+7, r25	; 0x07
  ee:	8e 83       	std	Y+6, r24	; 0x06
  f0:	00 c0       	rjmp	.+0      	; 0xf2 <H_ULTRASONIC_void_getDistance+0xf2>
  f2:	68 85       	ldd	r22, Y+8	; 0x08
  f4:	79 85       	ldd	r23, Y+9	; 0x09
  f6:	8a 85       	ldd	r24, Y+10	; 0x0a
  f8:	9b 85       	ldd	r25, Y+11	; 0x0b
  fa:	20 e0       	ldi	r18, 0x00	; 0
  fc:	3f ef       	ldi	r19, 0xFF	; 255
  fe:	4f e7       	ldi	r20, 0x7F	; 127
 100:	57 e4       	ldi	r21, 0x47	; 71
 102:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 106:	18 16       	cp	r1, r24
 108:	04 f4       	brge	.+0      	; 0x10a <H_ULTRASONIC_void_getDistance+0x10a>
 10a:	6c 85       	ldd	r22, Y+12	; 0x0c
 10c:	7d 85       	ldd	r23, Y+13	; 0x0d
 10e:	8e 85       	ldd	r24, Y+14	; 0x0e
 110:	9f 85       	ldd	r25, Y+15	; 0x0f
 112:	20 e0       	ldi	r18, 0x00	; 0
 114:	30 e0       	ldi	r19, 0x00	; 0
 116:	40 e2       	ldi	r20, 0x20	; 32
 118:	51 e4       	ldi	r21, 0x41	; 65
 11a:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 11e:	dc 01       	movw	r26, r24
 120:	cb 01       	movw	r24, r22
 122:	bc 01       	movw	r22, r24
 124:	cd 01       	movw	r24, r26
 126:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 12a:	dc 01       	movw	r26, r24
 12c:	cb 01       	movw	r24, r22
 12e:	9f 83       	std	Y+7, r25	; 0x07
 130:	8e 83       	std	Y+6, r24	; 0x06
 132:	00 c0       	rjmp	.+0      	; 0x134 <H_ULTRASONIC_void_getDistance+0x134>
 134:	80 e9       	ldi	r24, 0x90	; 144
 136:	91 e0       	ldi	r25, 0x01	; 1
 138:	9d 83       	std	Y+5, r25	; 0x05
 13a:	8c 83       	std	Y+4, r24	; 0x04
 13c:	8c 81       	ldd	r24, Y+4	; 0x04
 13e:	9d 81       	ldd	r25, Y+5	; 0x05
 140:	01 97       	sbiw	r24, 0x01	; 1
 142:	01 f4       	brne	.+0      	; 0x144 <H_ULTRASONIC_void_getDistance+0x144>
 144:	9d 83       	std	Y+5, r25	; 0x05
 146:	8c 83       	std	Y+4, r24	; 0x04
 148:	8e 81       	ldd	r24, Y+6	; 0x06
 14a:	9f 81       	ldd	r25, Y+7	; 0x07
 14c:	01 97       	sbiw	r24, 0x01	; 1
 14e:	9f 83       	std	Y+7, r25	; 0x07
 150:	8e 83       	std	Y+6, r24	; 0x06
 152:	8e 81       	ldd	r24, Y+6	; 0x06
 154:	9f 81       	ldd	r25, Y+7	; 0x07
 156:	00 97       	sbiw	r24, 0x00	; 0
 158:	01 f4       	brne	.+0      	; 0x15a <H_ULTRASONIC_void_getDistance+0x15a>
 15a:	00 c0       	rjmp	.+0      	; 0x15c <H_ULTRASONIC_void_getDistance+0x15c>
 15c:	68 85       	ldd	r22, Y+8	; 0x08
 15e:	79 85       	ldd	r23, Y+9	; 0x09
 160:	8a 85       	ldd	r24, Y+10	; 0x0a
 162:	9b 85       	ldd	r25, Y+11	; 0x0b
 164:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 168:	dc 01       	movw	r26, r24
 16a:	cb 01       	movw	r24, r22
 16c:	9f 83       	std	Y+7, r25	; 0x07
 16e:	8e 83       	std	Y+6, r24	; 0x06
 170:	8e 81       	ldd	r24, Y+6	; 0x06
 172:	9f 81       	ldd	r25, Y+7	; 0x07
 174:	9b 83       	std	Y+3, r25	; 0x03
 176:	8a 83       	std	Y+2, r24	; 0x02
 178:	8a 81       	ldd	r24, Y+2	; 0x02
 17a:	9b 81       	ldd	r25, Y+3	; 0x03
 17c:	01 97       	sbiw	r24, 0x01	; 1
 17e:	01 f4       	brne	.+0      	; 0x180 <H_ULTRASONIC_void_getDistance+0x180>
 180:	9b 83       	std	Y+3, r25	; 0x03
 182:	8a 83       	std	Y+2, r24	; 0x02
 184:	00 c0       	rjmp	.+0      	; 0x186 <H_ULTRASONIC_void_getDistance+0x186>
 186:	69 89       	ldd	r22, Y+17	; 0x11
 188:	7a 89       	ldd	r23, Y+18	; 0x12
 18a:	8b 89       	ldd	r24, Y+19	; 0x13
 18c:	9c 89       	ldd	r25, Y+20	; 0x14
 18e:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 192:	dc 01       	movw	r26, r24
 194:	cb 01       	movw	r24, r22
 196:	88 8b       	std	Y+16, r24	; 0x10
 198:	88 89       	ldd	r24, Y+16	; 0x10
 19a:	89 83       	std	Y+1, r24	; 0x01
 19c:	89 81       	ldd	r24, Y+1	; 0x01
 19e:	8a 95       	dec	r24
 1a0:	01 f4       	brne	.+0      	; 0x1a2 <H_ULTRASONIC_void_getDistance+0x1a2>
 1a2:	89 83       	std	Y+1, r24	; 0x01
 1a4:	83 e0       	ldi	r24, 0x03	; 3
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	65 e0       	ldi	r22, 0x05	; 5
 1aa:	70 e0       	ldi	r23, 0x00	; 0
 1ac:	40 e0       	ldi	r20, 0x00	; 0
 1ae:	50 e0       	ldi	r21, 0x00	; 0
 1b0:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 1b4:	80 91 00 00 	lds	r24, 0x0000
 1b8:	82 30       	cpi	r24, 0x02	; 2
 1ba:	00 f0       	brcs	.+0      	; 0x1bc <H_ULTRASONIC_void_getDistance+0x1bc>
 1bc:	10 92 00 00 	sts	0x0000, r1
 1c0:	20 91 00 00 	lds	r18, 0x0000
 1c4:	30 91 00 00 	lds	r19, 0x0000
 1c8:	80 91 00 00 	lds	r24, 0x0000
 1cc:	90 91 00 00 	lds	r25, 0x0000
 1d0:	a9 01       	movw	r20, r18
 1d2:	48 1b       	sub	r20, r24
 1d4:	59 0b       	sbc	r21, r25
 1d6:	ca 01       	movw	r24, r20
 1d8:	98 a3       	std	Y+32, r25	; 0x20
 1da:	8f 8f       	std	Y+31, r24	; 0x1f
 1dc:	8f 8d       	ldd	r24, Y+31	; 0x1f
 1de:	98 a1       	ldd	r25, Y+32	; 0x20
 1e0:	cc 01       	movw	r24, r24
 1e2:	a0 e0       	ldi	r26, 0x00	; 0
 1e4:	b0 e0       	ldi	r27, 0x00	; 0
 1e6:	bc 01       	movw	r22, r24
 1e8:	cd 01       	movw	r24, r26
 1ea:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 1ee:	dc 01       	movw	r26, r24
 1f0:	cb 01       	movw	r24, r22
 1f2:	bc 01       	movw	r22, r24
 1f4:	cd 01       	movw	r24, r26
 1f6:	2d eb       	ldi	r18, 0xBD	; 189
 1f8:	37 e3       	ldi	r19, 0x37	; 55
 1fa:	46 e8       	ldi	r20, 0x86	; 134
 1fc:	57 e3       	ldi	r21, 0x37	; 55
 1fe:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 202:	dc 01       	movw	r26, r24
 204:	cb 01       	movw	r24, r22
 206:	8b 8f       	std	Y+27, r24	; 0x1b
 208:	9c 8f       	std	Y+28, r25	; 0x1c
 20a:	ad 8f       	std	Y+29, r26	; 0x1d
 20c:	be 8f       	std	Y+30, r27	; 0x1e
 20e:	6b 8d       	ldd	r22, Y+27	; 0x1b
 210:	7c 8d       	ldd	r23, Y+28	; 0x1c
 212:	8d 8d       	ldd	r24, Y+29	; 0x1d
 214:	9e 8d       	ldd	r25, Y+30	; 0x1e
 216:	20 e0       	ldi	r18, 0x00	; 0
 218:	30 e0       	ldi	r19, 0x00	; 0
 21a:	40 e0       	ldi	r20, 0x00	; 0
 21c:	50 e4       	ldi	r21, 0x40	; 64
 21e:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 222:	dc 01       	movw	r26, r24
 224:	cb 01       	movw	r24, r22
 226:	bc 01       	movw	r22, r24
 228:	cd 01       	movw	r24, r26
 22a:	20 e0       	ldi	r18, 0x00	; 0
 22c:	3c ef       	ldi	r19, 0xFC	; 252
 22e:	45 e0       	ldi	r20, 0x05	; 5
 230:	57 e4       	ldi	r21, 0x47	; 71
 232:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 236:	dc 01       	movw	r26, r24
 238:	cb 01       	movw	r24, r22
 23a:	bc 01       	movw	r22, r24
 23c:	cd 01       	movw	r24, r26
 23e:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 242:	dc 01       	movw	r26, r24
 244:	cb 01       	movw	r24, r22
 246:	bc 01       	movw	r22, r24
 248:	cd 01       	movw	r24, r26
 24a:	0e 94 00 00 	call	0	; 0x0 <H_ULTRASONIC_void_getDistance>
 24e:	dc 01       	movw	r26, r24
 250:	cb 01       	movw	r24, r22
 252:	9a 8f       	std	Y+26, r25	; 0x1a
 254:	89 8f       	std	Y+25, r24	; 0x19
 256:	89 8d       	ldd	r24, Y+25	; 0x19
 258:	9a 8d       	ldd	r25, Y+26	; 0x1a
 25a:	a0 96       	adiw	r28, 0x20	; 32
 25c:	0f b6       	in	r0, 0x3f	; 63
 25e:	f8 94       	cli
 260:	de bf       	out	0x3e, r29	; 62
 262:	0f be       	out	0x3f, r0	; 63
 264:	cd bf       	out	0x3d, r28	; 61
 266:	cf 91       	pop	r28
 268:	df 91       	pop	r29
 26a:	08 95       	ret

Disassembly of section .text.ICU_HW:

00000000 <ICU_HW>:
static u16 Reading1 	= 0;
static u16 Reading2 	= 0;
static u8  stateCounter = 0;
void ICU_HW(void);
void	H_ULTRASONIC_void_init			(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <ICU_HW+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
	// set direction for trigg to be OUTPUT
	M_DIO_void_setPinDir(PORTC_ID,PIN5_ID, OUPUT);
   8:	de b7       	in	r29, 0x3e	; 62
   a:	80 91 00 00 	lds	r24, 0x0000
   e:	28 2f       	mov	r18, r24
  10:	30 e0       	ldi	r19, 0x00	; 0
  12:	3a 83       	std	Y+2, r19	; 0x02
  14:	29 83       	std	Y+1, r18	; 0x01
  16:	89 81       	ldd	r24, Y+1	; 0x01
	// set ICP1 pin as INPUT
	M_DIO_void_setPinDir(PORTD_ID,PIN6_ID, INPUT);
  18:	9a 81       	ldd	r25, Y+2	; 0x02
  1a:	00 97       	sbiw	r24, 0x00	; 0
  1c:	01 f0       	breq	.+0      	; 0x1e <ICU_HW+0x1e>
  1e:	29 81       	ldd	r18, Y+1	; 0x01
  20:	3a 81       	ldd	r19, Y+2	; 0x02
  22:	21 30       	cpi	r18, 0x01	; 1
  24:	31 05       	cpc	r19, r1
  26:	01 f0       	breq	.+0      	; 0x28 <ICU_HW+0x28>
	// ICU init
	M_TIMER1_ICU_void_init();
  28:	00 c0       	rjmp	.+0      	; 0x2a <ICU_HW+0x2a>
  2a:	0e 94 00 00 	call	0	; 0x0 <ICU_HW>
	// Call back
	M_TIMER1_ICU_void_setCallBack(ICU_HW);
  2e:	90 93 00 00 	sts	0x0000, r25
  32:	80 93 00 00 	sts	0x0000, r24
	// Enable ICU int
	M_TIMER1_ICU_void_IntEnable();
  36:	80 e0       	ldi	r24, 0x00	; 0

	M_TIMER1_void_init(); // timer1 start
  38:	0e 94 00 00 	call	0	; 0x0 <ICU_HW>
}
  3c:	00 c0       	rjmp	.+0      	; 0x3e <ICU_HW+0x3e>
  3e:	0e 94 00 00 	call	0	; 0x0 <ICU_HW>
  42:	90 93 00 00 	sts	0x0000, r25
  46:	80 93 00 00 	sts	0x0000, r24
  4a:	81 e0       	ldi	r24, 0x01	; 1
  4c:	0e 94 00 00 	call	0	; 0x0 <ICU_HW>
  50:	0e 94 00 00 	call	0	; 0x0 <ICU_HW>
  54:	80 91 00 00 	lds	r24, 0x0000
  58:	8f 5f       	subi	r24, 0xFF	; 255
  5a:	80 93 00 00 	sts	0x0000, r24
  5e:	0f 90       	pop	r0
  60:	0f 90       	pop	r0
  62:	cf 91       	pop	r28
  64:	df 91       	pop	r29
  66:	08 95       	ret

SSD_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000cc0  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000949  00000000  00000000  00000cf4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.H_SSD_void_init 00000072  00000000  00000000  0000163d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.H_SSD_void_DisplayNumber 00000966  00000000  00000000  000016af  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.H_SSD_void_init:

00000000 <H_SSD_void_init>:
#include "SSD_priv.h"
#include "SSD_config.h"
#include "SSD_int.h"
// u8 arr[]={0x3F, };
void H_SSD_void_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	// set all SSD pins as output
	M_Dio_void_setPinDir(SSD_LED_A_PORT,SSD_LED_A_PIN,OUPUT );
   8:	81 e0       	ldi	r24, 0x01	; 1
   a:	61 e0       	ldi	r22, 0x01	; 1
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>
	M_Dio_void_setPinDir(SSD_LED_B_PORT,SSD_LED_B_PIN,OUPUT );
  12:	81 e0       	ldi	r24, 0x01	; 1
  14:	62 e0       	ldi	r22, 0x02	; 2
  16:	41 e0       	ldi	r20, 0x01	; 1
  18:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>
	M_Dio_void_setPinDir(SSD_LED_C_PORT,SSD_LED_C_PIN,OUPUT );
  1c:	81 e0       	ldi	r24, 0x01	; 1
  1e:	63 e0       	ldi	r22, 0x03	; 3
  20:	41 e0       	ldi	r20, 0x01	; 1
  22:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>
	M_Dio_void_setPinDir(SSD_LED_D_PORT,SSD_LED_D_PIN,OUPUT );
  26:	81 e0       	ldi	r24, 0x01	; 1
  28:	64 e0       	ldi	r22, 0x04	; 4
  2a:	41 e0       	ldi	r20, 0x01	; 1
  2c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>
	M_Dio_void_setPinDir(SSD_LED_E_PORT,SSD_LED_E_PIN,OUPUT );
  30:	81 e0       	ldi	r24, 0x01	; 1
  32:	65 e0       	ldi	r22, 0x05	; 5
  34:	41 e0       	ldi	r20, 0x01	; 1
  36:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>
	M_Dio_void_setPinDir(SSD_LED_F_PORT,SSD_LED_F_PIN,OUPUT );
  3a:	81 e0       	ldi	r24, 0x01	; 1
  3c:	66 e0       	ldi	r22, 0x06	; 6
  3e:	41 e0       	ldi	r20, 0x01	; 1
  40:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>
	M_Dio_void_setPinDir(SSD_LED_G_PORT,SSD_LED_G_PIN,OUPUT );
  44:	81 e0       	ldi	r24, 0x01	; 1
  46:	67 e0       	ldi	r22, 0x07	; 7
  48:	41 e0       	ldi	r20, 0x01	; 1
  4a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>
	M_Dio_void_setPinDir(SSD_LED_DOT_PORT,SSD_LED_DOT_PIN,OUPUT );
  4e:	82 e0       	ldi	r24, 0x02	; 2
  50:	60 e0       	ldi	r22, 0x00	; 0
  52:	41 e0       	ldi	r20, 0x01	; 1
  54:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>

	// set Enable pins as output
	M_Dio_void_setPinDir(SSD_DIG_1_EN_PORT,SSD_DIG_1_EN_PIN,OUPUT );
  58:	83 e0       	ldi	r24, 0x03	; 3
  5a:	66 e0       	ldi	r22, 0x06	; 6
  5c:	41 e0       	ldi	r20, 0x01	; 1
  5e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>
	M_Dio_void_setPinDir(SSD_DIG_2_EN_PORT,SSD_DIG_2_EN_PIN,OUPUT );
  62:	83 e0       	ldi	r24, 0x03	; 3
  64:	67 e0       	ldi	r22, 0x07	; 7
  66:	41 e0       	ldi	r20, 0x01	; 1
  68:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_init>
}
  6c:	cf 91       	pop	r28
  6e:	df 91       	pop	r29
  70:	08 95       	ret

Disassembly of section .text.H_SSD_void_DisplayNumber:

00000000 <H_SSD_void_DisplayNumber>:
#include "SSD_priv.h"
#include "SSD_config.h"
#include "SSD_int.h"
// u8 arr[]={0x3F, };
void H_SSD_void_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	// set all SSD pins as output
	M_Dio_void_setPinDir(SSD_LED_A_PORT,SSD_LED_A_PIN,OUPUT );
   8:	a7 97       	sbiw	r28, 0x27	; 39
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
	M_Dio_void_setPinDir(SSD_LED_B_PORT,SSD_LED_B_PIN,OUPUT );
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8b a3       	std	Y+35, r24	; 0x23
  16:	8b a1       	ldd	r24, Y+35	; 0x23
  18:	84 36       	cpi	r24, 0x64	; 100
  1a:	00 f0       	brcs	.+0      	; 0x1c <H_SSD_void_DisplayNumber+0x1c>
	M_Dio_void_setPinDir(SSD_LED_C_PORT,SSD_LED_C_PIN,OUPUT );
  1c:	00 c0       	rjmp	.+0      	; 0x1e <H_SSD_void_DisplayNumber+0x1e>
  1e:	8b a1       	ldd	r24, Y+35	; 0x23
  20:	9a e0       	ldi	r25, 0x0A	; 10
  22:	69 2f       	mov	r22, r25
  24:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
	M_Dio_void_setPinDir(SSD_LED_D_PORT,SSD_LED_D_PIN,OUPUT );
  28:	89 2f       	mov	r24, r25
  2a:	8e 8f       	std	Y+30, r24	; 0x1e
  2c:	8b a1       	ldd	r24, Y+35	; 0x23
  2e:	9a e0       	ldi	r25, 0x0A	; 10
	M_Dio_void_setPinDir(SSD_LED_E_PORT,SSD_LED_E_PIN,OUPUT );
  30:	69 2f       	mov	r22, r25
  32:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
  36:	8d 8f       	std	Y+29, r24	; 0x1d
  38:	1f 8e       	std	Y+31, r1	; 0x1f
	M_Dio_void_setPinDir(SSD_LED_F_PORT,SSD_LED_F_PIN,OUPUT );
  3a:	18 a2       	std	Y+32, r1	; 0x20
  3c:	19 a2       	std	Y+33, r1	; 0x21
  3e:	1a a2       	std	Y+34, r1	; 0x22
  40:	00 c0       	rjmp	.+0      	; 0x42 <H_SSD_void_DisplayNumber+0x42>
  42:	8e 8d       	ldd	r24, Y+30	; 0x1e
	M_Dio_void_setPinDir(SSD_LED_G_PORT,SSD_LED_G_PIN,OUPUT );
  44:	28 2f       	mov	r18, r24
  46:	30 e0       	ldi	r19, 0x00	; 0
  48:	3f a3       	std	Y+39, r19	; 0x27
  4a:	2e a3       	std	Y+38, r18	; 0x26
  4c:	8e a1       	ldd	r24, Y+38	; 0x26
	M_Dio_void_setPinDir(SSD_LED_DOT_PORT,SSD_LED_DOT_PIN,OUPUT );
  4e:	9f a1       	ldd	r25, Y+39	; 0x27
  50:	84 30       	cpi	r24, 0x04	; 4
  52:	91 05       	cpc	r25, r1
  54:	01 f4       	brne	.+0      	; 0x56 <H_SSD_void_DisplayNumber+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <H_SSD_void_DisplayNumber+0x58>

	// set Enable pins as output
	M_Dio_void_setPinDir(SSD_DIG_1_EN_PORT,SSD_DIG_1_EN_PIN,OUPUT );
  58:	2e a1       	ldd	r18, Y+38	; 0x26
  5a:	3f a1       	ldd	r19, Y+39	; 0x27
  5c:	25 30       	cpi	r18, 0x05	; 5
  5e:	31 05       	cpc	r19, r1
  60:	04 f4       	brge	.+0      	; 0x62 <H_SSD_void_DisplayNumber+0x62>
	M_Dio_void_setPinDir(SSD_DIG_2_EN_PORT,SSD_DIG_2_EN_PIN,OUPUT );
  62:	8e a1       	ldd	r24, Y+38	; 0x26
  64:	9f a1       	ldd	r25, Y+39	; 0x27
  66:	81 30       	cpi	r24, 0x01	; 1
  68:	91 05       	cpc	r25, r1
  6a:	01 f4       	brne	.+0      	; 0x6c <H_SSD_void_DisplayNumber+0x6c>
}
  6c:	00 c0       	rjmp	.+0      	; 0x6e <H_SSD_void_DisplayNumber+0x6e>
  6e:	2e a1       	ldd	r18, Y+38	; 0x26
  70:	3f a1       	ldd	r19, Y+39	; 0x27
  72:	22 30       	cpi	r18, 0x02	; 2
  74:	31 05       	cpc	r19, r1
  76:	04 f4       	brge	.+0      	; 0x78 <H_SSD_void_DisplayNumber+0x78>
  78:	8e a1       	ldd	r24, Y+38	; 0x26
  7a:	9f a1       	ldd	r25, Y+39	; 0x27
  7c:	00 97       	sbiw	r24, 0x00	; 0
  7e:	01 f0       	breq	.+0      	; 0x80 <H_SSD_void_DisplayNumber+0x80>
  80:	00 c0       	rjmp	.+0      	; 0x82 <H_SSD_void_DisplayNumber+0x82>
  82:	2e a1       	ldd	r18, Y+38	; 0x26
  84:	3f a1       	ldd	r19, Y+39	; 0x27
  86:	22 30       	cpi	r18, 0x02	; 2
  88:	31 05       	cpc	r19, r1
  8a:	01 f4       	brne	.+0      	; 0x8c <H_SSD_void_DisplayNumber+0x8c>
  8c:	00 c0       	rjmp	.+0      	; 0x8e <H_SSD_void_DisplayNumber+0x8e>
  8e:	8e a1       	ldd	r24, Y+38	; 0x26
  90:	9f a1       	ldd	r25, Y+39	; 0x27
  92:	83 30       	cpi	r24, 0x03	; 3
  94:	91 05       	cpc	r25, r1
  96:	01 f4       	brne	.+0      	; 0x98 <H_SSD_void_DisplayNumber+0x98>
  98:	00 c0       	rjmp	.+0      	; 0x9a <H_SSD_void_DisplayNumber+0x9a>
  9a:	00 c0       	rjmp	.+0      	; 0x9c <H_SSD_void_DisplayNumber+0x9c>
  9c:	2e a1       	ldd	r18, Y+38	; 0x26
  9e:	3f a1       	ldd	r19, Y+39	; 0x27
  a0:	27 30       	cpi	r18, 0x07	; 7
  a2:	31 05       	cpc	r19, r1
  a4:	01 f4       	brne	.+0      	; 0xa6 <H_SSD_void_DisplayNumber+0xa6>
  a6:	00 c0       	rjmp	.+0      	; 0xa8 <H_SSD_void_DisplayNumber+0xa8>
  a8:	8e a1       	ldd	r24, Y+38	; 0x26
  aa:	9f a1       	ldd	r25, Y+39	; 0x27
  ac:	88 30       	cpi	r24, 0x08	; 8
  ae:	91 05       	cpc	r25, r1
  b0:	04 f4       	brge	.+0      	; 0xb2 <H_SSD_void_DisplayNumber+0xb2>
  b2:	2e a1       	ldd	r18, Y+38	; 0x26
  b4:	3f a1       	ldd	r19, Y+39	; 0x27
  b6:	25 30       	cpi	r18, 0x05	; 5
  b8:	31 05       	cpc	r19, r1
  ba:	01 f4       	brne	.+0      	; 0xbc <H_SSD_void_DisplayNumber+0xbc>
  bc:	00 c0       	rjmp	.+0      	; 0xbe <H_SSD_void_DisplayNumber+0xbe>
  be:	8e a1       	ldd	r24, Y+38	; 0x26
  c0:	9f a1       	ldd	r25, Y+39	; 0x27
  c2:	86 30       	cpi	r24, 0x06	; 6
  c4:	91 05       	cpc	r25, r1
  c6:	01 f4       	brne	.+0      	; 0xc8 <H_SSD_void_DisplayNumber+0xc8>
  c8:	00 c0       	rjmp	.+0      	; 0xca <H_SSD_void_DisplayNumber+0xca>
  ca:	00 c0       	rjmp	.+0      	; 0xcc <H_SSD_void_DisplayNumber+0xcc>
  cc:	2e a1       	ldd	r18, Y+38	; 0x26
  ce:	3f a1       	ldd	r19, Y+39	; 0x27
  d0:	28 30       	cpi	r18, 0x08	; 8
  d2:	31 05       	cpc	r19, r1
  d4:	01 f4       	brne	.+0      	; 0xd6 <H_SSD_void_DisplayNumber+0xd6>
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <H_SSD_void_DisplayNumber+0xd8>
  d8:	8e a1       	ldd	r24, Y+38	; 0x26
  da:	9f a1       	ldd	r25, Y+39	; 0x27
  dc:	89 30       	cpi	r24, 0x09	; 9
  de:	91 05       	cpc	r25, r1
  e0:	01 f4       	brne	.+0      	; 0xe2 <H_SSD_void_DisplayNumber+0xe2>
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <H_SSD_void_DisplayNumber+0xe4>
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <H_SSD_void_DisplayNumber+0xe6>
  e6:	81 e0       	ldi	r24, 0x01	; 1
  e8:	61 e0       	ldi	r22, 0x01	; 1
  ea:	41 e0       	ldi	r20, 0x01	; 1
  ec:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
  f0:	81 e0       	ldi	r24, 0x01	; 1
  f2:	62 e0       	ldi	r22, 0x02	; 2
  f4:	41 e0       	ldi	r20, 0x01	; 1
  f6:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
  fa:	81 e0       	ldi	r24, 0x01	; 1
  fc:	63 e0       	ldi	r22, 0x03	; 3
  fe:	41 e0       	ldi	r20, 0x01	; 1
 100:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 104:	81 e0       	ldi	r24, 0x01	; 1
 106:	64 e0       	ldi	r22, 0x04	; 4
 108:	41 e0       	ldi	r20, 0x01	; 1
 10a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 10e:	81 e0       	ldi	r24, 0x01	; 1
 110:	65 e0       	ldi	r22, 0x05	; 5
 112:	41 e0       	ldi	r20, 0x01	; 1
 114:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 118:	81 e0       	ldi	r24, 0x01	; 1
 11a:	66 e0       	ldi	r22, 0x06	; 6
 11c:	41 e0       	ldi	r20, 0x01	; 1
 11e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 122:	81 e0       	ldi	r24, 0x01	; 1
 124:	67 e0       	ldi	r22, 0x07	; 7
 126:	40 e0       	ldi	r20, 0x00	; 0
 128:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 12c:	00 c0       	rjmp	.+0      	; 0x12e <H_SSD_void_DisplayNumber+0x12e>
 12e:	81 e0       	ldi	r24, 0x01	; 1
 130:	61 e0       	ldi	r22, 0x01	; 1
 132:	40 e0       	ldi	r20, 0x00	; 0
 134:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 138:	81 e0       	ldi	r24, 0x01	; 1
 13a:	62 e0       	ldi	r22, 0x02	; 2
 13c:	41 e0       	ldi	r20, 0x01	; 1
 13e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 142:	81 e0       	ldi	r24, 0x01	; 1
 144:	63 e0       	ldi	r22, 0x03	; 3
 146:	41 e0       	ldi	r20, 0x01	; 1
 148:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 14c:	81 e0       	ldi	r24, 0x01	; 1
 14e:	64 e0       	ldi	r22, 0x04	; 4
 150:	40 e0       	ldi	r20, 0x00	; 0
 152:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 156:	81 e0       	ldi	r24, 0x01	; 1
 158:	65 e0       	ldi	r22, 0x05	; 5
 15a:	40 e0       	ldi	r20, 0x00	; 0
 15c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 160:	81 e0       	ldi	r24, 0x01	; 1
 162:	66 e0       	ldi	r22, 0x06	; 6
 164:	40 e0       	ldi	r20, 0x00	; 0
 166:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 16a:	81 e0       	ldi	r24, 0x01	; 1
 16c:	67 e0       	ldi	r22, 0x07	; 7
 16e:	40 e0       	ldi	r20, 0x00	; 0
 170:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 174:	00 c0       	rjmp	.+0      	; 0x176 <H_SSD_void_DisplayNumber+0x176>
 176:	81 e0       	ldi	r24, 0x01	; 1
 178:	61 e0       	ldi	r22, 0x01	; 1
 17a:	41 e0       	ldi	r20, 0x01	; 1
 17c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 180:	81 e0       	ldi	r24, 0x01	; 1
 182:	62 e0       	ldi	r22, 0x02	; 2
 184:	41 e0       	ldi	r20, 0x01	; 1
 186:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 18a:	81 e0       	ldi	r24, 0x01	; 1
 18c:	63 e0       	ldi	r22, 0x03	; 3
 18e:	40 e0       	ldi	r20, 0x00	; 0
 190:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 194:	81 e0       	ldi	r24, 0x01	; 1
 196:	64 e0       	ldi	r22, 0x04	; 4
 198:	41 e0       	ldi	r20, 0x01	; 1
 19a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 19e:	81 e0       	ldi	r24, 0x01	; 1
 1a0:	65 e0       	ldi	r22, 0x05	; 5
 1a2:	41 e0       	ldi	r20, 0x01	; 1
 1a4:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 1a8:	81 e0       	ldi	r24, 0x01	; 1
 1aa:	66 e0       	ldi	r22, 0x06	; 6
 1ac:	40 e0       	ldi	r20, 0x00	; 0
 1ae:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 1b2:	81 e0       	ldi	r24, 0x01	; 1
 1b4:	67 e0       	ldi	r22, 0x07	; 7
 1b6:	41 e0       	ldi	r20, 0x01	; 1
 1b8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 1bc:	00 c0       	rjmp	.+0      	; 0x1be <H_SSD_void_DisplayNumber+0x1be>
 1be:	81 e0       	ldi	r24, 0x01	; 1
 1c0:	61 e0       	ldi	r22, 0x01	; 1
 1c2:	41 e0       	ldi	r20, 0x01	; 1
 1c4:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 1c8:	81 e0       	ldi	r24, 0x01	; 1
 1ca:	62 e0       	ldi	r22, 0x02	; 2
 1cc:	41 e0       	ldi	r20, 0x01	; 1
 1ce:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 1d2:	81 e0       	ldi	r24, 0x01	; 1
 1d4:	63 e0       	ldi	r22, 0x03	; 3
 1d6:	41 e0       	ldi	r20, 0x01	; 1
 1d8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 1dc:	81 e0       	ldi	r24, 0x01	; 1
 1de:	64 e0       	ldi	r22, 0x04	; 4
 1e0:	41 e0       	ldi	r20, 0x01	; 1
 1e2:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 1e6:	81 e0       	ldi	r24, 0x01	; 1
 1e8:	65 e0       	ldi	r22, 0x05	; 5
 1ea:	40 e0       	ldi	r20, 0x00	; 0
 1ec:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 1f0:	81 e0       	ldi	r24, 0x01	; 1
 1f2:	66 e0       	ldi	r22, 0x06	; 6
 1f4:	40 e0       	ldi	r20, 0x00	; 0
 1f6:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 1fa:	81 e0       	ldi	r24, 0x01	; 1
 1fc:	67 e0       	ldi	r22, 0x07	; 7
 1fe:	41 e0       	ldi	r20, 0x01	; 1
 200:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 204:	00 c0       	rjmp	.+0      	; 0x206 <H_SSD_void_DisplayNumber+0x206>
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	61 e0       	ldi	r22, 0x01	; 1
 20a:	40 e0       	ldi	r20, 0x00	; 0
 20c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 210:	81 e0       	ldi	r24, 0x01	; 1
 212:	62 e0       	ldi	r22, 0x02	; 2
 214:	41 e0       	ldi	r20, 0x01	; 1
 216:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 21a:	81 e0       	ldi	r24, 0x01	; 1
 21c:	63 e0       	ldi	r22, 0x03	; 3
 21e:	41 e0       	ldi	r20, 0x01	; 1
 220:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 224:	81 e0       	ldi	r24, 0x01	; 1
 226:	64 e0       	ldi	r22, 0x04	; 4
 228:	40 e0       	ldi	r20, 0x00	; 0
 22a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 22e:	81 e0       	ldi	r24, 0x01	; 1
 230:	65 e0       	ldi	r22, 0x05	; 5
 232:	40 e0       	ldi	r20, 0x00	; 0
 234:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 238:	81 e0       	ldi	r24, 0x01	; 1
 23a:	66 e0       	ldi	r22, 0x06	; 6
 23c:	41 e0       	ldi	r20, 0x01	; 1
 23e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 242:	81 e0       	ldi	r24, 0x01	; 1
 244:	67 e0       	ldi	r22, 0x07	; 7
 246:	41 e0       	ldi	r20, 0x01	; 1
 248:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 24c:	00 c0       	rjmp	.+0      	; 0x24e <H_SSD_void_DisplayNumber+0x24e>
 24e:	81 e0       	ldi	r24, 0x01	; 1
 250:	61 e0       	ldi	r22, 0x01	; 1
 252:	41 e0       	ldi	r20, 0x01	; 1
 254:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	62 e0       	ldi	r22, 0x02	; 2
 25c:	40 e0       	ldi	r20, 0x00	; 0
 25e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 262:	81 e0       	ldi	r24, 0x01	; 1
 264:	63 e0       	ldi	r22, 0x03	; 3
 266:	41 e0       	ldi	r20, 0x01	; 1
 268:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 26c:	81 e0       	ldi	r24, 0x01	; 1
 26e:	64 e0       	ldi	r22, 0x04	; 4
 270:	41 e0       	ldi	r20, 0x01	; 1
 272:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 276:	81 e0       	ldi	r24, 0x01	; 1
 278:	65 e0       	ldi	r22, 0x05	; 5
 27a:	40 e0       	ldi	r20, 0x00	; 0
 27c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 280:	81 e0       	ldi	r24, 0x01	; 1
 282:	66 e0       	ldi	r22, 0x06	; 6
 284:	41 e0       	ldi	r20, 0x01	; 1
 286:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 28a:	81 e0       	ldi	r24, 0x01	; 1
 28c:	67 e0       	ldi	r22, 0x07	; 7
 28e:	41 e0       	ldi	r20, 0x01	; 1
 290:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 294:	00 c0       	rjmp	.+0      	; 0x296 <H_SSD_void_DisplayNumber+0x296>
 296:	81 e0       	ldi	r24, 0x01	; 1
 298:	61 e0       	ldi	r22, 0x01	; 1
 29a:	41 e0       	ldi	r20, 0x01	; 1
 29c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2a0:	81 e0       	ldi	r24, 0x01	; 1
 2a2:	62 e0       	ldi	r22, 0x02	; 2
 2a4:	40 e0       	ldi	r20, 0x00	; 0
 2a6:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2aa:	81 e0       	ldi	r24, 0x01	; 1
 2ac:	63 e0       	ldi	r22, 0x03	; 3
 2ae:	41 e0       	ldi	r20, 0x01	; 1
 2b0:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2b4:	81 e0       	ldi	r24, 0x01	; 1
 2b6:	64 e0       	ldi	r22, 0x04	; 4
 2b8:	41 e0       	ldi	r20, 0x01	; 1
 2ba:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2be:	81 e0       	ldi	r24, 0x01	; 1
 2c0:	65 e0       	ldi	r22, 0x05	; 5
 2c2:	41 e0       	ldi	r20, 0x01	; 1
 2c4:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2c8:	81 e0       	ldi	r24, 0x01	; 1
 2ca:	66 e0       	ldi	r22, 0x06	; 6
 2cc:	41 e0       	ldi	r20, 0x01	; 1
 2ce:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2d2:	81 e0       	ldi	r24, 0x01	; 1
 2d4:	67 e0       	ldi	r22, 0x07	; 7
 2d6:	41 e0       	ldi	r20, 0x01	; 1
 2d8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2dc:	00 c0       	rjmp	.+0      	; 0x2de <H_SSD_void_DisplayNumber+0x2de>
 2de:	81 e0       	ldi	r24, 0x01	; 1
 2e0:	61 e0       	ldi	r22, 0x01	; 1
 2e2:	41 e0       	ldi	r20, 0x01	; 1
 2e4:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2e8:	81 e0       	ldi	r24, 0x01	; 1
 2ea:	62 e0       	ldi	r22, 0x02	; 2
 2ec:	41 e0       	ldi	r20, 0x01	; 1
 2ee:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2f2:	81 e0       	ldi	r24, 0x01	; 1
 2f4:	63 e0       	ldi	r22, 0x03	; 3
 2f6:	41 e0       	ldi	r20, 0x01	; 1
 2f8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 2fc:	81 e0       	ldi	r24, 0x01	; 1
 2fe:	64 e0       	ldi	r22, 0x04	; 4
 300:	40 e0       	ldi	r20, 0x00	; 0
 302:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 306:	81 e0       	ldi	r24, 0x01	; 1
 308:	65 e0       	ldi	r22, 0x05	; 5
 30a:	40 e0       	ldi	r20, 0x00	; 0
 30c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 310:	81 e0       	ldi	r24, 0x01	; 1
 312:	66 e0       	ldi	r22, 0x06	; 6
 314:	40 e0       	ldi	r20, 0x00	; 0
 316:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 31a:	81 e0       	ldi	r24, 0x01	; 1
 31c:	67 e0       	ldi	r22, 0x07	; 7
 31e:	40 e0       	ldi	r20, 0x00	; 0
 320:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 324:	00 c0       	rjmp	.+0      	; 0x326 <H_SSD_void_DisplayNumber+0x326>
 326:	81 e0       	ldi	r24, 0x01	; 1
 328:	61 e0       	ldi	r22, 0x01	; 1
 32a:	41 e0       	ldi	r20, 0x01	; 1
 32c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 330:	81 e0       	ldi	r24, 0x01	; 1
 332:	62 e0       	ldi	r22, 0x02	; 2
 334:	41 e0       	ldi	r20, 0x01	; 1
 336:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 33a:	81 e0       	ldi	r24, 0x01	; 1
 33c:	63 e0       	ldi	r22, 0x03	; 3
 33e:	41 e0       	ldi	r20, 0x01	; 1
 340:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 344:	81 e0       	ldi	r24, 0x01	; 1
 346:	64 e0       	ldi	r22, 0x04	; 4
 348:	41 e0       	ldi	r20, 0x01	; 1
 34a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 34e:	81 e0       	ldi	r24, 0x01	; 1
 350:	65 e0       	ldi	r22, 0x05	; 5
 352:	41 e0       	ldi	r20, 0x01	; 1
 354:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 358:	81 e0       	ldi	r24, 0x01	; 1
 35a:	66 e0       	ldi	r22, 0x06	; 6
 35c:	41 e0       	ldi	r20, 0x01	; 1
 35e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 362:	81 e0       	ldi	r24, 0x01	; 1
 364:	67 e0       	ldi	r22, 0x07	; 7
 366:	41 e0       	ldi	r20, 0x01	; 1
 368:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 36c:	00 c0       	rjmp	.+0      	; 0x36e <H_SSD_void_DisplayNumber+0x36e>
 36e:	81 e0       	ldi	r24, 0x01	; 1
 370:	61 e0       	ldi	r22, 0x01	; 1
 372:	41 e0       	ldi	r20, 0x01	; 1
 374:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 378:	81 e0       	ldi	r24, 0x01	; 1
 37a:	62 e0       	ldi	r22, 0x02	; 2
 37c:	41 e0       	ldi	r20, 0x01	; 1
 37e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 382:	81 e0       	ldi	r24, 0x01	; 1
 384:	63 e0       	ldi	r22, 0x03	; 3
 386:	41 e0       	ldi	r20, 0x01	; 1
 388:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 38c:	81 e0       	ldi	r24, 0x01	; 1
 38e:	64 e0       	ldi	r22, 0x04	; 4
 390:	41 e0       	ldi	r20, 0x01	; 1
 392:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 396:	81 e0       	ldi	r24, 0x01	; 1
 398:	65 e0       	ldi	r22, 0x05	; 5
 39a:	40 e0       	ldi	r20, 0x00	; 0
 39c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 3a0:	81 e0       	ldi	r24, 0x01	; 1
 3a2:	66 e0       	ldi	r22, 0x06	; 6
 3a4:	41 e0       	ldi	r20, 0x01	; 1
 3a6:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 3aa:	81 e0       	ldi	r24, 0x01	; 1
 3ac:	67 e0       	ldi	r22, 0x07	; 7
 3ae:	41 e0       	ldi	r20, 0x01	; 1
 3b0:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 3b4:	83 e0       	ldi	r24, 0x03	; 3
 3b6:	66 e0       	ldi	r22, 0x06	; 6
 3b8:	41 e0       	ldi	r20, 0x01	; 1
 3ba:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 3be:	83 e0       	ldi	r24, 0x03	; 3
 3c0:	67 e0       	ldi	r22, 0x07	; 7
 3c2:	40 e0       	ldi	r20, 0x00	; 0
 3c4:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 3c8:	80 e0       	ldi	r24, 0x00	; 0
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	a0 e8       	ldi	r26, 0x80	; 128
 3ce:	bf e3       	ldi	r27, 0x3F	; 63
 3d0:	89 8f       	std	Y+25, r24	; 0x19
 3d2:	9a 8f       	std	Y+26, r25	; 0x1a
 3d4:	ab 8f       	std	Y+27, r26	; 0x1b
 3d6:	bc 8f       	std	Y+28, r27	; 0x1c
 3d8:	69 8d       	ldd	r22, Y+25	; 0x19
 3da:	7a 8d       	ldd	r23, Y+26	; 0x1a
 3dc:	8b 8d       	ldd	r24, Y+27	; 0x1b
 3de:	9c 8d       	ldd	r25, Y+28	; 0x1c
 3e0:	20 e0       	ldi	r18, 0x00	; 0
 3e2:	30 e0       	ldi	r19, 0x00	; 0
 3e4:	4a e7       	ldi	r20, 0x7A	; 122
 3e6:	55 e4       	ldi	r21, 0x45	; 69
 3e8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 3ec:	dc 01       	movw	r26, r24
 3ee:	cb 01       	movw	r24, r22
 3f0:	8d 8b       	std	Y+21, r24	; 0x15
 3f2:	9e 8b       	std	Y+22, r25	; 0x16
 3f4:	af 8b       	std	Y+23, r26	; 0x17
 3f6:	b8 8f       	std	Y+24, r27	; 0x18
 3f8:	6d 89       	ldd	r22, Y+21	; 0x15
 3fa:	7e 89       	ldd	r23, Y+22	; 0x16
 3fc:	8f 89       	ldd	r24, Y+23	; 0x17
 3fe:	98 8d       	ldd	r25, Y+24	; 0x18
 400:	20 e0       	ldi	r18, 0x00	; 0
 402:	30 e0       	ldi	r19, 0x00	; 0
 404:	40 e8       	ldi	r20, 0x80	; 128
 406:	5f e3       	ldi	r21, 0x3F	; 63
 408:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 40c:	88 23       	and	r24, r24
 40e:	04 f4       	brge	.+0      	; 0x410 <H_SSD_void_DisplayNumber+0x410>
 410:	81 e0       	ldi	r24, 0x01	; 1
 412:	90 e0       	ldi	r25, 0x00	; 0
 414:	9c 8b       	std	Y+20, r25	; 0x14
 416:	8b 8b       	std	Y+19, r24	; 0x13
 418:	00 c0       	rjmp	.+0      	; 0x41a <H_SSD_void_DisplayNumber+0x41a>
 41a:	6d 89       	ldd	r22, Y+21	; 0x15
 41c:	7e 89       	ldd	r23, Y+22	; 0x16
 41e:	8f 89       	ldd	r24, Y+23	; 0x17
 420:	98 8d       	ldd	r25, Y+24	; 0x18
 422:	20 e0       	ldi	r18, 0x00	; 0
 424:	3f ef       	ldi	r19, 0xFF	; 255
 426:	4f e7       	ldi	r20, 0x7F	; 127
 428:	57 e4       	ldi	r21, 0x47	; 71
 42a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 42e:	18 16       	cp	r1, r24
 430:	04 f4       	brge	.+0      	; 0x432 <H_SSD_void_DisplayNumber+0x432>
 432:	69 8d       	ldd	r22, Y+25	; 0x19
 434:	7a 8d       	ldd	r23, Y+26	; 0x1a
 436:	8b 8d       	ldd	r24, Y+27	; 0x1b
 438:	9c 8d       	ldd	r25, Y+28	; 0x1c
 43a:	20 e0       	ldi	r18, 0x00	; 0
 43c:	30 e0       	ldi	r19, 0x00	; 0
 43e:	40 e2       	ldi	r20, 0x20	; 32
 440:	51 e4       	ldi	r21, 0x41	; 65
 442:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 446:	dc 01       	movw	r26, r24
 448:	cb 01       	movw	r24, r22
 44a:	bc 01       	movw	r22, r24
 44c:	cd 01       	movw	r24, r26
 44e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 452:	dc 01       	movw	r26, r24
 454:	cb 01       	movw	r24, r22
 456:	9c 8b       	std	Y+20, r25	; 0x14
 458:	8b 8b       	std	Y+19, r24	; 0x13
 45a:	00 c0       	rjmp	.+0      	; 0x45c <H_SSD_void_DisplayNumber+0x45c>
 45c:	80 e9       	ldi	r24, 0x90	; 144
 45e:	91 e0       	ldi	r25, 0x01	; 1
 460:	9a 8b       	std	Y+18, r25	; 0x12
 462:	89 8b       	std	Y+17, r24	; 0x11
 464:	89 89       	ldd	r24, Y+17	; 0x11
 466:	9a 89       	ldd	r25, Y+18	; 0x12
 468:	01 97       	sbiw	r24, 0x01	; 1
 46a:	01 f4       	brne	.+0      	; 0x46c <H_SSD_void_DisplayNumber+0x46c>
 46c:	9a 8b       	std	Y+18, r25	; 0x12
 46e:	89 8b       	std	Y+17, r24	; 0x11
 470:	8b 89       	ldd	r24, Y+19	; 0x13
 472:	9c 89       	ldd	r25, Y+20	; 0x14
 474:	01 97       	sbiw	r24, 0x01	; 1
 476:	9c 8b       	std	Y+20, r25	; 0x14
 478:	8b 8b       	std	Y+19, r24	; 0x13
 47a:	8b 89       	ldd	r24, Y+19	; 0x13
 47c:	9c 89       	ldd	r25, Y+20	; 0x14
 47e:	00 97       	sbiw	r24, 0x00	; 0
 480:	01 f4       	brne	.+0      	; 0x482 <H_SSD_void_DisplayNumber+0x482>
 482:	00 c0       	rjmp	.+0      	; 0x484 <H_SSD_void_DisplayNumber+0x484>
 484:	6d 89       	ldd	r22, Y+21	; 0x15
 486:	7e 89       	ldd	r23, Y+22	; 0x16
 488:	8f 89       	ldd	r24, Y+23	; 0x17
 48a:	98 8d       	ldd	r25, Y+24	; 0x18
 48c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 490:	dc 01       	movw	r26, r24
 492:	cb 01       	movw	r24, r22
 494:	9c 8b       	std	Y+20, r25	; 0x14
 496:	8b 8b       	std	Y+19, r24	; 0x13
 498:	8b 89       	ldd	r24, Y+19	; 0x13
 49a:	9c 89       	ldd	r25, Y+20	; 0x14
 49c:	98 8b       	std	Y+16, r25	; 0x10
 49e:	8f 87       	std	Y+15, r24	; 0x0f
 4a0:	8f 85       	ldd	r24, Y+15	; 0x0f
 4a2:	98 89       	ldd	r25, Y+16	; 0x10
 4a4:	01 97       	sbiw	r24, 0x01	; 1
 4a6:	01 f4       	brne	.+0      	; 0x4a8 <H_SSD_void_DisplayNumber+0x4a8>
 4a8:	98 8b       	std	Y+16, r25	; 0x10
 4aa:	8f 87       	std	Y+15, r24	; 0x0f
 4ac:	83 e0       	ldi	r24, 0x03	; 3
 4ae:	66 e0       	ldi	r22, 0x06	; 6
 4b0:	40 e0       	ldi	r20, 0x00	; 0
 4b2:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 4b6:	8d 8d       	ldd	r24, Y+29	; 0x1d
 4b8:	28 2f       	mov	r18, r24
 4ba:	30 e0       	ldi	r19, 0x00	; 0
 4bc:	3d a3       	std	Y+37, r19	; 0x25
 4be:	2c a3       	std	Y+36, r18	; 0x24
 4c0:	8c a1       	ldd	r24, Y+36	; 0x24
 4c2:	9d a1       	ldd	r25, Y+37	; 0x25
 4c4:	84 30       	cpi	r24, 0x04	; 4
 4c6:	91 05       	cpc	r25, r1
 4c8:	01 f4       	brne	.+0      	; 0x4ca <H_SSD_void_DisplayNumber+0x4ca>
 4ca:	00 c0       	rjmp	.+0      	; 0x4cc <H_SSD_void_DisplayNumber+0x4cc>
 4cc:	2c a1       	ldd	r18, Y+36	; 0x24
 4ce:	3d a1       	ldd	r19, Y+37	; 0x25
 4d0:	25 30       	cpi	r18, 0x05	; 5
 4d2:	31 05       	cpc	r19, r1
 4d4:	04 f4       	brge	.+0      	; 0x4d6 <H_SSD_void_DisplayNumber+0x4d6>
 4d6:	8c a1       	ldd	r24, Y+36	; 0x24
 4d8:	9d a1       	ldd	r25, Y+37	; 0x25
 4da:	81 30       	cpi	r24, 0x01	; 1
 4dc:	91 05       	cpc	r25, r1
 4de:	01 f4       	brne	.+0      	; 0x4e0 <H_SSD_void_DisplayNumber+0x4e0>
 4e0:	00 c0       	rjmp	.+0      	; 0x4e2 <H_SSD_void_DisplayNumber+0x4e2>
 4e2:	2c a1       	ldd	r18, Y+36	; 0x24
 4e4:	3d a1       	ldd	r19, Y+37	; 0x25
 4e6:	22 30       	cpi	r18, 0x02	; 2
 4e8:	31 05       	cpc	r19, r1
 4ea:	04 f4       	brge	.+0      	; 0x4ec <H_SSD_void_DisplayNumber+0x4ec>
 4ec:	8c a1       	ldd	r24, Y+36	; 0x24
 4ee:	9d a1       	ldd	r25, Y+37	; 0x25
 4f0:	00 97       	sbiw	r24, 0x00	; 0
 4f2:	01 f0       	breq	.+0      	; 0x4f4 <H_SSD_void_DisplayNumber+0x4f4>
 4f4:	00 c0       	rjmp	.+0      	; 0x4f6 <H_SSD_void_DisplayNumber+0x4f6>
 4f6:	2c a1       	ldd	r18, Y+36	; 0x24
 4f8:	3d a1       	ldd	r19, Y+37	; 0x25
 4fa:	22 30       	cpi	r18, 0x02	; 2
 4fc:	31 05       	cpc	r19, r1
 4fe:	01 f4       	brne	.+0      	; 0x500 <H_SSD_void_DisplayNumber+0x500>
 500:	00 c0       	rjmp	.+0      	; 0x502 <H_SSD_void_DisplayNumber+0x502>
 502:	8c a1       	ldd	r24, Y+36	; 0x24
 504:	9d a1       	ldd	r25, Y+37	; 0x25
 506:	83 30       	cpi	r24, 0x03	; 3
 508:	91 05       	cpc	r25, r1
 50a:	01 f4       	brne	.+0      	; 0x50c <H_SSD_void_DisplayNumber+0x50c>
 50c:	00 c0       	rjmp	.+0      	; 0x50e <H_SSD_void_DisplayNumber+0x50e>
 50e:	00 c0       	rjmp	.+0      	; 0x510 <H_SSD_void_DisplayNumber+0x510>
 510:	2c a1       	ldd	r18, Y+36	; 0x24
 512:	3d a1       	ldd	r19, Y+37	; 0x25
 514:	27 30       	cpi	r18, 0x07	; 7
 516:	31 05       	cpc	r19, r1
 518:	01 f4       	brne	.+0      	; 0x51a <H_SSD_void_DisplayNumber+0x51a>
 51a:	00 c0       	rjmp	.+0      	; 0x51c <H_SSD_void_DisplayNumber+0x51c>
 51c:	8c a1       	ldd	r24, Y+36	; 0x24
 51e:	9d a1       	ldd	r25, Y+37	; 0x25
 520:	88 30       	cpi	r24, 0x08	; 8
 522:	91 05       	cpc	r25, r1
 524:	04 f4       	brge	.+0      	; 0x526 <H_SSD_void_DisplayNumber+0x526>
 526:	2c a1       	ldd	r18, Y+36	; 0x24
 528:	3d a1       	ldd	r19, Y+37	; 0x25
 52a:	25 30       	cpi	r18, 0x05	; 5
 52c:	31 05       	cpc	r19, r1
 52e:	01 f4       	brne	.+0      	; 0x530 <H_SSD_void_DisplayNumber+0x530>
 530:	00 c0       	rjmp	.+0      	; 0x532 <H_SSD_void_DisplayNumber+0x532>
 532:	8c a1       	ldd	r24, Y+36	; 0x24
 534:	9d a1       	ldd	r25, Y+37	; 0x25
 536:	86 30       	cpi	r24, 0x06	; 6
 538:	91 05       	cpc	r25, r1
 53a:	01 f4       	brne	.+0      	; 0x53c <H_SSD_void_DisplayNumber+0x53c>
 53c:	00 c0       	rjmp	.+0      	; 0x53e <H_SSD_void_DisplayNumber+0x53e>
 53e:	00 c0       	rjmp	.+0      	; 0x540 <H_SSD_void_DisplayNumber+0x540>
 540:	2c a1       	ldd	r18, Y+36	; 0x24
 542:	3d a1       	ldd	r19, Y+37	; 0x25
 544:	28 30       	cpi	r18, 0x08	; 8
 546:	31 05       	cpc	r19, r1
 548:	01 f4       	brne	.+0      	; 0x54a <H_SSD_void_DisplayNumber+0x54a>
 54a:	00 c0       	rjmp	.+0      	; 0x54c <H_SSD_void_DisplayNumber+0x54c>
 54c:	8c a1       	ldd	r24, Y+36	; 0x24
 54e:	9d a1       	ldd	r25, Y+37	; 0x25
 550:	89 30       	cpi	r24, 0x09	; 9
 552:	91 05       	cpc	r25, r1
 554:	01 f4       	brne	.+0      	; 0x556 <H_SSD_void_DisplayNumber+0x556>
 556:	00 c0       	rjmp	.+0      	; 0x558 <H_SSD_void_DisplayNumber+0x558>
 558:	00 c0       	rjmp	.+0      	; 0x55a <H_SSD_void_DisplayNumber+0x55a>
 55a:	81 e0       	ldi	r24, 0x01	; 1
 55c:	61 e0       	ldi	r22, 0x01	; 1
 55e:	41 e0       	ldi	r20, 0x01	; 1
 560:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 564:	81 e0       	ldi	r24, 0x01	; 1
 566:	62 e0       	ldi	r22, 0x02	; 2
 568:	41 e0       	ldi	r20, 0x01	; 1
 56a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 56e:	81 e0       	ldi	r24, 0x01	; 1
 570:	63 e0       	ldi	r22, 0x03	; 3
 572:	41 e0       	ldi	r20, 0x01	; 1
 574:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 578:	81 e0       	ldi	r24, 0x01	; 1
 57a:	64 e0       	ldi	r22, 0x04	; 4
 57c:	41 e0       	ldi	r20, 0x01	; 1
 57e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 582:	81 e0       	ldi	r24, 0x01	; 1
 584:	65 e0       	ldi	r22, 0x05	; 5
 586:	41 e0       	ldi	r20, 0x01	; 1
 588:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 58c:	81 e0       	ldi	r24, 0x01	; 1
 58e:	66 e0       	ldi	r22, 0x06	; 6
 590:	41 e0       	ldi	r20, 0x01	; 1
 592:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 596:	81 e0       	ldi	r24, 0x01	; 1
 598:	67 e0       	ldi	r22, 0x07	; 7
 59a:	40 e0       	ldi	r20, 0x00	; 0
 59c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5a0:	00 c0       	rjmp	.+0      	; 0x5a2 <H_SSD_void_DisplayNumber+0x5a2>
 5a2:	81 e0       	ldi	r24, 0x01	; 1
 5a4:	61 e0       	ldi	r22, 0x01	; 1
 5a6:	40 e0       	ldi	r20, 0x00	; 0
 5a8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5ac:	81 e0       	ldi	r24, 0x01	; 1
 5ae:	62 e0       	ldi	r22, 0x02	; 2
 5b0:	41 e0       	ldi	r20, 0x01	; 1
 5b2:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5b6:	81 e0       	ldi	r24, 0x01	; 1
 5b8:	63 e0       	ldi	r22, 0x03	; 3
 5ba:	41 e0       	ldi	r20, 0x01	; 1
 5bc:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5c0:	81 e0       	ldi	r24, 0x01	; 1
 5c2:	64 e0       	ldi	r22, 0x04	; 4
 5c4:	40 e0       	ldi	r20, 0x00	; 0
 5c6:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5ca:	81 e0       	ldi	r24, 0x01	; 1
 5cc:	65 e0       	ldi	r22, 0x05	; 5
 5ce:	40 e0       	ldi	r20, 0x00	; 0
 5d0:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5d4:	81 e0       	ldi	r24, 0x01	; 1
 5d6:	66 e0       	ldi	r22, 0x06	; 6
 5d8:	40 e0       	ldi	r20, 0x00	; 0
 5da:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5de:	81 e0       	ldi	r24, 0x01	; 1
 5e0:	67 e0       	ldi	r22, 0x07	; 7
 5e2:	40 e0       	ldi	r20, 0x00	; 0
 5e4:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5e8:	00 c0       	rjmp	.+0      	; 0x5ea <H_SSD_void_DisplayNumber+0x5ea>
 5ea:	81 e0       	ldi	r24, 0x01	; 1
 5ec:	61 e0       	ldi	r22, 0x01	; 1
 5ee:	41 e0       	ldi	r20, 0x01	; 1
 5f0:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5f4:	81 e0       	ldi	r24, 0x01	; 1
 5f6:	62 e0       	ldi	r22, 0x02	; 2
 5f8:	41 e0       	ldi	r20, 0x01	; 1
 5fa:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 5fe:	81 e0       	ldi	r24, 0x01	; 1
 600:	63 e0       	ldi	r22, 0x03	; 3
 602:	40 e0       	ldi	r20, 0x00	; 0
 604:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 608:	81 e0       	ldi	r24, 0x01	; 1
 60a:	64 e0       	ldi	r22, 0x04	; 4
 60c:	41 e0       	ldi	r20, 0x01	; 1
 60e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 612:	81 e0       	ldi	r24, 0x01	; 1
 614:	65 e0       	ldi	r22, 0x05	; 5
 616:	41 e0       	ldi	r20, 0x01	; 1
 618:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 61c:	81 e0       	ldi	r24, 0x01	; 1
 61e:	66 e0       	ldi	r22, 0x06	; 6
 620:	40 e0       	ldi	r20, 0x00	; 0
 622:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 626:	81 e0       	ldi	r24, 0x01	; 1
 628:	67 e0       	ldi	r22, 0x07	; 7
 62a:	41 e0       	ldi	r20, 0x01	; 1
 62c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 630:	00 c0       	rjmp	.+0      	; 0x632 <H_SSD_void_DisplayNumber+0x632>
 632:	81 e0       	ldi	r24, 0x01	; 1
 634:	61 e0       	ldi	r22, 0x01	; 1
 636:	41 e0       	ldi	r20, 0x01	; 1
 638:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 63c:	81 e0       	ldi	r24, 0x01	; 1
 63e:	62 e0       	ldi	r22, 0x02	; 2
 640:	41 e0       	ldi	r20, 0x01	; 1
 642:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 646:	81 e0       	ldi	r24, 0x01	; 1
 648:	63 e0       	ldi	r22, 0x03	; 3
 64a:	41 e0       	ldi	r20, 0x01	; 1
 64c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 650:	81 e0       	ldi	r24, 0x01	; 1
 652:	64 e0       	ldi	r22, 0x04	; 4
 654:	41 e0       	ldi	r20, 0x01	; 1
 656:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 65a:	81 e0       	ldi	r24, 0x01	; 1
 65c:	65 e0       	ldi	r22, 0x05	; 5
 65e:	40 e0       	ldi	r20, 0x00	; 0
 660:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 664:	81 e0       	ldi	r24, 0x01	; 1
 666:	66 e0       	ldi	r22, 0x06	; 6
 668:	40 e0       	ldi	r20, 0x00	; 0
 66a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 66e:	81 e0       	ldi	r24, 0x01	; 1
 670:	67 e0       	ldi	r22, 0x07	; 7
 672:	41 e0       	ldi	r20, 0x01	; 1
 674:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 678:	00 c0       	rjmp	.+0      	; 0x67a <H_SSD_void_DisplayNumber+0x67a>
 67a:	81 e0       	ldi	r24, 0x01	; 1
 67c:	61 e0       	ldi	r22, 0x01	; 1
 67e:	40 e0       	ldi	r20, 0x00	; 0
 680:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 684:	81 e0       	ldi	r24, 0x01	; 1
 686:	62 e0       	ldi	r22, 0x02	; 2
 688:	41 e0       	ldi	r20, 0x01	; 1
 68a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 68e:	81 e0       	ldi	r24, 0x01	; 1
 690:	63 e0       	ldi	r22, 0x03	; 3
 692:	41 e0       	ldi	r20, 0x01	; 1
 694:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 698:	81 e0       	ldi	r24, 0x01	; 1
 69a:	64 e0       	ldi	r22, 0x04	; 4
 69c:	40 e0       	ldi	r20, 0x00	; 0
 69e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6a2:	81 e0       	ldi	r24, 0x01	; 1
 6a4:	65 e0       	ldi	r22, 0x05	; 5
 6a6:	40 e0       	ldi	r20, 0x00	; 0
 6a8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6ac:	81 e0       	ldi	r24, 0x01	; 1
 6ae:	66 e0       	ldi	r22, 0x06	; 6
 6b0:	41 e0       	ldi	r20, 0x01	; 1
 6b2:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6b6:	81 e0       	ldi	r24, 0x01	; 1
 6b8:	67 e0       	ldi	r22, 0x07	; 7
 6ba:	41 e0       	ldi	r20, 0x01	; 1
 6bc:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6c0:	00 c0       	rjmp	.+0      	; 0x6c2 <H_SSD_void_DisplayNumber+0x6c2>
 6c2:	81 e0       	ldi	r24, 0x01	; 1
 6c4:	61 e0       	ldi	r22, 0x01	; 1
 6c6:	41 e0       	ldi	r20, 0x01	; 1
 6c8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6cc:	81 e0       	ldi	r24, 0x01	; 1
 6ce:	62 e0       	ldi	r22, 0x02	; 2
 6d0:	40 e0       	ldi	r20, 0x00	; 0
 6d2:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6d6:	81 e0       	ldi	r24, 0x01	; 1
 6d8:	63 e0       	ldi	r22, 0x03	; 3
 6da:	41 e0       	ldi	r20, 0x01	; 1
 6dc:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6e0:	81 e0       	ldi	r24, 0x01	; 1
 6e2:	64 e0       	ldi	r22, 0x04	; 4
 6e4:	41 e0       	ldi	r20, 0x01	; 1
 6e6:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6ea:	81 e0       	ldi	r24, 0x01	; 1
 6ec:	65 e0       	ldi	r22, 0x05	; 5
 6ee:	40 e0       	ldi	r20, 0x00	; 0
 6f0:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6f4:	81 e0       	ldi	r24, 0x01	; 1
 6f6:	66 e0       	ldi	r22, 0x06	; 6
 6f8:	41 e0       	ldi	r20, 0x01	; 1
 6fa:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 6fe:	81 e0       	ldi	r24, 0x01	; 1
 700:	67 e0       	ldi	r22, 0x07	; 7
 702:	41 e0       	ldi	r20, 0x01	; 1
 704:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 708:	00 c0       	rjmp	.+0      	; 0x70a <H_SSD_void_DisplayNumber+0x70a>
 70a:	81 e0       	ldi	r24, 0x01	; 1
 70c:	61 e0       	ldi	r22, 0x01	; 1
 70e:	41 e0       	ldi	r20, 0x01	; 1
 710:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 714:	81 e0       	ldi	r24, 0x01	; 1
 716:	62 e0       	ldi	r22, 0x02	; 2
 718:	40 e0       	ldi	r20, 0x00	; 0
 71a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 71e:	81 e0       	ldi	r24, 0x01	; 1
 720:	63 e0       	ldi	r22, 0x03	; 3
 722:	41 e0       	ldi	r20, 0x01	; 1
 724:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 728:	81 e0       	ldi	r24, 0x01	; 1
 72a:	64 e0       	ldi	r22, 0x04	; 4
 72c:	41 e0       	ldi	r20, 0x01	; 1
 72e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 732:	81 e0       	ldi	r24, 0x01	; 1
 734:	65 e0       	ldi	r22, 0x05	; 5
 736:	41 e0       	ldi	r20, 0x01	; 1
 738:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 73c:	81 e0       	ldi	r24, 0x01	; 1
 73e:	66 e0       	ldi	r22, 0x06	; 6
 740:	41 e0       	ldi	r20, 0x01	; 1
 742:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 746:	81 e0       	ldi	r24, 0x01	; 1
 748:	67 e0       	ldi	r22, 0x07	; 7
 74a:	41 e0       	ldi	r20, 0x01	; 1
 74c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 750:	00 c0       	rjmp	.+0      	; 0x752 <H_SSD_void_DisplayNumber+0x752>
 752:	81 e0       	ldi	r24, 0x01	; 1
 754:	61 e0       	ldi	r22, 0x01	; 1
 756:	41 e0       	ldi	r20, 0x01	; 1
 758:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 75c:	81 e0       	ldi	r24, 0x01	; 1
 75e:	62 e0       	ldi	r22, 0x02	; 2
 760:	41 e0       	ldi	r20, 0x01	; 1
 762:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 766:	81 e0       	ldi	r24, 0x01	; 1
 768:	63 e0       	ldi	r22, 0x03	; 3
 76a:	41 e0       	ldi	r20, 0x01	; 1
 76c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 770:	81 e0       	ldi	r24, 0x01	; 1
 772:	64 e0       	ldi	r22, 0x04	; 4
 774:	40 e0       	ldi	r20, 0x00	; 0
 776:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 77a:	81 e0       	ldi	r24, 0x01	; 1
 77c:	65 e0       	ldi	r22, 0x05	; 5
 77e:	40 e0       	ldi	r20, 0x00	; 0
 780:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 784:	81 e0       	ldi	r24, 0x01	; 1
 786:	66 e0       	ldi	r22, 0x06	; 6
 788:	40 e0       	ldi	r20, 0x00	; 0
 78a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 78e:	81 e0       	ldi	r24, 0x01	; 1
 790:	67 e0       	ldi	r22, 0x07	; 7
 792:	40 e0       	ldi	r20, 0x00	; 0
 794:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 798:	00 c0       	rjmp	.+0      	; 0x79a <H_SSD_void_DisplayNumber+0x79a>
 79a:	81 e0       	ldi	r24, 0x01	; 1
 79c:	61 e0       	ldi	r22, 0x01	; 1
 79e:	41 e0       	ldi	r20, 0x01	; 1
 7a0:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 7a4:	81 e0       	ldi	r24, 0x01	; 1
 7a6:	62 e0       	ldi	r22, 0x02	; 2
 7a8:	41 e0       	ldi	r20, 0x01	; 1
 7aa:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 7ae:	81 e0       	ldi	r24, 0x01	; 1
 7b0:	63 e0       	ldi	r22, 0x03	; 3
 7b2:	41 e0       	ldi	r20, 0x01	; 1
 7b4:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 7b8:	81 e0       	ldi	r24, 0x01	; 1
 7ba:	64 e0       	ldi	r22, 0x04	; 4
 7bc:	41 e0       	ldi	r20, 0x01	; 1
 7be:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 7c2:	81 e0       	ldi	r24, 0x01	; 1
 7c4:	65 e0       	ldi	r22, 0x05	; 5
 7c6:	41 e0       	ldi	r20, 0x01	; 1
 7c8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 7cc:	81 e0       	ldi	r24, 0x01	; 1
 7ce:	66 e0       	ldi	r22, 0x06	; 6
 7d0:	41 e0       	ldi	r20, 0x01	; 1
 7d2:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 7d6:	81 e0       	ldi	r24, 0x01	; 1
 7d8:	67 e0       	ldi	r22, 0x07	; 7
 7da:	41 e0       	ldi	r20, 0x01	; 1
 7dc:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 7e0:	00 c0       	rjmp	.+0      	; 0x7e2 <H_SSD_void_DisplayNumber+0x7e2>
 7e2:	81 e0       	ldi	r24, 0x01	; 1
 7e4:	61 e0       	ldi	r22, 0x01	; 1
 7e6:	41 e0       	ldi	r20, 0x01	; 1
 7e8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 7ec:	81 e0       	ldi	r24, 0x01	; 1
 7ee:	62 e0       	ldi	r22, 0x02	; 2
 7f0:	41 e0       	ldi	r20, 0x01	; 1
 7f2:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 7f6:	81 e0       	ldi	r24, 0x01	; 1
 7f8:	63 e0       	ldi	r22, 0x03	; 3
 7fa:	41 e0       	ldi	r20, 0x01	; 1
 7fc:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 800:	81 e0       	ldi	r24, 0x01	; 1
 802:	64 e0       	ldi	r22, 0x04	; 4
 804:	41 e0       	ldi	r20, 0x01	; 1
 806:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 80a:	81 e0       	ldi	r24, 0x01	; 1
 80c:	65 e0       	ldi	r22, 0x05	; 5
 80e:	40 e0       	ldi	r20, 0x00	; 0
 810:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 814:	81 e0       	ldi	r24, 0x01	; 1
 816:	66 e0       	ldi	r22, 0x06	; 6
 818:	41 e0       	ldi	r20, 0x01	; 1
 81a:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 81e:	81 e0       	ldi	r24, 0x01	; 1
 820:	67 e0       	ldi	r22, 0x07	; 7
 822:	41 e0       	ldi	r20, 0x01	; 1
 824:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 828:	83 e0       	ldi	r24, 0x03	; 3
 82a:	67 e0       	ldi	r22, 0x07	; 7
 82c:	41 e0       	ldi	r20, 0x01	; 1
 82e:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 832:	80 e0       	ldi	r24, 0x00	; 0
 834:	90 e0       	ldi	r25, 0x00	; 0
 836:	a0 e8       	ldi	r26, 0x80	; 128
 838:	bf e3       	ldi	r27, 0x3F	; 63
 83a:	8b 87       	std	Y+11, r24	; 0x0b
 83c:	9c 87       	std	Y+12, r25	; 0x0c
 83e:	ad 87       	std	Y+13, r26	; 0x0d
 840:	be 87       	std	Y+14, r27	; 0x0e
 842:	6b 85       	ldd	r22, Y+11	; 0x0b
 844:	7c 85       	ldd	r23, Y+12	; 0x0c
 846:	8d 85       	ldd	r24, Y+13	; 0x0d
 848:	9e 85       	ldd	r25, Y+14	; 0x0e
 84a:	20 e0       	ldi	r18, 0x00	; 0
 84c:	30 e0       	ldi	r19, 0x00	; 0
 84e:	4a e7       	ldi	r20, 0x7A	; 122
 850:	55 e4       	ldi	r21, 0x45	; 69
 852:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 856:	dc 01       	movw	r26, r24
 858:	cb 01       	movw	r24, r22
 85a:	8f 83       	std	Y+7, r24	; 0x07
 85c:	98 87       	std	Y+8, r25	; 0x08
 85e:	a9 87       	std	Y+9, r26	; 0x09
 860:	ba 87       	std	Y+10, r27	; 0x0a
 862:	6f 81       	ldd	r22, Y+7	; 0x07
 864:	78 85       	ldd	r23, Y+8	; 0x08
 866:	89 85       	ldd	r24, Y+9	; 0x09
 868:	9a 85       	ldd	r25, Y+10	; 0x0a
 86a:	20 e0       	ldi	r18, 0x00	; 0
 86c:	30 e0       	ldi	r19, 0x00	; 0
 86e:	40 e8       	ldi	r20, 0x80	; 128
 870:	5f e3       	ldi	r21, 0x3F	; 63
 872:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 876:	88 23       	and	r24, r24
 878:	04 f4       	brge	.+0      	; 0x87a <H_SSD_void_DisplayNumber+0x87a>
 87a:	81 e0       	ldi	r24, 0x01	; 1
 87c:	90 e0       	ldi	r25, 0x00	; 0
 87e:	9e 83       	std	Y+6, r25	; 0x06
 880:	8d 83       	std	Y+5, r24	; 0x05
 882:	00 c0       	rjmp	.+0      	; 0x884 <H_SSD_void_DisplayNumber+0x884>
 884:	6f 81       	ldd	r22, Y+7	; 0x07
 886:	78 85       	ldd	r23, Y+8	; 0x08
 888:	89 85       	ldd	r24, Y+9	; 0x09
 88a:	9a 85       	ldd	r25, Y+10	; 0x0a
 88c:	20 e0       	ldi	r18, 0x00	; 0
 88e:	3f ef       	ldi	r19, 0xFF	; 255
 890:	4f e7       	ldi	r20, 0x7F	; 127
 892:	57 e4       	ldi	r21, 0x47	; 71
 894:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 898:	18 16       	cp	r1, r24
 89a:	04 f4       	brge	.+0      	; 0x89c <H_SSD_void_DisplayNumber+0x89c>
 89c:	6b 85       	ldd	r22, Y+11	; 0x0b
 89e:	7c 85       	ldd	r23, Y+12	; 0x0c
 8a0:	8d 85       	ldd	r24, Y+13	; 0x0d
 8a2:	9e 85       	ldd	r25, Y+14	; 0x0e
 8a4:	20 e0       	ldi	r18, 0x00	; 0
 8a6:	30 e0       	ldi	r19, 0x00	; 0
 8a8:	40 e2       	ldi	r20, 0x20	; 32
 8aa:	51 e4       	ldi	r21, 0x41	; 65
 8ac:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 8b0:	dc 01       	movw	r26, r24
 8b2:	cb 01       	movw	r24, r22
 8b4:	bc 01       	movw	r22, r24
 8b6:	cd 01       	movw	r24, r26
 8b8:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 8bc:	dc 01       	movw	r26, r24
 8be:	cb 01       	movw	r24, r22
 8c0:	9e 83       	std	Y+6, r25	; 0x06
 8c2:	8d 83       	std	Y+5, r24	; 0x05
 8c4:	00 c0       	rjmp	.+0      	; 0x8c6 <H_SSD_void_DisplayNumber+0x8c6>
 8c6:	80 e9       	ldi	r24, 0x90	; 144
 8c8:	91 e0       	ldi	r25, 0x01	; 1
 8ca:	9c 83       	std	Y+4, r25	; 0x04
 8cc:	8b 83       	std	Y+3, r24	; 0x03
 8ce:	8b 81       	ldd	r24, Y+3	; 0x03
 8d0:	9c 81       	ldd	r25, Y+4	; 0x04
 8d2:	01 97       	sbiw	r24, 0x01	; 1
 8d4:	01 f4       	brne	.+0      	; 0x8d6 <H_SSD_void_DisplayNumber+0x8d6>
 8d6:	9c 83       	std	Y+4, r25	; 0x04
 8d8:	8b 83       	std	Y+3, r24	; 0x03
 8da:	8d 81       	ldd	r24, Y+5	; 0x05
 8dc:	9e 81       	ldd	r25, Y+6	; 0x06
 8de:	01 97       	sbiw	r24, 0x01	; 1
 8e0:	9e 83       	std	Y+6, r25	; 0x06
 8e2:	8d 83       	std	Y+5, r24	; 0x05
 8e4:	8d 81       	ldd	r24, Y+5	; 0x05
 8e6:	9e 81       	ldd	r25, Y+6	; 0x06
 8e8:	00 97       	sbiw	r24, 0x00	; 0
 8ea:	01 f4       	brne	.+0      	; 0x8ec <H_SSD_void_DisplayNumber+0x8ec>
 8ec:	00 c0       	rjmp	.+0      	; 0x8ee <H_SSD_void_DisplayNumber+0x8ee>
 8ee:	6f 81       	ldd	r22, Y+7	; 0x07
 8f0:	78 85       	ldd	r23, Y+8	; 0x08
 8f2:	89 85       	ldd	r24, Y+9	; 0x09
 8f4:	9a 85       	ldd	r25, Y+10	; 0x0a
 8f6:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 8fa:	dc 01       	movw	r26, r24
 8fc:	cb 01       	movw	r24, r22
 8fe:	9e 83       	std	Y+6, r25	; 0x06
 900:	8d 83       	std	Y+5, r24	; 0x05
 902:	8d 81       	ldd	r24, Y+5	; 0x05
 904:	9e 81       	ldd	r25, Y+6	; 0x06
 906:	9a 83       	std	Y+2, r25	; 0x02
 908:	89 83       	std	Y+1, r24	; 0x01
 90a:	89 81       	ldd	r24, Y+1	; 0x01
 90c:	9a 81       	ldd	r25, Y+2	; 0x02
 90e:	01 97       	sbiw	r24, 0x01	; 1
 910:	01 f4       	brne	.+0      	; 0x912 <H_SSD_void_DisplayNumber+0x912>
 912:	9a 83       	std	Y+2, r25	; 0x02
 914:	89 83       	std	Y+1, r24	; 0x01
 916:	83 e0       	ldi	r24, 0x03	; 3
 918:	66 e0       	ldi	r22, 0x06	; 6
 91a:	40 e0       	ldi	r20, 0x00	; 0
 91c:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 920:	83 e0       	ldi	r24, 0x03	; 3
 922:	67 e0       	ldi	r22, 0x07	; 7
 924:	40 e0       	ldi	r20, 0x00	; 0
 926:	0e 94 00 00 	call	0	; 0x0 <H_SSD_void_DisplayNumber>
 92a:	8f 8d       	ldd	r24, Y+31	; 0x1f
 92c:	98 a1       	ldd	r25, Y+32	; 0x20
 92e:	a9 a1       	ldd	r26, Y+33	; 0x21
 930:	ba a1       	ldd	r27, Y+34	; 0x22
 932:	01 96       	adiw	r24, 0x01	; 1
 934:	a1 1d       	adc	r26, r1
 936:	b1 1d       	adc	r27, r1
 938:	8f 8f       	std	Y+31, r24	; 0x1f
 93a:	98 a3       	std	Y+32, r25	; 0x20
 93c:	a9 a3       	std	Y+33, r26	; 0x21
 93e:	ba a3       	std	Y+34, r27	; 0x22
 940:	8f 8d       	ldd	r24, Y+31	; 0x1f
 942:	98 a1       	ldd	r25, Y+32	; 0x20
 944:	a9 a1       	ldd	r26, Y+33	; 0x21
 946:	ba a1       	ldd	r27, Y+34	; 0x22
 948:	8a 3f       	cpi	r24, 0xFA	; 250
 94a:	91 05       	cpc	r25, r1
 94c:	a1 05       	cpc	r26, r1
 94e:	b1 05       	cpc	r27, r1
 950:	00 f4       	brcc	.+0      	; 0x952 <H_SSD_void_DisplayNumber+0x952>
 952:	00 c0       	rjmp	.+0      	; 0x954 <H_SSD_void_DisplayNumber+0x954>
 954:	a7 96       	adiw	r28, 0x27	; 39
 956:	0f b6       	in	r0, 0x3f	; 63
 958:	f8 94       	cli
 95a:	de bf       	out	0x3e, r29	; 62
 95c:	0f be       	out	0x3f, r0	; 63
 95e:	cd bf       	out	0x3d, r28	; 61
 960:	cf 91       	pop	r28
 962:	df 91       	pop	r29
 964:	08 95       	ret

PB_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000648  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000a0f  00000000  00000000  0000067c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.H_PB_void_init 0000002c  00000000  00000000  0000108b  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.H_PB_void_read 000002f6  00000000  00000000  000010b7  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.H_PB_void_init:

00000000 <H_PB_void_init>:
#include "PB_priv.h"
#include "PB_config.h"
#include "PB_int.h"

void H_PB_void_init(const PB_t * ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <H_PB_void_init+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
  // set direction
	M_Dio_void_setPinDir(ptr->PB_port,ptr->PB_pin, INPUT);
   e:	e9 81       	ldd	r30, Y+1	; 0x01
  10:	fa 81       	ldd	r31, Y+2	; 0x02
  12:	81 81       	ldd	r24, Z+1	; 0x01
  14:	e9 81       	ldd	r30, Y+1	; 0x01
  16:	fa 81       	ldd	r31, Y+2	; 0x02
  18:	92 81       	ldd	r25, Z+2	; 0x02
  1a:	69 2f       	mov	r22, r25
  1c:	40 e0       	ldi	r20, 0x00	; 0
  1e:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_init>
}
  22:	0f 90       	pop	r0
  24:	0f 90       	pop	r0
  26:	cf 91       	pop	r28
  28:	df 91       	pop	r29
  2a:	08 95       	ret

Disassembly of section .text.H_PB_void_read:

00000000 <H_PB_void_read>:
#include "PB_priv.h"
#include "PB_config.h"
#include "PB_int.h"

void H_PB_void_init(const PB_t * ptr)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	a1 97       	sbiw	r28, 0x21	; 33
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
  // set direction
	M_Dio_void_setPinDir(ptr->PB_port,ptr->PB_pin, INPUT);
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	9f 8f       	std	Y+31, r25	; 0x1f
  16:	8e 8f       	std	Y+30, r24	; 0x1e
  18:	79 a3       	std	Y+33, r23	; 0x21
  1a:	68 a3       	std	Y+32, r22	; 0x20
  1c:	ee 8d       	ldd	r30, Y+30	; 0x1e
  1e:	ff 8d       	ldd	r31, Y+31	; 0x1f
  20:	83 81       	ldd	r24, Z+3	; 0x03
}
  22:	88 23       	and	r24, r24
  24:	01 f0       	breq	.+0      	; 0x26 <H_PB_void_read+0x26>
  26:	00 c0       	rjmp	.+0      	; 0x28 <H_PB_void_read+0x28>
  28:	e8 a1       	ldd	r30, Y+32	; 0x20
  2a:	f9 a1       	ldd	r31, Y+33	; 0x21
  2c:	81 e0       	ldi	r24, 0x01	; 1
  2e:	80 83       	st	Z, r24
  30:	ee 8d       	ldd	r30, Y+30	; 0x1e
  32:	ff 8d       	ldd	r31, Y+31	; 0x1f
  34:	81 81       	ldd	r24, Z+1	; 0x01
  36:	ee 8d       	ldd	r30, Y+30	; 0x1e
  38:	ff 8d       	ldd	r31, Y+31	; 0x1f
  3a:	92 81       	ldd	r25, Z+2	; 0x02
  3c:	9e 01       	movw	r18, r28
  3e:	23 5e       	subi	r18, 0xE3	; 227
  40:	3f 4f       	sbci	r19, 0xFF	; 255
  42:	69 2f       	mov	r22, r25
  44:	a9 01       	movw	r20, r18
  46:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
  4a:	8d 8d       	ldd	r24, Y+29	; 0x1d
  4c:	88 23       	and	r24, r24
  4e:	01 f0       	breq	.+0      	; 0x50 <H_PB_void_read+0x50>
  50:	00 c0       	rjmp	.+0      	; 0x52 <H_PB_void_read+0x52>
  52:	80 e0       	ldi	r24, 0x00	; 0
  54:	90 e0       	ldi	r25, 0x00	; 0
  56:	a8 e4       	ldi	r26, 0x48	; 72
  58:	b3 e4       	ldi	r27, 0x43	; 67
  5a:	89 8f       	std	Y+25, r24	; 0x19
  5c:	9a 8f       	std	Y+26, r25	; 0x1a
  5e:	ab 8f       	std	Y+27, r26	; 0x1b
  60:	bc 8f       	std	Y+28, r27	; 0x1c
  62:	69 8d       	ldd	r22, Y+25	; 0x19
  64:	7a 8d       	ldd	r23, Y+26	; 0x1a
  66:	8b 8d       	ldd	r24, Y+27	; 0x1b
  68:	9c 8d       	ldd	r25, Y+28	; 0x1c
  6a:	20 e0       	ldi	r18, 0x00	; 0
  6c:	30 e0       	ldi	r19, 0x00	; 0
  6e:	4a e7       	ldi	r20, 0x7A	; 122
  70:	55 e4       	ldi	r21, 0x45	; 69
  72:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
  76:	dc 01       	movw	r26, r24
  78:	cb 01       	movw	r24, r22
  7a:	8d 8b       	std	Y+21, r24	; 0x15
  7c:	9e 8b       	std	Y+22, r25	; 0x16
  7e:	af 8b       	std	Y+23, r26	; 0x17
  80:	b8 8f       	std	Y+24, r27	; 0x18
  82:	6d 89       	ldd	r22, Y+21	; 0x15
  84:	7e 89       	ldd	r23, Y+22	; 0x16
  86:	8f 89       	ldd	r24, Y+23	; 0x17
  88:	98 8d       	ldd	r25, Y+24	; 0x18
  8a:	20 e0       	ldi	r18, 0x00	; 0
  8c:	30 e0       	ldi	r19, 0x00	; 0
  8e:	40 e8       	ldi	r20, 0x80	; 128
  90:	5f e3       	ldi	r21, 0x3F	; 63
  92:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
  96:	88 23       	and	r24, r24
  98:	04 f4       	brge	.+0      	; 0x9a <H_PB_void_read+0x9a>
  9a:	81 e0       	ldi	r24, 0x01	; 1
  9c:	90 e0       	ldi	r25, 0x00	; 0
  9e:	9c 8b       	std	Y+20, r25	; 0x14
  a0:	8b 8b       	std	Y+19, r24	; 0x13
  a2:	00 c0       	rjmp	.+0      	; 0xa4 <H_PB_void_read+0xa4>
  a4:	6d 89       	ldd	r22, Y+21	; 0x15
  a6:	7e 89       	ldd	r23, Y+22	; 0x16
  a8:	8f 89       	ldd	r24, Y+23	; 0x17
  aa:	98 8d       	ldd	r25, Y+24	; 0x18
  ac:	20 e0       	ldi	r18, 0x00	; 0
  ae:	3f ef       	ldi	r19, 0xFF	; 255
  b0:	4f e7       	ldi	r20, 0x7F	; 127
  b2:	57 e4       	ldi	r21, 0x47	; 71
  b4:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
  b8:	18 16       	cp	r1, r24
  ba:	04 f4       	brge	.+0      	; 0xbc <H_PB_void_read+0xbc>
  bc:	69 8d       	ldd	r22, Y+25	; 0x19
  be:	7a 8d       	ldd	r23, Y+26	; 0x1a
  c0:	8b 8d       	ldd	r24, Y+27	; 0x1b
  c2:	9c 8d       	ldd	r25, Y+28	; 0x1c
  c4:	20 e0       	ldi	r18, 0x00	; 0
  c6:	30 e0       	ldi	r19, 0x00	; 0
  c8:	40 e2       	ldi	r20, 0x20	; 32
  ca:	51 e4       	ldi	r21, 0x41	; 65
  cc:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
  d0:	dc 01       	movw	r26, r24
  d2:	cb 01       	movw	r24, r22
  d4:	bc 01       	movw	r22, r24
  d6:	cd 01       	movw	r24, r26
  d8:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
  dc:	dc 01       	movw	r26, r24
  de:	cb 01       	movw	r24, r22
  e0:	9c 8b       	std	Y+20, r25	; 0x14
  e2:	8b 8b       	std	Y+19, r24	; 0x13
  e4:	00 c0       	rjmp	.+0      	; 0xe6 <H_PB_void_read+0xe6>
  e6:	80 e9       	ldi	r24, 0x90	; 144
  e8:	91 e0       	ldi	r25, 0x01	; 1
  ea:	9a 8b       	std	Y+18, r25	; 0x12
  ec:	89 8b       	std	Y+17, r24	; 0x11
  ee:	89 89       	ldd	r24, Y+17	; 0x11
  f0:	9a 89       	ldd	r25, Y+18	; 0x12
  f2:	01 97       	sbiw	r24, 0x01	; 1
  f4:	01 f4       	brne	.+0      	; 0xf6 <H_PB_void_read+0xf6>
  f6:	9a 8b       	std	Y+18, r25	; 0x12
  f8:	89 8b       	std	Y+17, r24	; 0x11
  fa:	8b 89       	ldd	r24, Y+19	; 0x13
  fc:	9c 89       	ldd	r25, Y+20	; 0x14
  fe:	01 97       	sbiw	r24, 0x01	; 1
 100:	9c 8b       	std	Y+20, r25	; 0x14
 102:	8b 8b       	std	Y+19, r24	; 0x13
 104:	8b 89       	ldd	r24, Y+19	; 0x13
 106:	9c 89       	ldd	r25, Y+20	; 0x14
 108:	00 97       	sbiw	r24, 0x00	; 0
 10a:	01 f4       	brne	.+0      	; 0x10c <H_PB_void_read+0x10c>
 10c:	00 c0       	rjmp	.+0      	; 0x10e <H_PB_void_read+0x10e>
 10e:	6d 89       	ldd	r22, Y+21	; 0x15
 110:	7e 89       	ldd	r23, Y+22	; 0x16
 112:	8f 89       	ldd	r24, Y+23	; 0x17
 114:	98 8d       	ldd	r25, Y+24	; 0x18
 116:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 11a:	dc 01       	movw	r26, r24
 11c:	cb 01       	movw	r24, r22
 11e:	9c 8b       	std	Y+20, r25	; 0x14
 120:	8b 8b       	std	Y+19, r24	; 0x13
 122:	8b 89       	ldd	r24, Y+19	; 0x13
 124:	9c 89       	ldd	r25, Y+20	; 0x14
 126:	98 8b       	std	Y+16, r25	; 0x10
 128:	8f 87       	std	Y+15, r24	; 0x0f
 12a:	8f 85       	ldd	r24, Y+15	; 0x0f
 12c:	98 89       	ldd	r25, Y+16	; 0x10
 12e:	01 97       	sbiw	r24, 0x01	; 1
 130:	01 f4       	brne	.+0      	; 0x132 <H_PB_void_read+0x132>
 132:	98 8b       	std	Y+16, r25	; 0x10
 134:	8f 87       	std	Y+15, r24	; 0x0f
 136:	ee 8d       	ldd	r30, Y+30	; 0x1e
 138:	ff 8d       	ldd	r31, Y+31	; 0x1f
 13a:	81 81       	ldd	r24, Z+1	; 0x01
 13c:	ee 8d       	ldd	r30, Y+30	; 0x1e
 13e:	ff 8d       	ldd	r31, Y+31	; 0x1f
 140:	92 81       	ldd	r25, Z+2	; 0x02
 142:	9e 01       	movw	r18, r28
 144:	23 5e       	subi	r18, 0xE3	; 227
 146:	3f 4f       	sbci	r19, 0xFF	; 255
 148:	69 2f       	mov	r22, r25
 14a:	a9 01       	movw	r20, r18
 14c:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 150:	8d 8d       	ldd	r24, Y+29	; 0x1d
 152:	88 23       	and	r24, r24
 154:	01 f0       	breq	.+0      	; 0x156 <H_PB_void_read+0x156>
 156:	00 c0       	rjmp	.+0      	; 0x158 <H_PB_void_read+0x158>
 158:	00 c0       	rjmp	.+0      	; 0x15a <H_PB_void_read+0x15a>
 15a:	ee 8d       	ldd	r30, Y+30	; 0x1e
 15c:	ff 8d       	ldd	r31, Y+31	; 0x1f
 15e:	81 81       	ldd	r24, Z+1	; 0x01
 160:	ee 8d       	ldd	r30, Y+30	; 0x1e
 162:	ff 8d       	ldd	r31, Y+31	; 0x1f
 164:	92 81       	ldd	r25, Z+2	; 0x02
 166:	9e 01       	movw	r18, r28
 168:	23 5e       	subi	r18, 0xE3	; 227
 16a:	3f 4f       	sbci	r19, 0xFF	; 255
 16c:	69 2f       	mov	r22, r25
 16e:	a9 01       	movw	r20, r18
 170:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 174:	8d 8d       	ldd	r24, Y+29	; 0x1d
 176:	88 23       	and	r24, r24
 178:	01 f0       	breq	.+0      	; 0x17a <H_PB_void_read+0x17a>
 17a:	e8 a1       	ldd	r30, Y+32	; 0x20
 17c:	f9 a1       	ldd	r31, Y+33	; 0x21
 17e:	10 82       	st	Z, r1
 180:	00 c0       	rjmp	.+0      	; 0x182 <H_PB_void_read+0x182>
 182:	ee 8d       	ldd	r30, Y+30	; 0x1e
 184:	ff 8d       	ldd	r31, Y+31	; 0x1f
 186:	83 81       	ldd	r24, Z+3	; 0x03
 188:	81 30       	cpi	r24, 0x01	; 1
 18a:	01 f0       	breq	.+0      	; 0x18c <H_PB_void_read+0x18c>
 18c:	00 c0       	rjmp	.+0      	; 0x18e <H_PB_void_read+0x18e>
 18e:	e8 a1       	ldd	r30, Y+32	; 0x20
 190:	f9 a1       	ldd	r31, Y+33	; 0x21
 192:	10 82       	st	Z, r1
 194:	ee 8d       	ldd	r30, Y+30	; 0x1e
 196:	ff 8d       	ldd	r31, Y+31	; 0x1f
 198:	81 81       	ldd	r24, Z+1	; 0x01
 19a:	ee 8d       	ldd	r30, Y+30	; 0x1e
 19c:	ff 8d       	ldd	r31, Y+31	; 0x1f
 19e:	92 81       	ldd	r25, Z+2	; 0x02
 1a0:	9e 01       	movw	r18, r28
 1a2:	23 5e       	subi	r18, 0xE3	; 227
 1a4:	3f 4f       	sbci	r19, 0xFF	; 255
 1a6:	69 2f       	mov	r22, r25
 1a8:	a9 01       	movw	r20, r18
 1aa:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 1ae:	8d 8d       	ldd	r24, Y+29	; 0x1d
 1b0:	81 30       	cpi	r24, 0x01	; 1
 1b2:	01 f0       	breq	.+0      	; 0x1b4 <H_PB_void_read+0x1b4>
 1b4:	00 c0       	rjmp	.+0      	; 0x1b6 <H_PB_void_read+0x1b6>
 1b6:	80 e0       	ldi	r24, 0x00	; 0
 1b8:	90 e0       	ldi	r25, 0x00	; 0
 1ba:	a8 e4       	ldi	r26, 0x48	; 72
 1bc:	b3 e4       	ldi	r27, 0x43	; 67
 1be:	8b 87       	std	Y+11, r24	; 0x0b
 1c0:	9c 87       	std	Y+12, r25	; 0x0c
 1c2:	ad 87       	std	Y+13, r26	; 0x0d
 1c4:	be 87       	std	Y+14, r27	; 0x0e
 1c6:	6b 85       	ldd	r22, Y+11	; 0x0b
 1c8:	7c 85       	ldd	r23, Y+12	; 0x0c
 1ca:	8d 85       	ldd	r24, Y+13	; 0x0d
 1cc:	9e 85       	ldd	r25, Y+14	; 0x0e
 1ce:	20 e0       	ldi	r18, 0x00	; 0
 1d0:	30 e0       	ldi	r19, 0x00	; 0
 1d2:	4a e7       	ldi	r20, 0x7A	; 122
 1d4:	55 e4       	ldi	r21, 0x45	; 69
 1d6:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 1da:	dc 01       	movw	r26, r24
 1dc:	cb 01       	movw	r24, r22
 1de:	8f 83       	std	Y+7, r24	; 0x07
 1e0:	98 87       	std	Y+8, r25	; 0x08
 1e2:	a9 87       	std	Y+9, r26	; 0x09
 1e4:	ba 87       	std	Y+10, r27	; 0x0a
 1e6:	6f 81       	ldd	r22, Y+7	; 0x07
 1e8:	78 85       	ldd	r23, Y+8	; 0x08
 1ea:	89 85       	ldd	r24, Y+9	; 0x09
 1ec:	9a 85       	ldd	r25, Y+10	; 0x0a
 1ee:	20 e0       	ldi	r18, 0x00	; 0
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	40 e8       	ldi	r20, 0x80	; 128
 1f4:	5f e3       	ldi	r21, 0x3F	; 63
 1f6:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 1fa:	88 23       	and	r24, r24
 1fc:	04 f4       	brge	.+0      	; 0x1fe <H_PB_void_read+0x1fe>
 1fe:	81 e0       	ldi	r24, 0x01	; 1
 200:	90 e0       	ldi	r25, 0x00	; 0
 202:	9e 83       	std	Y+6, r25	; 0x06
 204:	8d 83       	std	Y+5, r24	; 0x05
 206:	00 c0       	rjmp	.+0      	; 0x208 <H_PB_void_read+0x208>
 208:	6f 81       	ldd	r22, Y+7	; 0x07
 20a:	78 85       	ldd	r23, Y+8	; 0x08
 20c:	89 85       	ldd	r24, Y+9	; 0x09
 20e:	9a 85       	ldd	r25, Y+10	; 0x0a
 210:	20 e0       	ldi	r18, 0x00	; 0
 212:	3f ef       	ldi	r19, 0xFF	; 255
 214:	4f e7       	ldi	r20, 0x7F	; 127
 216:	57 e4       	ldi	r21, 0x47	; 71
 218:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 21c:	18 16       	cp	r1, r24
 21e:	04 f4       	brge	.+0      	; 0x220 <H_PB_void_read+0x220>
 220:	6b 85       	ldd	r22, Y+11	; 0x0b
 222:	7c 85       	ldd	r23, Y+12	; 0x0c
 224:	8d 85       	ldd	r24, Y+13	; 0x0d
 226:	9e 85       	ldd	r25, Y+14	; 0x0e
 228:	20 e0       	ldi	r18, 0x00	; 0
 22a:	30 e0       	ldi	r19, 0x00	; 0
 22c:	40 e2       	ldi	r20, 0x20	; 32
 22e:	51 e4       	ldi	r21, 0x41	; 65
 230:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 234:	dc 01       	movw	r26, r24
 236:	cb 01       	movw	r24, r22
 238:	bc 01       	movw	r22, r24
 23a:	cd 01       	movw	r24, r26
 23c:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 240:	dc 01       	movw	r26, r24
 242:	cb 01       	movw	r24, r22
 244:	9e 83       	std	Y+6, r25	; 0x06
 246:	8d 83       	std	Y+5, r24	; 0x05
 248:	00 c0       	rjmp	.+0      	; 0x24a <H_PB_void_read+0x24a>
 24a:	80 e9       	ldi	r24, 0x90	; 144
 24c:	91 e0       	ldi	r25, 0x01	; 1
 24e:	9c 83       	std	Y+4, r25	; 0x04
 250:	8b 83       	std	Y+3, r24	; 0x03
 252:	8b 81       	ldd	r24, Y+3	; 0x03
 254:	9c 81       	ldd	r25, Y+4	; 0x04
 256:	01 97       	sbiw	r24, 0x01	; 1
 258:	01 f4       	brne	.+0      	; 0x25a <H_PB_void_read+0x25a>
 25a:	9c 83       	std	Y+4, r25	; 0x04
 25c:	8b 83       	std	Y+3, r24	; 0x03
 25e:	8d 81       	ldd	r24, Y+5	; 0x05
 260:	9e 81       	ldd	r25, Y+6	; 0x06
 262:	01 97       	sbiw	r24, 0x01	; 1
 264:	9e 83       	std	Y+6, r25	; 0x06
 266:	8d 83       	std	Y+5, r24	; 0x05
 268:	8d 81       	ldd	r24, Y+5	; 0x05
 26a:	9e 81       	ldd	r25, Y+6	; 0x06
 26c:	00 97       	sbiw	r24, 0x00	; 0
 26e:	01 f4       	brne	.+0      	; 0x270 <H_PB_void_read+0x270>
 270:	00 c0       	rjmp	.+0      	; 0x272 <H_PB_void_read+0x272>
 272:	6f 81       	ldd	r22, Y+7	; 0x07
 274:	78 85       	ldd	r23, Y+8	; 0x08
 276:	89 85       	ldd	r24, Y+9	; 0x09
 278:	9a 85       	ldd	r25, Y+10	; 0x0a
 27a:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 27e:	dc 01       	movw	r26, r24
 280:	cb 01       	movw	r24, r22
 282:	9e 83       	std	Y+6, r25	; 0x06
 284:	8d 83       	std	Y+5, r24	; 0x05
 286:	8d 81       	ldd	r24, Y+5	; 0x05
 288:	9e 81       	ldd	r25, Y+6	; 0x06
 28a:	9a 83       	std	Y+2, r25	; 0x02
 28c:	89 83       	std	Y+1, r24	; 0x01
 28e:	89 81       	ldd	r24, Y+1	; 0x01
 290:	9a 81       	ldd	r25, Y+2	; 0x02
 292:	01 97       	sbiw	r24, 0x01	; 1
 294:	01 f4       	brne	.+0      	; 0x296 <H_PB_void_read+0x296>
 296:	9a 83       	std	Y+2, r25	; 0x02
 298:	89 83       	std	Y+1, r24	; 0x01
 29a:	ee 8d       	ldd	r30, Y+30	; 0x1e
 29c:	ff 8d       	ldd	r31, Y+31	; 0x1f
 29e:	81 81       	ldd	r24, Z+1	; 0x01
 2a0:	ee 8d       	ldd	r30, Y+30	; 0x1e
 2a2:	ff 8d       	ldd	r31, Y+31	; 0x1f
 2a4:	92 81       	ldd	r25, Z+2	; 0x02
 2a6:	9e 01       	movw	r18, r28
 2a8:	23 5e       	subi	r18, 0xE3	; 227
 2aa:	3f 4f       	sbci	r19, 0xFF	; 255
 2ac:	69 2f       	mov	r22, r25
 2ae:	a9 01       	movw	r20, r18
 2b0:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 2b4:	8d 8d       	ldd	r24, Y+29	; 0x1d
 2b6:	81 30       	cpi	r24, 0x01	; 1
 2b8:	01 f4       	brne	.+0      	; 0x2ba <H_PB_void_read+0x2ba>
 2ba:	00 c0       	rjmp	.+0      	; 0x2bc <H_PB_void_read+0x2bc>
 2bc:	ee 8d       	ldd	r30, Y+30	; 0x1e
 2be:	ff 8d       	ldd	r31, Y+31	; 0x1f
 2c0:	81 81       	ldd	r24, Z+1	; 0x01
 2c2:	ee 8d       	ldd	r30, Y+30	; 0x1e
 2c4:	ff 8d       	ldd	r31, Y+31	; 0x1f
 2c6:	92 81       	ldd	r25, Z+2	; 0x02
 2c8:	9e 01       	movw	r18, r28
 2ca:	23 5e       	subi	r18, 0xE3	; 227
 2cc:	3f 4f       	sbci	r19, 0xFF	; 255
 2ce:	69 2f       	mov	r22, r25
 2d0:	a9 01       	movw	r20, r18
 2d2:	0e 94 00 00 	call	0	; 0x0 <H_PB_void_read>
 2d6:	8d 8d       	ldd	r24, Y+29	; 0x1d
 2d8:	81 30       	cpi	r24, 0x01	; 1
 2da:	01 f0       	breq	.+0      	; 0x2dc <H_PB_void_read+0x2dc>
 2dc:	e8 a1       	ldd	r30, Y+32	; 0x20
 2de:	f9 a1       	ldd	r31, Y+33	; 0x21
 2e0:	81 e0       	ldi	r24, 0x01	; 1
 2e2:	80 83       	st	Z, r24
 2e4:	a1 96       	adiw	r28, 0x21	; 33
 2e6:	0f b6       	in	r0, 0x3f	; 63
 2e8:	f8 94       	cli
 2ea:	de bf       	out	0x3e, r29	; 62
 2ec:	0f be       	out	0x3f, r0	; 63
 2ee:	cd bf       	out	0x3d, r28	; 61
 2f0:	cf 91       	pop	r28
 2f2:	df 91       	pop	r29
 2f4:	08 95       	ret

LM35_PRG.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000004bc  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000944  00000000  00000000  000004f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.M_ADC_void_Init 0000008c  00000000  00000000  00000e34  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.M_ADC_void_adcRead 00000048  00000000  00000000  00000ec0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE

Disassembly of section .text.M_ADC_void_Init:

00000000 <M_ADC_void_Init>:
#include<avr/io.h>



void M_ADC_void_Init(prescaler_t copy_prescaler, vref_t copy_vref)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <M_ADC_void_Init+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	6a 83       	std	Y+2, r22	; 0x02
	//step1: configer prescaler
		//step1: apply mask
	ADCSRA_REG &= ADC_PRESCALER_MASK;
   e:	a6 e2       	ldi	r26, 0x26	; 38
  10:	b0 e0       	ldi	r27, 0x00	; 0
  12:	e6 e2       	ldi	r30, 0x26	; 38
  14:	f0 e0       	ldi	r31, 0x00	; 0
  16:	80 81       	ld	r24, Z
  18:	88 7f       	andi	r24, 0xF8	; 248
  1a:	8c 93       	st	X, r24
		//step2: insert value
	ADCSRA_REG |= copy_prescaler;
  1c:	a6 e2       	ldi	r26, 0x26	; 38
  1e:	b0 e0       	ldi	r27, 0x00	; 0
  20:	e6 e2       	ldi	r30, 0x26	; 38
  22:	f0 e0       	ldi	r31, 0x00	; 0
  24:	90 81       	ld	r25, Z
  26:	89 81       	ldd	r24, Y+1	; 0x01
  28:	89 2b       	or	r24, r25
  2a:	8c 93       	st	X, r24
	//step2: disable interrupt
	CLR_BIT(ADCSRA_REG,ADIE_BIT);
  2c:	a6 e2       	ldi	r26, 0x26	; 38
  2e:	b0 e0       	ldi	r27, 0x00	; 0
  30:	e6 e2       	ldi	r30, 0x26	; 38
  32:	f0 e0       	ldi	r31, 0x00	; 0
  34:	80 81       	ld	r24, Z
  36:	87 7f       	andi	r24, 0xF7	; 247
  38:	8c 93       	st	X, r24
	//step3: configer right adjust
	CLR_BIT(ADMUX_REG,ADLAR_BIT);
  3a:	a7 e2       	ldi	r26, 0x27	; 39
  3c:	b0 e0       	ldi	r27, 0x00	; 0
  3e:	e7 e2       	ldi	r30, 0x27	; 39
  40:	f0 e0       	ldi	r31, 0x00	; 0
  42:	80 81       	ld	r24, Z
  44:	8f 7d       	andi	r24, 0xDF	; 223
  46:	8c 93       	st	X, r24
	//step4: disable auto reg
	CLR_BIT(ADCSRA_REG, ADATE_BIT);
  48:	a6 e2       	ldi	r26, 0x26	; 38
  4a:	b0 e0       	ldi	r27, 0x00	; 0
  4c:	e6 e2       	ldi	r30, 0x26	; 38
  4e:	f0 e0       	ldi	r31, 0x00	; 0
  50:	80 81       	ld	r24, Z
  52:	8f 7d       	andi	r24, 0xDF	; 223
  54:	8c 93       	st	X, r24
	//step5: choose vref
		//step1: apply mask
	ADMUX_REG &=ADC_VREF_MASK;
  56:	a7 e2       	ldi	r26, 0x27	; 39
  58:	b0 e0       	ldi	r27, 0x00	; 0
  5a:	e7 e2       	ldi	r30, 0x27	; 39
  5c:	f0 e0       	ldi	r31, 0x00	; 0
  5e:	80 81       	ld	r24, Z
  60:	8f 73       	andi	r24, 0x3F	; 63
  62:	8c 93       	st	X, r24
		//step2: insert value
	ADMUX_REG =copy_vref <<ADC_VREF_SHIFT;
  64:	e7 e2       	ldi	r30, 0x27	; 39
  66:	f0 e0       	ldi	r31, 0x00	; 0
  68:	8a 81       	ldd	r24, Y+2	; 0x02
  6a:	82 95       	swap	r24
  6c:	88 0f       	add	r24, r24
  6e:	88 0f       	add	r24, r24
  70:	80 7c       	andi	r24, 0xC0	; 192
  72:	80 83       	st	Z, r24
	//step6: enable ADC
	SET_BIT(ADCSRA_REG,ADEN_BIT);
  74:	a6 e2       	ldi	r26, 0x26	; 38
  76:	b0 e0       	ldi	r27, 0x00	; 0
  78:	e6 e2       	ldi	r30, 0x26	; 38
  7a:	f0 e0       	ldi	r31, 0x00	; 0
  7c:	80 81       	ld	r24, Z
  7e:	80 68       	ori	r24, 0x80	; 128
  80:	8c 93       	st	X, r24
}
  82:	0f 90       	pop	r0
  84:	0f 90       	pop	r0
  86:	cf 91       	pop	r28
  88:	df 91       	pop	r29
  8a:	08 95       	ret

Disassembly of section .text.M_ADC_void_adcRead:

00000000 <M_ADC_void_adcRead>:
#include<avr/io.h>



void M_ADC_void_Init(prescaler_t copy_prescaler, vref_t copy_vref)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	a7 e2       	ldi	r26, 0x27	; 39
	//step1: configer prescaler
		//step1: apply mask
	ADCSRA_REG &= ADC_PRESCALER_MASK;
   e:	b0 e0       	ldi	r27, 0x00	; 0
  10:	e7 e2       	ldi	r30, 0x27	; 39
  12:	f0 e0       	ldi	r31, 0x00	; 0
  14:	80 81       	ld	r24, Z
  16:	80 7e       	andi	r24, 0xE0	; 224
  18:	8c 93       	st	X, r24
  1a:	a7 e2       	ldi	r26, 0x27	; 39
		//step2: insert value
	ADCSRA_REG |= copy_prescaler;
  1c:	b0 e0       	ldi	r27, 0x00	; 0
  1e:	e7 e2       	ldi	r30, 0x27	; 39
  20:	f0 e0       	ldi	r31, 0x00	; 0
  22:	90 81       	ld	r25, Z
  24:	89 81       	ldd	r24, Y+1	; 0x01
  26:	89 2b       	or	r24, r25
  28:	8c 93       	st	X, r24
  2a:	a6 e2       	ldi	r26, 0x26	; 38
	//step2: disable interrupt
	CLR_BIT(ADCSRA_REG,ADIE_BIT);
  2c:	b0 e0       	ldi	r27, 0x00	; 0
  2e:	e6 e2       	ldi	r30, 0x26	; 38
  30:	f0 e0       	ldi	r31, 0x00	; 0
  32:	80 81       	ld	r24, Z
  34:	80 64       	ori	r24, 0x40	; 64
  36:	8c 93       	st	X, r24
  38:	e4 e2       	ldi	r30, 0x24	; 36
	//step3: configer right adjust
	CLR_BIT(ADMUX_REG,ADLAR_BIT);
  3a:	f0 e0       	ldi	r31, 0x00	; 0
  3c:	80 81       	ld	r24, Z
  3e:	91 81       	ldd	r25, Z+1	; 0x01
  40:	0f 90       	pop	r0
  42:	cf 91       	pop	r28
  44:	df 91       	pop	r29
  46:	08 95       	ret

LED_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         000002dc  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000392  00000000  00000000  00000310  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.H_Led_void_ledInit 00000062  00000000  00000000  000006a2  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.H_Led_void_setON 00000062  00000000  00000000  00000704  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.H_Led_void_setOFF 00000062  00000000  00000000  00000766  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.H_Led_void_toggle 0000005c  00000000  00000000  000007c8  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.H_Led_void_ledInit:

00000000 <H_Led_void_ledInit>:
#include "LED_priv.h"
#include "LED_config.h"
#include "LED_int.h"

void H_Led_void_ledInit(u8 LedID)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <H_Led_void_ledInit+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
  switch(LedID)
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	91 05       	cpc	r25, r1
  20:	01 f0       	breq	.+0      	; 0x22 <H_Led_void_ledInit+0x22>
  22:	2a 81       	ldd	r18, Y+2	; 0x02
  24:	3b 81       	ldd	r19, Y+3	; 0x03
  26:	22 30       	cpi	r18, 0x02	; 2
  28:	31 05       	cpc	r19, r1
  2a:	01 f0       	breq	.+0      	; 0x2c <H_Led_void_ledInit+0x2c>
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	9b 81       	ldd	r25, Y+3	; 0x03
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f4       	brne	.+0      	; 0x34 <H_Led_void_ledInit+0x34>
  {
  case RED_LED :
	 M_Dio_void_setPinDir(LED_RED_PORT,LED_RED_PIN,OUPUT);
  34:	83 e0       	ldi	r24, 0x03	; 3
  36:	60 e0       	ldi	r22, 0x00	; 0
  38:	41 e0       	ldi	r20, 0x01	; 1
  3a:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_ledInit>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <H_Led_void_ledInit+0x40>
	  break;
  case GRN_LED:
	  M_Dio_void_setPinDir(LED_GRN_PORT,LED_GRN_PIN,OUPUT);
  40:	83 e0       	ldi	r24, 0x03	; 3
  42:	61 e0       	ldi	r22, 0x01	; 1
  44:	41 e0       	ldi	r20, 0x01	; 1
  46:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_ledInit>
  4a:	00 c0       	rjmp	.+0      	; 0x4c <H_Led_void_ledInit+0x4c>
	  break;
  case BLU_LED :
	  M_Dio_void_setPinDir(LED_BLU_PORT,LED_BLU_PIN,OUPUT);
  4c:	83 e0       	ldi	r24, 0x03	; 3
  4e:	62 e0       	ldi	r22, 0x02	; 2
  50:	41 e0       	ldi	r20, 0x01	; 1
  52:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_ledInit>
	  break;
  }
}
  56:	0f 90       	pop	r0
  58:	0f 90       	pop	r0
  5a:	0f 90       	pop	r0
  5c:	cf 91       	pop	r28
  5e:	df 91       	pop	r29
  60:	08 95       	ret

Disassembly of section .text.H_Led_void_setON:

00000000 <H_Led_void_setON>:
#include "LED_priv.h"
#include "LED_config.h"
#include "LED_int.h"

void H_Led_void_ledInit(u8 LedID)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <H_Led_void_setON+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
  switch(LedID)
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	91 05       	cpc	r25, r1
  20:	01 f0       	breq	.+0      	; 0x22 <H_Led_void_setON+0x22>
  22:	2a 81       	ldd	r18, Y+2	; 0x02
  24:	3b 81       	ldd	r19, Y+3	; 0x03
  26:	22 30       	cpi	r18, 0x02	; 2
  28:	31 05       	cpc	r19, r1
  2a:	01 f0       	breq	.+0      	; 0x2c <H_Led_void_setON+0x2c>
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	9b 81       	ldd	r25, Y+3	; 0x03
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f4       	brne	.+0      	; 0x34 <H_Led_void_setON+0x34>
  {
  case RED_LED :
	 M_Dio_void_setPinDir(LED_RED_PORT,LED_RED_PIN,OUPUT);
  34:	83 e0       	ldi	r24, 0x03	; 3
  36:	60 e0       	ldi	r22, 0x00	; 0
  38:	41 e0       	ldi	r20, 0x01	; 1
  3a:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_setON>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <H_Led_void_setON+0x40>
	  break;
  case GRN_LED:
	  M_Dio_void_setPinDir(LED_GRN_PORT,LED_GRN_PIN,OUPUT);
  40:	83 e0       	ldi	r24, 0x03	; 3
  42:	61 e0       	ldi	r22, 0x01	; 1
  44:	41 e0       	ldi	r20, 0x01	; 1
  46:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_setON>
  4a:	00 c0       	rjmp	.+0      	; 0x4c <H_Led_void_setON+0x4c>
	  break;
  case BLU_LED :
	  M_Dio_void_setPinDir(LED_BLU_PORT,LED_BLU_PIN,OUPUT);
  4c:	83 e0       	ldi	r24, 0x03	; 3
  4e:	62 e0       	ldi	r22, 0x02	; 2
  50:	41 e0       	ldi	r20, 0x01	; 1
  52:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_setON>
	  break;
  }
}
  56:	0f 90       	pop	r0
  58:	0f 90       	pop	r0
  5a:	0f 90       	pop	r0
  5c:	cf 91       	pop	r28
  5e:	df 91       	pop	r29
  60:	08 95       	ret

Disassembly of section .text.H_Led_void_setOFF:

00000000 <H_Led_void_setOFF>:
#include "LED_priv.h"
#include "LED_config.h"
#include "LED_int.h"

void H_Led_void_ledInit(u8 LedID)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <H_Led_void_setOFF+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
  switch(LedID)
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	91 05       	cpc	r25, r1
  20:	01 f0       	breq	.+0      	; 0x22 <H_Led_void_setOFF+0x22>
  22:	2a 81       	ldd	r18, Y+2	; 0x02
  24:	3b 81       	ldd	r19, Y+3	; 0x03
  26:	22 30       	cpi	r18, 0x02	; 2
  28:	31 05       	cpc	r19, r1
  2a:	01 f0       	breq	.+0      	; 0x2c <H_Led_void_setOFF+0x2c>
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	9b 81       	ldd	r25, Y+3	; 0x03
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f4       	brne	.+0      	; 0x34 <H_Led_void_setOFF+0x34>
  {
  case RED_LED :
	 M_Dio_void_setPinDir(LED_RED_PORT,LED_RED_PIN,OUPUT);
  34:	83 e0       	ldi	r24, 0x03	; 3
  36:	60 e0       	ldi	r22, 0x00	; 0
  38:	40 e0       	ldi	r20, 0x00	; 0
  3a:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_setOFF>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <H_Led_void_setOFF+0x40>
	  break;
  case GRN_LED:
	  M_Dio_void_setPinDir(LED_GRN_PORT,LED_GRN_PIN,OUPUT);
  40:	83 e0       	ldi	r24, 0x03	; 3
  42:	61 e0       	ldi	r22, 0x01	; 1
  44:	40 e0       	ldi	r20, 0x00	; 0
  46:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_setOFF>
  4a:	00 c0       	rjmp	.+0      	; 0x4c <H_Led_void_setOFF+0x4c>
	  break;
  case BLU_LED :
	  M_Dio_void_setPinDir(LED_BLU_PORT,LED_BLU_PIN,OUPUT);
  4c:	83 e0       	ldi	r24, 0x03	; 3
  4e:	62 e0       	ldi	r22, 0x02	; 2
  50:	40 e0       	ldi	r20, 0x00	; 0
  52:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_setOFF>
	  break;
  }
}
  56:	0f 90       	pop	r0
  58:	0f 90       	pop	r0
  5a:	0f 90       	pop	r0
  5c:	cf 91       	pop	r28
  5e:	df 91       	pop	r29
  60:	08 95       	ret

Disassembly of section .text.H_Led_void_toggle:

00000000 <H_Led_void_toggle>:
#include "LED_priv.h"
#include "LED_config.h"
#include "LED_int.h"

void H_Led_void_ledInit(u8 LedID)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <H_Led_void_toggle+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
  switch(LedID)
   e:	89 81       	ldd	r24, Y+1	; 0x01
  10:	28 2f       	mov	r18, r24
  12:	30 e0       	ldi	r19, 0x00	; 0
  14:	3b 83       	std	Y+3, r19	; 0x03
  16:	2a 83       	std	Y+2, r18	; 0x02
  18:	8a 81       	ldd	r24, Y+2	; 0x02
  1a:	9b 81       	ldd	r25, Y+3	; 0x03
  1c:	81 30       	cpi	r24, 0x01	; 1
  1e:	91 05       	cpc	r25, r1
  20:	01 f0       	breq	.+0      	; 0x22 <H_Led_void_toggle+0x22>
  22:	2a 81       	ldd	r18, Y+2	; 0x02
  24:	3b 81       	ldd	r19, Y+3	; 0x03
  26:	22 30       	cpi	r18, 0x02	; 2
  28:	31 05       	cpc	r19, r1
  2a:	01 f0       	breq	.+0      	; 0x2c <H_Led_void_toggle+0x2c>
  2c:	8a 81       	ldd	r24, Y+2	; 0x02
  2e:	9b 81       	ldd	r25, Y+3	; 0x03
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f4       	brne	.+0      	; 0x34 <H_Led_void_toggle+0x34>
  {
  case RED_LED :
	 M_Dio_void_setPinDir(LED_RED_PORT,LED_RED_PIN,OUPUT);
  34:	83 e0       	ldi	r24, 0x03	; 3
  36:	60 e0       	ldi	r22, 0x00	; 0
  38:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_toggle>
  3c:	00 c0       	rjmp	.+0      	; 0x3e <H_Led_void_toggle+0x3e>
  3e:	83 e0       	ldi	r24, 0x03	; 3
	  break;
  case GRN_LED:
	  M_Dio_void_setPinDir(LED_GRN_PORT,LED_GRN_PIN,OUPUT);
  40:	61 e0       	ldi	r22, 0x01	; 1
  42:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_toggle>
  46:	00 c0       	rjmp	.+0      	; 0x48 <H_Led_void_toggle+0x48>
  48:	83 e0       	ldi	r24, 0x03	; 3
  4a:	62 e0       	ldi	r22, 0x02	; 2
	  break;
  case BLU_LED :
	  M_Dio_void_setPinDir(LED_BLU_PORT,LED_BLU_PIN,OUPUT);
  4c:	0e 94 00 00 	call	0	; 0x0 <H_Led_void_toggle>
  50:	0f 90       	pop	r0
  52:	0f 90       	pop	r0
  54:	0f 90       	pop	r0
	  break;
  }
}
  56:	cf 91       	pop	r28
  58:	df 91       	pop	r29
  5a:	08 95       	ret

LCD_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000ce4  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      0000103f  00000000  00000000  00000d18  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.H_LCD_void_Init 00000376  00000000  00000000  00001d57  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.H_LCD_void_sendData 00000024  00000000  00000000  000020cd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.H_LCD_void_sendCommand 00000024  00000000  00000000  000020f1  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.H_LCD_void_sendString 00000038  00000000  00000000  00002115  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  9 .text.H_LCD_void_clear 00000014  00000000  00000000  0000214d  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.H_LCD_void_sendIntNum 00000132  00000000  00000000  00002161  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 11 .text.H_LCD_void_gotXY 00000060  00000000  00000000  00002293  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 12 .text.H_LCD_void_creatCustomChar 0000001e  00000000  00000000  000022f3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 13 .text.H_LCD_void_displayCustomChar 00000014  00000000  00000000  00002311  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 14 .text.H_LCD_void_writeNlatch 0000048c  00000000  00000000  00002325  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.H_LCD_void_Init:

00000000 <H_LCD_void_Init>:
void H_LCD_void_displayCustomChar(u8 copy_u8charCode)
{

}
static void H_LCD_void_writeNlatch(u8 copy_u8Byte)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	aa 97       	sbiw	r28, 0x2a	; 42
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	81 e0       	ldi	r24, 0x01	; 1
 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
  // step 5 : delay to allow LCD to process
 	_delay_ms(5);
#elif(LCD_MODE ==  LCD_4BIT_MODE_)
 	// EN = 0 disabled
 	M_Dio_void_setPinValue(LCD_EN_PORT,LCD_EN_PIN,LOW);
  16:	61 e0       	ldi	r22, 0x01	; 1
  18:	41 e0       	ldi	r20, 0x01	; 1
  1a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  1e:	81 e0       	ldi	r24, 0x01	; 1
 	// devide Byte to 2 (4 bits )
 	// step 1 :send high order bits on pins (D7 .. D4)
 	M_Dio_void_setPinValue(LCD_D4_PORT ,LCD_D4_PIN  , GET_BIT(copy_u8Byte,4));
  20:	62 e0       	ldi	r22, 0x02	; 2
  22:	41 e0       	ldi	r20, 0x01	; 1
  24:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  28:	81 e0       	ldi	r24, 0x01	; 1
  2a:	66 e0       	ldi	r22, 0x06	; 6
  2c:	41 e0       	ldi	r20, 0x01	; 1
  2e:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  32:	81 e0       	ldi	r24, 0x01	; 1
 	M_Dio_void_setPinValue(LCD_D5_PORT ,LCD_D5_PIN  , GET_BIT(copy_u8Byte,5));
  34:	65 e0       	ldi	r22, 0x05	; 5
  36:	41 e0       	ldi	r20, 0x01	; 1
  38:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  3c:	81 e0       	ldi	r24, 0x01	; 1
  3e:	64 e0       	ldi	r22, 0x04	; 4
  40:	41 e0       	ldi	r20, 0x01	; 1
  42:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  46:	81 e0       	ldi	r24, 0x01	; 1
  48:	63 e0       	ldi	r22, 0x03	; 3
 	M_Dio_void_setPinValue(LCD_D6_PORT ,LCD_D6_PIN  , GET_BIT(copy_u8Byte,6));
  4a:	41 e0       	ldi	r20, 0x01	; 1
  4c:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  50:	80 e0       	ldi	r24, 0x00	; 0
  52:	90 e0       	ldi	r25, 0x00	; 0
  54:	ac e0       	ldi	r26, 0x0C	; 12
  56:	b2 e4       	ldi	r27, 0x42	; 66
  58:	8f a3       	std	Y+39, r24	; 0x27
  5a:	98 a7       	std	Y+40, r25	; 0x28
  5c:	a9 a7       	std	Y+41, r26	; 0x29
  5e:	ba a7       	std	Y+42, r27	; 0x2a
  60:	6f a1       	ldd	r22, Y+39	; 0x27
 	M_Dio_void_setPinValue(LCD_D7_PORT ,LCD_D7_PIN  , GET_BIT(copy_u8Byte,7));
  62:	78 a5       	ldd	r23, Y+40	; 0x28
  64:	89 a5       	ldd	r24, Y+41	; 0x29
  66:	9a a5       	ldd	r25, Y+42	; 0x2a
  68:	20 e0       	ldi	r18, 0x00	; 0
  6a:	30 e0       	ldi	r19, 0x00	; 0
  6c:	4a e7       	ldi	r20, 0x7A	; 122
  6e:	55 e4       	ldi	r21, 0x45	; 69
  70:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  74:	dc 01       	movw	r26, r24
 	  //step 2 : Activate Enable ,( E = 1)
 	 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,HIGH);
  76:	cb 01       	movw	r24, r22
  78:	8b a3       	std	Y+35, r24	; 0x23
  7a:	9c a3       	std	Y+36, r25	; 0x24
  7c:	ad a3       	std	Y+37, r26	; 0x25
  7e:	be a3       	std	Y+38, r27	; 0x26
  80:	6b a1       	ldd	r22, Y+35	; 0x23
  82:	7c a1       	ldd	r23, Y+36	; 0x24
  84:	8d a1       	ldd	r24, Y+37	; 0x25
  86:	9e a1       	ldd	r25, Y+38	; 0x26
  88:	20 e0       	ldi	r18, 0x00	; 0
  8a:	30 e0       	ldi	r19, 0x00	; 0
  8c:	40 e8       	ldi	r20, 0x80	; 128
  8e:	5f e3       	ldi	r21, 0x3F	; 63
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  90:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  94:	88 23       	and	r24, r24
  96:	04 f4       	brge	.+0      	; 0x98 <H_LCD_void_Init+0x98>
  98:	81 e0       	ldi	r24, 0x01	; 1
  9a:	90 e0       	ldi	r25, 0x00	; 0
  9c:	9a a3       	std	Y+34, r25	; 0x22
  9e:	89 a3       	std	Y+33, r24	; 0x21
  a0:	00 c0       	rjmp	.+0      	; 0xa2 <H_LCD_void_Init+0xa2>
  a2:	6b a1       	ldd	r22, Y+35	; 0x23
  a4:	7c a1       	ldd	r23, Y+36	; 0x24
  a6:	8d a1       	ldd	r24, Y+37	; 0x25
  a8:	9e a1       	ldd	r25, Y+38	; 0x26
  aa:	20 e0       	ldi	r18, 0x00	; 0
  ac:	3f ef       	ldi	r19, 0xFF	; 255
  ae:	4f e7       	ldi	r20, 0x7F	; 127
	if (__tmp < 1.0)
  b0:	57 e4       	ldi	r21, 0x47	; 71
  b2:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  b6:	18 16       	cp	r1, r24
  b8:	04 f4       	brge	.+0      	; 0xba <H_LCD_void_Init+0xba>
  ba:	6f a1       	ldd	r22, Y+39	; 0x27
  bc:	78 a5       	ldd	r23, Y+40	; 0x28
  be:	89 a5       	ldd	r24, Y+41	; 0x29
  c0:	9a a5       	ldd	r25, Y+42	; 0x2a
  c2:	20 e0       	ldi	r18, 0x00	; 0
  c4:	30 e0       	ldi	r19, 0x00	; 0
  c6:	40 e2       	ldi	r20, 0x20	; 32
		__ticks = 1;
  c8:	51 e4       	ldi	r21, 0x41	; 65
  ca:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  ce:	dc 01       	movw	r26, r24
  d0:	cb 01       	movw	r24, r22
	else if (__tmp > 65535)
  d2:	bc 01       	movw	r22, r24
  d4:	cd 01       	movw	r24, r26
  d6:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
  da:	dc 01       	movw	r26, r24
  dc:	cb 01       	movw	r24, r22
  de:	9a a3       	std	Y+34, r25	; 0x22
  e0:	89 a3       	std	Y+33, r24	; 0x21
  e2:	00 c0       	rjmp	.+0      	; 0xe4 <H_LCD_void_Init+0xe4>
  e4:	80 e9       	ldi	r24, 0x90	; 144
  e6:	91 e0       	ldi	r25, 0x01	; 1
  e8:	98 a3       	std	Y+32, r25	; 0x20
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  ea:	8f 8f       	std	Y+31, r24	; 0x1f
  ec:	8f 8d       	ldd	r24, Y+31	; 0x1f
  ee:	98 a1       	ldd	r25, Y+32	; 0x20
  f0:	01 97       	sbiw	r24, 0x01	; 1
  f2:	01 f4       	brne	.+0      	; 0xf4 <H_LCD_void_Init+0xf4>
  f4:	98 a3       	std	Y+32, r25	; 0x20
  f6:	8f 8f       	std	Y+31, r24	; 0x1f
  f8:	89 a1       	ldd	r24, Y+33	; 0x21
  fa:	9a a1       	ldd	r25, Y+34	; 0x22
  fc:	01 97       	sbiw	r24, 0x01	; 1
  fe:	9a a3       	std	Y+34, r25	; 0x22
 100:	89 a3       	std	Y+33, r24	; 0x21
 102:	89 a1       	ldd	r24, Y+33	; 0x21
 104:	9a a1       	ldd	r25, Y+34	; 0x22
 106:	00 97       	sbiw	r24, 0x00	; 0
 108:	01 f4       	brne	.+0      	; 0x10a <H_LCD_void_Init+0x10a>
 10a:	00 c0       	rjmp	.+0      	; 0x10c <H_LCD_void_Init+0x10c>
 10c:	6b a1       	ldd	r22, Y+35	; 0x23
 10e:	7c a1       	ldd	r23, Y+36	; 0x24
 110:	8d a1       	ldd	r24, Y+37	; 0x25
 112:	9e a1       	ldd	r25, Y+38	; 0x26
 114:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 118:	dc 01       	movw	r26, r24
 11a:	cb 01       	movw	r24, r22
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 11c:	9a a3       	std	Y+34, r25	; 0x22
 11e:	89 a3       	std	Y+33, r24	; 0x21
 120:	89 a1       	ldd	r24, Y+33	; 0x21
 122:	9a a1       	ldd	r25, Y+34	; 0x22
 124:	9e 8f       	std	Y+30, r25	; 0x1e
 126:	8d 8f       	std	Y+29, r24	; 0x1d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 128:	8d 8d       	ldd	r24, Y+29	; 0x1d
 12a:	9e 8d       	ldd	r25, Y+30	; 0x1e
 12c:	01 97       	sbiw	r24, 0x01	; 1
 12e:	01 f4       	brne	.+0      	; 0x130 <H_LCD_void_Init+0x130>
 130:	9e 8f       	std	Y+30, r25	; 0x1e
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 132:	8d 8f       	std	Y+29, r24	; 0x1d
 134:	81 e0       	ldi	r24, 0x01	; 1
 136:	61 e0       	ldi	r22, 0x01	; 1
 138:	40 e0       	ldi	r20, 0x00	; 0
 13a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 13e:	81 e0       	ldi	r24, 0x01	; 1
 140:	62 e0       	ldi	r22, 0x02	; 2
 142:	40 e0       	ldi	r20, 0x00	; 0
 144:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 148:	81 e0       	ldi	r24, 0x01	; 1
 14a:	66 e0       	ldi	r22, 0x06	; 6
 14c:	40 e0       	ldi	r20, 0x00	; 0
 14e:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 152:	81 e0       	ldi	r24, 0x01	; 1
 154:	65 e0       	ldi	r22, 0x05	; 5
 156:	40 e0       	ldi	r20, 0x00	; 0
 158:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 15c:	81 e0       	ldi	r24, 0x01	; 1
 15e:	64 e0       	ldi	r22, 0x04	; 4
 160:	41 e0       	ldi	r20, 0x01	; 1
 162:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 	  // step 3 : delay for 1 msec 	to allow latching
 	 	_delay_ms(1);
 	  // step 4 : deactivate Enable (E = 0)
 	 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
 166:	81 e0       	ldi	r24, 0x01	; 1
 168:	63 e0       	ldi	r22, 0x03	; 3
 16a:	40 e0       	ldi	r20, 0x00	; 0
 16c:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 170:	81 e0       	ldi	r24, 0x01	; 1
 172:	62 e0       	ldi	r22, 0x02	; 2
 174:	41 e0       	ldi	r20, 0x01	; 1
 176:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 17a:	80 e0       	ldi	r24, 0x00	; 0
 17c:	90 e0       	ldi	r25, 0x00	; 0
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 17e:	a0 e8       	ldi	r26, 0x80	; 128
 180:	bf e3       	ldi	r27, 0x3F	; 63
 182:	89 8f       	std	Y+25, r24	; 0x19
 184:	9a 8f       	std	Y+26, r25	; 0x1a
 186:	ab 8f       	std	Y+27, r26	; 0x1b
 188:	bc 8f       	std	Y+28, r27	; 0x1c
 18a:	69 8d       	ldd	r22, Y+25	; 0x19
 18c:	7a 8d       	ldd	r23, Y+26	; 0x1a
 18e:	8b 8d       	ldd	r24, Y+27	; 0x1b
 190:	9c 8d       	ldd	r25, Y+28	; 0x1c
 192:	20 e0       	ldi	r18, 0x00	; 0
 194:	30 e0       	ldi	r19, 0x00	; 0
 196:	4a e7       	ldi	r20, 0x7A	; 122
 198:	55 e4       	ldi	r21, 0x45	; 69
 19a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
	if (__tmp < 1.0)
 19e:	dc 01       	movw	r26, r24
 1a0:	cb 01       	movw	r24, r22
 1a2:	8d 8b       	std	Y+21, r24	; 0x15
 1a4:	9e 8b       	std	Y+22, r25	; 0x16
 1a6:	af 8b       	std	Y+23, r26	; 0x17
 1a8:	b8 8f       	std	Y+24, r27	; 0x18
 1aa:	6d 89       	ldd	r22, Y+21	; 0x15
 1ac:	7e 89       	ldd	r23, Y+22	; 0x16
 1ae:	8f 89       	ldd	r24, Y+23	; 0x17
 1b0:	98 8d       	ldd	r25, Y+24	; 0x18
 1b2:	20 e0       	ldi	r18, 0x00	; 0
 1b4:	30 e0       	ldi	r19, 0x00	; 0
		__ticks = 1;
 1b6:	40 e8       	ldi	r20, 0x80	; 128
 1b8:	5f e3       	ldi	r21, 0x3F	; 63
 1ba:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 1be:	88 23       	and	r24, r24
	else if (__tmp > 65535)
 1c0:	04 f4       	brge	.+0      	; 0x1c2 <H_LCD_void_Init+0x1c2>
 1c2:	81 e0       	ldi	r24, 0x01	; 1
 1c4:	90 e0       	ldi	r25, 0x00	; 0
 1c6:	9c 8b       	std	Y+20, r25	; 0x14
 1c8:	8b 8b       	std	Y+19, r24	; 0x13
 1ca:	00 c0       	rjmp	.+0      	; 0x1cc <H_LCD_void_Init+0x1cc>
 1cc:	6d 89       	ldd	r22, Y+21	; 0x15
 1ce:	7e 89       	ldd	r23, Y+22	; 0x16
 1d0:	8f 89       	ldd	r24, Y+23	; 0x17
 1d2:	98 8d       	ldd	r25, Y+24	; 0x18
 1d4:	20 e0       	ldi	r18, 0x00	; 0
 1d6:	3f ef       	ldi	r19, 0xFF	; 255
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 1d8:	4f e7       	ldi	r20, 0x7F	; 127
 1da:	57 e4       	ldi	r21, 0x47	; 71
 1dc:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 1e0:	18 16       	cp	r1, r24
 1e2:	04 f4       	brge	.+0      	; 0x1e4 <H_LCD_void_Init+0x1e4>
 1e4:	69 8d       	ldd	r22, Y+25	; 0x19
 1e6:	7a 8d       	ldd	r23, Y+26	; 0x1a
 1e8:	8b 8d       	ldd	r24, Y+27	; 0x1b
 1ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
 1ec:	20 e0       	ldi	r18, 0x00	; 0
 1ee:	30 e0       	ldi	r19, 0x00	; 0
 1f0:	40 e2       	ldi	r20, 0x20	; 32
 1f2:	51 e4       	ldi	r21, 0x41	; 65
 1f4:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 1f8:	dc 01       	movw	r26, r24
 1fa:	cb 01       	movw	r24, r22
 1fc:	bc 01       	movw	r22, r24
 1fe:	cd 01       	movw	r24, r26
 200:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 204:	dc 01       	movw	r26, r24
 206:	cb 01       	movw	r24, r22
 208:	9c 8b       	std	Y+20, r25	; 0x14
 20a:	8b 8b       	std	Y+19, r24	; 0x13
 20c:	00 c0       	rjmp	.+0      	; 0x20e <H_LCD_void_Init+0x20e>
 20e:	80 e9       	ldi	r24, 0x90	; 144
 210:	91 e0       	ldi	r25, 0x01	; 1
 212:	9a 8b       	std	Y+18, r25	; 0x12
 214:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 216:	89 89       	ldd	r24, Y+17	; 0x11
 218:	9a 89       	ldd	r25, Y+18	; 0x12
 21a:	01 97       	sbiw	r24, 0x01	; 1
 21c:	01 f4       	brne	.+0      	; 0x21e <H_LCD_void_Init+0x21e>
 21e:	9a 8b       	std	Y+18, r25	; 0x12
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 220:	89 8b       	std	Y+17, r24	; 0x11
 222:	8b 89       	ldd	r24, Y+19	; 0x13
 224:	9c 89       	ldd	r25, Y+20	; 0x14
 226:	01 97       	sbiw	r24, 0x01	; 1
 228:	9c 8b       	std	Y+20, r25	; 0x14
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 22a:	8b 8b       	std	Y+19, r24	; 0x13
 22c:	8b 89       	ldd	r24, Y+19	; 0x13
 22e:	9c 89       	ldd	r25, Y+20	; 0x14
 230:	00 97       	sbiw	r24, 0x00	; 0
 232:	01 f4       	brne	.+0      	; 0x234 <H_LCD_void_Init+0x234>
 234:	00 c0       	rjmp	.+0      	; 0x236 <H_LCD_void_Init+0x236>
 236:	6d 89       	ldd	r22, Y+21	; 0x15
 238:	7e 89       	ldd	r23, Y+22	; 0x16
 23a:	8f 89       	ldd	r24, Y+23	; 0x17
 23c:	98 8d       	ldd	r25, Y+24	; 0x18
 23e:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 242:	dc 01       	movw	r26, r24
 244:	cb 01       	movw	r24, r22
 246:	9c 8b       	std	Y+20, r25	; 0x14
 248:	8b 8b       	std	Y+19, r24	; 0x13
 24a:	8b 89       	ldd	r24, Y+19	; 0x13
 24c:	9c 89       	ldd	r25, Y+20	; 0x14
 24e:	98 8b       	std	Y+16, r25	; 0x10
 250:	8f 87       	std	Y+15, r24	; 0x0f
 	  // step 5 : delay to allow LCD to process
 	 	_delay_ms(5);
 	 	// step 6 :send Low order bits on pins (D7 .. D4)
 	 	M_Dio_void_setPinValue(LCD_D4_PORT ,LCD_D4_PIN  , GET_BIT(copy_u8Byte,0));
 252:	8f 85       	ldd	r24, Y+15	; 0x0f
 254:	98 89       	ldd	r25, Y+16	; 0x10
 256:	01 97       	sbiw	r24, 0x01	; 1
 258:	01 f4       	brne	.+0      	; 0x25a <H_LCD_void_Init+0x25a>
 25a:	98 8b       	std	Y+16, r25	; 0x10
 25c:	8f 87       	std	Y+15, r24	; 0x0f
 25e:	81 e0       	ldi	r24, 0x01	; 1
 260:	62 e0       	ldi	r22, 0x02	; 2
 	 	M_Dio_void_setPinValue(LCD_D5_PORT ,LCD_D5_PIN  , GET_BIT(copy_u8Byte,1));
 262:	40 e0       	ldi	r20, 0x00	; 0
 264:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 268:	80 e0       	ldi	r24, 0x00	; 0
 26a:	90 e0       	ldi	r25, 0x00	; 0
 26c:	a0 ea       	ldi	r26, 0xA0	; 160
 26e:	b0 e4       	ldi	r27, 0x40	; 64
 270:	8b 87       	std	Y+11, r24	; 0x0b
 272:	9c 87       	std	Y+12, r25	; 0x0c
 	 	M_Dio_void_setPinValue(LCD_D6_PORT ,LCD_D6_PIN  , GET_BIT(copy_u8Byte,2));
 274:	ad 87       	std	Y+13, r26	; 0x0d
 276:	be 87       	std	Y+14, r27	; 0x0e
 278:	6b 85       	ldd	r22, Y+11	; 0x0b
 27a:	7c 85       	ldd	r23, Y+12	; 0x0c
 27c:	8d 85       	ldd	r24, Y+13	; 0x0d
 27e:	9e 85       	ldd	r25, Y+14	; 0x0e
 280:	20 e0       	ldi	r18, 0x00	; 0
 282:	30 e0       	ldi	r19, 0x00	; 0
 284:	4a e7       	ldi	r20, 0x7A	; 122
 286:	55 e4       	ldi	r21, 0x45	; 69
 	 	M_Dio_void_setPinValue(LCD_D7_PORT ,LCD_D7_PIN  , GET_BIT(copy_u8Byte,3));
 288:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 28c:	dc 01       	movw	r26, r24
 28e:	cb 01       	movw	r24, r22
 290:	8f 83       	std	Y+7, r24	; 0x07
 292:	98 87       	std	Y+8, r25	; 0x08
 294:	a9 87       	std	Y+9, r26	; 0x09
 296:	ba 87       	std	Y+10, r27	; 0x0a
 298:	6f 81       	ldd	r22, Y+7	; 0x07
 29a:	78 85       	ldd	r23, Y+8	; 0x08
 29c:	89 85       	ldd	r24, Y+9	; 0x09
 	 	 //step 7 : Activate Enable ,( E = 1)
 	 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,HIGH);
 29e:	9a 85       	ldd	r25, Y+10	; 0x0a
 2a0:	20 e0       	ldi	r18, 0x00	; 0
 2a2:	30 e0       	ldi	r19, 0x00	; 0
 2a4:	40 e8       	ldi	r20, 0x80	; 128
 2a6:	5f e3       	ldi	r21, 0x3F	; 63
 2a8:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 2ac:	88 23       	and	r24, r24
 2ae:	04 f4       	brge	.+0      	; 0x2b0 <H_LCD_void_Init+0x2b0>
 2b0:	81 e0       	ldi	r24, 0x01	; 1
 2b2:	90 e0       	ldi	r25, 0x00	; 0
 2b4:	9e 83       	std	Y+6, r25	; 0x06
 2b6:	8d 83       	std	Y+5, r24	; 0x05
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 2b8:	00 c0       	rjmp	.+0      	; 0x2ba <H_LCD_void_Init+0x2ba>
 2ba:	6f 81       	ldd	r22, Y+7	; 0x07
 2bc:	78 85       	ldd	r23, Y+8	; 0x08
 2be:	89 85       	ldd	r24, Y+9	; 0x09
 2c0:	9a 85       	ldd	r25, Y+10	; 0x0a
 2c2:	20 e0       	ldi	r18, 0x00	; 0
 2c4:	3f ef       	ldi	r19, 0xFF	; 255
 2c6:	4f e7       	ldi	r20, 0x7F	; 127
 2c8:	57 e4       	ldi	r21, 0x47	; 71
 2ca:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 2ce:	18 16       	cp	r1, r24
 2d0:	04 f4       	brge	.+0      	; 0x2d2 <H_LCD_void_Init+0x2d2>
 2d2:	6b 85       	ldd	r22, Y+11	; 0x0b
 2d4:	7c 85       	ldd	r23, Y+12	; 0x0c
 2d6:	8d 85       	ldd	r24, Y+13	; 0x0d
	if (__tmp < 1.0)
 2d8:	9e 85       	ldd	r25, Y+14	; 0x0e
 2da:	20 e0       	ldi	r18, 0x00	; 0
 2dc:	30 e0       	ldi	r19, 0x00	; 0
 2de:	40 e2       	ldi	r20, 0x20	; 32
 2e0:	51 e4       	ldi	r21, 0x41	; 65
 2e2:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 2e6:	dc 01       	movw	r26, r24
 2e8:	cb 01       	movw	r24, r22
 2ea:	bc 01       	movw	r22, r24
 2ec:	cd 01       	movw	r24, r26
 2ee:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
		__ticks = 1;
 2f2:	dc 01       	movw	r26, r24
 2f4:	cb 01       	movw	r24, r22
 2f6:	9e 83       	std	Y+6, r25	; 0x06
 2f8:	8d 83       	std	Y+5, r24	; 0x05
	else if (__tmp > 65535)
 2fa:	00 c0       	rjmp	.+0      	; 0x2fc <H_LCD_void_Init+0x2fc>
 2fc:	80 e9       	ldi	r24, 0x90	; 144
 2fe:	91 e0       	ldi	r25, 0x01	; 1
 300:	9c 83       	std	Y+4, r25	; 0x04
 302:	8b 83       	std	Y+3, r24	; 0x03
 304:	8b 81       	ldd	r24, Y+3	; 0x03
 306:	9c 81       	ldd	r25, Y+4	; 0x04
 308:	01 97       	sbiw	r24, 0x01	; 1
 30a:	01 f4       	brne	.+0      	; 0x30c <H_LCD_void_Init+0x30c>
 30c:	9c 83       	std	Y+4, r25	; 0x04
 30e:	8b 83       	std	Y+3, r24	; 0x03
 310:	8d 81       	ldd	r24, Y+5	; 0x05
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 312:	9e 81       	ldd	r25, Y+6	; 0x06
 314:	01 97       	sbiw	r24, 0x01	; 1
 316:	9e 83       	std	Y+6, r25	; 0x06
 318:	8d 83       	std	Y+5, r24	; 0x05
 31a:	8d 81       	ldd	r24, Y+5	; 0x05
 31c:	9e 81       	ldd	r25, Y+6	; 0x06
 31e:	00 97       	sbiw	r24, 0x00	; 0
 320:	01 f4       	brne	.+0      	; 0x322 <H_LCD_void_Init+0x322>
 322:	00 c0       	rjmp	.+0      	; 0x324 <H_LCD_void_Init+0x324>
 324:	6f 81       	ldd	r22, Y+7	; 0x07
 326:	78 85       	ldd	r23, Y+8	; 0x08
 328:	89 85       	ldd	r24, Y+9	; 0x09
 32a:	9a 85       	ldd	r25, Y+10	; 0x0a
 32c:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 330:	dc 01       	movw	r26, r24
 332:	cb 01       	movw	r24, r22
 334:	9e 83       	std	Y+6, r25	; 0x06
 336:	8d 83       	std	Y+5, r24	; 0x05
 338:	8d 81       	ldd	r24, Y+5	; 0x05
 33a:	9e 81       	ldd	r25, Y+6	; 0x06
 33c:	9a 83       	std	Y+2, r25	; 0x02
 33e:	89 83       	std	Y+1, r24	; 0x01
 340:	89 81       	ldd	r24, Y+1	; 0x01
 342:	9a 81       	ldd	r25, Y+2	; 0x02
 344:	01 97       	sbiw	r24, 0x01	; 1
 346:	01 f4       	brne	.+0      	; 0x348 <H_LCD_void_Init+0x348>
 348:	9a 83       	std	Y+2, r25	; 0x02
 34a:	89 83       	std	Y+1, r24	; 0x01
 34c:	88 e2       	ldi	r24, 0x28	; 40
 34e:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 352:	8e e0       	ldi	r24, 0x0E	; 14
 354:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 358:	81 e0       	ldi	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 35a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
 35e:	86 e0       	ldi	r24, 0x06	; 6
 360:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_Init>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 364:	aa 96       	adiw	r28, 0x2a	; 42
 366:	0f b6       	in	r0, 0x3f	; 63
 368:	f8 94       	cli
 36a:	de bf       	out	0x3e, r29	; 62
 36c:	0f be       	out	0x3f, r0	; 63
 36e:	cd bf       	out	0x3d, r28	; 61
 370:	cf 91       	pop	r28
 372:	df 91       	pop	r29
 374:	08 95       	ret

Disassembly of section .text.H_LCD_void_sendData:

00000000 <H_LCD_void_sendData>:
void H_LCD_void_displayCustomChar(u8 copy_u8charCode)
{

}
static void H_LCD_void_writeNlatch(u8 copy_u8Byte)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	81 e0       	ldi	r24, 0x01	; 1
   e:	61 e0       	ldi	r22, 0x01	; 1
  10:	41 e0       	ldi	r20, 0x01	; 1
  12:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendData>
 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
  // step 5 : delay to allow LCD to process
 	_delay_ms(5);
#elif(LCD_MODE ==  LCD_4BIT_MODE_)
 	// EN = 0 disabled
 	M_Dio_void_setPinValue(LCD_EN_PORT,LCD_EN_PIN,LOW);
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendData>
  1c:	0f 90       	pop	r0
  1e:	cf 91       	pop	r28
 	// devide Byte to 2 (4 bits )
 	// step 1 :send high order bits on pins (D7 .. D4)
 	M_Dio_void_setPinValue(LCD_D4_PORT ,LCD_D4_PIN  , GET_BIT(copy_u8Byte,4));
  20:	df 91       	pop	r29
  22:	08 95       	ret

Disassembly of section .text.H_LCD_void_sendCommand:

00000000 <H_LCD_void_sendCommand>:
void H_LCD_void_displayCustomChar(u8 copy_u8charCode)
{

}
static void H_LCD_void_writeNlatch(u8 copy_u8Byte)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	81 e0       	ldi	r24, 0x01	; 1
   e:	61 e0       	ldi	r22, 0x01	; 1
  10:	40 e0       	ldi	r20, 0x00	; 0
  12:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendCommand>
 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
  // step 5 : delay to allow LCD to process
 	_delay_ms(5);
#elif(LCD_MODE ==  LCD_4BIT_MODE_)
 	// EN = 0 disabled
 	M_Dio_void_setPinValue(LCD_EN_PORT,LCD_EN_PIN,LOW);
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendCommand>
  1c:	0f 90       	pop	r0
  1e:	cf 91       	pop	r28
 	// devide Byte to 2 (4 bits )
 	// step 1 :send high order bits on pins (D7 .. D4)
 	M_Dio_void_setPinValue(LCD_D4_PORT ,LCD_D4_PIN  , GET_BIT(copy_u8Byte,4));
  20:	df 91       	pop	r29
  22:	08 95       	ret

Disassembly of section .text.H_LCD_void_sendString:

00000000 <H_LCD_void_sendString>:
void H_LCD_void_displayCustomChar(u8 copy_u8charCode)
{

}
static void H_LCD_void_writeNlatch(u8 copy_u8Byte)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <H_LCD_void_sendString+0x6>
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	9a 83       	std	Y+2, r25	; 0x02
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	00 c0       	rjmp	.+0      	; 0x10 <H_LCD_void_sendString+0x10>
  10:	e9 81       	ldd	r30, Y+1	; 0x01
  12:	fa 81       	ldd	r31, Y+2	; 0x02
  14:	80 81       	ld	r24, Z
 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
  // step 5 : delay to allow LCD to process
 	_delay_ms(5);
#elif(LCD_MODE ==  LCD_4BIT_MODE_)
 	// EN = 0 disabled
 	M_Dio_void_setPinValue(LCD_EN_PORT,LCD_EN_PIN,LOW);
  16:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendString>
  1a:	89 81       	ldd	r24, Y+1	; 0x01
  1c:	9a 81       	ldd	r25, Y+2	; 0x02
  1e:	01 96       	adiw	r24, 0x01	; 1
 	// devide Byte to 2 (4 bits )
 	// step 1 :send high order bits on pins (D7 .. D4)
 	M_Dio_void_setPinValue(LCD_D4_PORT ,LCD_D4_PIN  , GET_BIT(copy_u8Byte,4));
  20:	9a 83       	std	Y+2, r25	; 0x02
  22:	89 83       	std	Y+1, r24	; 0x01
  24:	e9 81       	ldd	r30, Y+1	; 0x01
  26:	fa 81       	ldd	r31, Y+2	; 0x02
  28:	80 81       	ld	r24, Z
  2a:	88 23       	and	r24, r24
  2c:	01 f4       	brne	.+0      	; 0x2e <H_LCD_void_sendString+0x2e>
  2e:	0f 90       	pop	r0
  30:	0f 90       	pop	r0
  32:	cf 91       	pop	r28
 	M_Dio_void_setPinValue(LCD_D5_PORT ,LCD_D5_PIN  , GET_BIT(copy_u8Byte,5));
  34:	df 91       	pop	r29
  36:	08 95       	ret

Disassembly of section .text.H_LCD_void_clear:

00000000 <H_LCD_void_clear>:
void H_LCD_void_displayCustomChar(u8 copy_u8charCode)
{

}
static void H_LCD_void_writeNlatch(u8 copy_u8Byte)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	81 e0       	ldi	r24, 0x01	; 1
   a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_clear>
   e:	cf 91       	pop	r28
  10:	df 91       	pop	r29
  12:	08 95       	ret

Disassembly of section .text.H_LCD_void_sendIntNum:

00000000 <H_LCD_void_sendIntNum>:
   0:	0f 93       	push	r16
   2:	1f 93       	push	r17
   4:	df 93       	push	r29
   6:	cf 93       	push	r28
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	2f 97       	sbiw	r28, 0x0f	; 15
   e:	0f b6       	in	r0, 0x3f	; 63
  10:	f8 94       	cli
  12:	de bf       	out	0x3e, r29	; 62
  14:	0f be       	out	0x3f, r0	; 63
 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
  // step 5 : delay to allow LCD to process
 	_delay_ms(5);
#elif(LCD_MODE ==  LCD_4BIT_MODE_)
 	// EN = 0 disabled
 	M_Dio_void_setPinValue(LCD_EN_PORT,LCD_EN_PIN,LOW);
  16:	cd bf       	out	0x3d, r28	; 61
  18:	6c 87       	std	Y+12, r22	; 0x0c
  1a:	7d 87       	std	Y+13, r23	; 0x0d
  1c:	8e 87       	std	Y+14, r24	; 0x0e
  1e:	9f 87       	std	Y+15, r25	; 0x0f
 	// devide Byte to 2 (4 bits )
 	// step 1 :send high order bits on pins (D7 .. D4)
 	M_Dio_void_setPinValue(LCD_D4_PORT ,LCD_D4_PIN  , GET_BIT(copy_u8Byte,4));
  20:	8a e0       	ldi	r24, 0x0A	; 10
  22:	fe 01       	movw	r30, r28
  24:	32 96       	adiw	r30, 0x02	; 2
  26:	df 01       	movw	r26, r30
  28:	98 2f       	mov	r25, r24
  2a:	1d 92       	st	X+, r1
  2c:	9a 95       	dec	r25
  2e:	01 f4       	brne	.+0      	; 0x30 <H_LCD_void_sendIntNum+0x30>
  30:	19 82       	std	Y+1, r1	; 0x01
  32:	8c 85       	ldd	r24, Y+12	; 0x0c
 	M_Dio_void_setPinValue(LCD_D5_PORT ,LCD_D5_PIN  , GET_BIT(copy_u8Byte,5));
  34:	9d 85       	ldd	r25, Y+13	; 0x0d
  36:	ae 85       	ldd	r26, Y+14	; 0x0e
  38:	bf 85       	ldd	r27, Y+15	; 0x0f
  3a:	00 97       	sbiw	r24, 0x00	; 0
  3c:	a1 05       	cpc	r26, r1
  3e:	b1 05       	cpc	r27, r1
  40:	01 f4       	brne	.+0      	; 0x42 <H_LCD_void_sendIntNum+0x42>
  42:	80 e3       	ldi	r24, 0x30	; 48
  44:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendIntNum>
  48:	00 c0       	rjmp	.+0      	; 0x4a <H_LCD_void_sendIntNum+0x4a>
 	M_Dio_void_setPinValue(LCD_D6_PORT ,LCD_D6_PIN  , GET_BIT(copy_u8Byte,6));
  4a:	8c 85       	ldd	r24, Y+12	; 0x0c
  4c:	9d 85       	ldd	r25, Y+13	; 0x0d
  4e:	ae 85       	ldd	r26, Y+14	; 0x0e
  50:	bf 85       	ldd	r27, Y+15	; 0x0f
  52:	bb 23       	and	r27, r27
  54:	04 f0       	brlt	.+0      	; 0x56 <H_LCD_void_sendIntNum+0x56>
  56:	00 c0       	rjmp	.+0      	; 0x58 <H_LCD_void_sendIntNum+0x58>
  58:	8d e2       	ldi	r24, 0x2D	; 45
  5a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendIntNum>
  5e:	8c 85       	ldd	r24, Y+12	; 0x0c
  60:	9d 85       	ldd	r25, Y+13	; 0x0d
 	M_Dio_void_setPinValue(LCD_D7_PORT ,LCD_D7_PIN  , GET_BIT(copy_u8Byte,7));
  62:	ae 85       	ldd	r26, Y+14	; 0x0e
  64:	bf 85       	ldd	r27, Y+15	; 0x0f
  66:	b0 95       	com	r27
  68:	a0 95       	com	r26
  6a:	90 95       	com	r25
  6c:	81 95       	neg	r24
  6e:	9f 4f       	sbci	r25, 0xFF	; 255
  70:	af 4f       	sbci	r26, 0xFF	; 255
  72:	bf 4f       	sbci	r27, 0xFF	; 255
  74:	8c 87       	std	Y+12, r24	; 0x0c
 	  //step 2 : Activate Enable ,( E = 1)
 	 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,HIGH);
  76:	9d 87       	std	Y+13, r25	; 0x0d
  78:	ae 87       	std	Y+14, r26	; 0x0e
  7a:	bf 87       	std	Y+15, r27	; 0x0f
  7c:	00 c0       	rjmp	.+0      	; 0x7e <H_LCD_void_sendIntNum+0x7e>
  7e:	89 81       	ldd	r24, Y+1	; 0x01
  80:	08 2f       	mov	r16, r24
  82:	11 27       	eor	r17, r17
  84:	07 fd       	sbrc	r16, 7
  86:	10 95       	com	r17
  88:	8c 85       	ldd	r24, Y+12	; 0x0c
  8a:	9d 85       	ldd	r25, Y+13	; 0x0d
  8c:	ae 85       	ldd	r26, Y+14	; 0x0e
  8e:	bf 85       	ldd	r27, Y+15	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  90:	2a e0       	ldi	r18, 0x0A	; 10
  92:	30 e0       	ldi	r19, 0x00	; 0
  94:	40 e0       	ldi	r20, 0x00	; 0
  96:	50 e0       	ldi	r21, 0x00	; 0
  98:	bc 01       	movw	r22, r24
  9a:	cd 01       	movw	r24, r26
  9c:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendIntNum>
  a0:	dc 01       	movw	r26, r24
  a2:	cb 01       	movw	r24, r22
  a4:	28 2f       	mov	r18, r24
  a6:	ce 01       	movw	r24, r28
  a8:	02 96       	adiw	r24, 0x02	; 2
  aa:	fc 01       	movw	r30, r24
  ac:	e0 0f       	add	r30, r16
  ae:	f1 1f       	adc	r31, r17
	if (__tmp < 1.0)
  b0:	20 83       	st	Z, r18
  b2:	8c 85       	ldd	r24, Y+12	; 0x0c
  b4:	9d 85       	ldd	r25, Y+13	; 0x0d
  b6:	ae 85       	ldd	r26, Y+14	; 0x0e
  b8:	bf 85       	ldd	r27, Y+15	; 0x0f
  ba:	2a e0       	ldi	r18, 0x0A	; 10
  bc:	30 e0       	ldi	r19, 0x00	; 0
  be:	40 e0       	ldi	r20, 0x00	; 0
  c0:	50 e0       	ldi	r21, 0x00	; 0
  c2:	bc 01       	movw	r22, r24
  c4:	cd 01       	movw	r24, r26
  c6:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendIntNum>
		__ticks = 1;
  ca:	da 01       	movw	r26, r20
  cc:	c9 01       	movw	r24, r18
  ce:	8c 87       	std	Y+12, r24	; 0x0c
  d0:	9d 87       	std	Y+13, r25	; 0x0d
	else if (__tmp > 65535)
  d2:	ae 87       	std	Y+14, r26	; 0x0e
  d4:	bf 87       	std	Y+15, r27	; 0x0f
  d6:	89 81       	ldd	r24, Y+1	; 0x01
  d8:	8f 5f       	subi	r24, 0xFF	; 255
  da:	89 83       	std	Y+1, r24	; 0x01
  dc:	8c 85       	ldd	r24, Y+12	; 0x0c
  de:	9d 85       	ldd	r25, Y+13	; 0x0d
  e0:	ae 85       	ldd	r26, Y+14	; 0x0e
  e2:	bf 85       	ldd	r27, Y+15	; 0x0f
  e4:	00 97       	sbiw	r24, 0x00	; 0
  e6:	a1 05       	cpc	r26, r1
  e8:	b1 05       	cpc	r27, r1
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  ea:	01 f4       	brne	.+0      	; 0xec <H_LCD_void_sendIntNum+0xec>
  ec:	89 81       	ldd	r24, Y+1	; 0x01
  ee:	81 50       	subi	r24, 0x01	; 1
  f0:	89 83       	std	Y+1, r24	; 0x01
  f2:	00 c0       	rjmp	.+0      	; 0xf4 <H_LCD_void_sendIntNum+0xf4>
  f4:	89 81       	ldd	r24, Y+1	; 0x01
  f6:	28 2f       	mov	r18, r24
  f8:	33 27       	eor	r19, r19
  fa:	27 fd       	sbrc	r18, 7
  fc:	30 95       	com	r19
  fe:	ce 01       	movw	r24, r28
 100:	02 96       	adiw	r24, 0x02	; 2
 102:	fc 01       	movw	r30, r24
 104:	e2 0f       	add	r30, r18
 106:	f3 1f       	adc	r31, r19
 108:	80 81       	ld	r24, Z
 10a:	80 5d       	subi	r24, 0xD0	; 208
 10c:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_sendIntNum>
 110:	89 81       	ldd	r24, Y+1	; 0x01
 112:	81 50       	subi	r24, 0x01	; 1
 114:	89 83       	std	Y+1, r24	; 0x01
 116:	89 81       	ldd	r24, Y+1	; 0x01
 118:	88 23       	and	r24, r24
 11a:	04 f4       	brge	.+0      	; 0x11c <H_LCD_void_sendIntNum+0x11c>
 11c:	2f 96       	adiw	r28, 0x0f	; 15
 11e:	0f b6       	in	r0, 0x3f	; 63
 120:	f8 94       	cli
 122:	de bf       	out	0x3e, r29	; 62
 124:	0f be       	out	0x3f, r0	; 63
 126:	cd bf       	out	0x3d, r28	; 61
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 128:	cf 91       	pop	r28
 12a:	df 91       	pop	r29
 12c:	1f 91       	pop	r17
 12e:	0f 91       	pop	r16
 130:	08 95       	ret

Disassembly of section .text.H_LCD_void_gotXY:

00000000 <H_LCD_void_gotXY>:
void H_LCD_void_displayCustomChar(u8 copy_u8charCode)
{

}
static void H_LCD_void_writeNlatch(u8 copy_u8Byte)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <H_LCD_void_gotXY+0x6>
   6:	00 d0       	rcall	.+0      	; 0x8 <H_LCD_void_gotXY+0x8>
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	89 83       	std	Y+1, r24	; 0x01
   e:	6a 83       	std	Y+2, r22	; 0x02
  10:	89 81       	ldd	r24, Y+1	; 0x01
  12:	88 23       	and	r24, r24
  14:	01 f0       	breq	.+0      	; 0x16 <H_LCD_void_gotXY+0x16>
 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
  // step 5 : delay to allow LCD to process
 	_delay_ms(5);
#elif(LCD_MODE ==  LCD_4BIT_MODE_)
 	// EN = 0 disabled
 	M_Dio_void_setPinValue(LCD_EN_PORT,LCD_EN_PIN,LOW);
  16:	89 81       	ldd	r24, Y+1	; 0x01
  18:	81 30       	cpi	r24, 0x01	; 1
  1a:	01 f4       	brne	.+0      	; 0x1c <H_LCD_void_gotXY+0x1c>
  1c:	8a 81       	ldd	r24, Y+2	; 0x02
  1e:	80 31       	cpi	r24, 0x10	; 16
 	// devide Byte to 2 (4 bits )
 	// step 1 :send high order bits on pins (D7 .. D4)
 	M_Dio_void_setPinValue(LCD_D4_PORT ,LCD_D4_PIN  , GET_BIT(copy_u8Byte,4));
  20:	00 f4       	brcc	.+0      	; 0x22 <H_LCD_void_gotXY+0x22>
  22:	89 81       	ldd	r24, Y+1	; 0x01
  24:	28 2f       	mov	r18, r24
  26:	30 e0       	ldi	r19, 0x00	; 0
  28:	3c 83       	std	Y+4, r19	; 0x04
  2a:	2b 83       	std	Y+3, r18	; 0x03
  2c:	8b 81       	ldd	r24, Y+3	; 0x03
  2e:	9c 81       	ldd	r25, Y+4	; 0x04
  30:	00 97       	sbiw	r24, 0x00	; 0
  32:	01 f0       	breq	.+0      	; 0x34 <H_LCD_void_gotXY+0x34>
 	M_Dio_void_setPinValue(LCD_D5_PORT ,LCD_D5_PIN  , GET_BIT(copy_u8Byte,5));
  34:	2b 81       	ldd	r18, Y+3	; 0x03
  36:	3c 81       	ldd	r19, Y+4	; 0x04
  38:	21 30       	cpi	r18, 0x01	; 1
  3a:	31 05       	cpc	r19, r1
  3c:	01 f0       	breq	.+0      	; 0x3e <H_LCD_void_gotXY+0x3e>
  3e:	00 c0       	rjmp	.+0      	; 0x40 <H_LCD_void_gotXY+0x40>
  40:	8a 81       	ldd	r24, Y+2	; 0x02
  42:	80 58       	subi	r24, 0x80	; 128
  44:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_gotXY>
  48:	00 c0       	rjmp	.+0      	; 0x4a <H_LCD_void_gotXY+0x4a>
 	M_Dio_void_setPinValue(LCD_D6_PORT ,LCD_D6_PIN  , GET_BIT(copy_u8Byte,6));
  4a:	8a 81       	ldd	r24, Y+2	; 0x02
  4c:	80 54       	subi	r24, 0x40	; 64
  4e:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_gotXY>
  52:	0f 90       	pop	r0
  54:	0f 90       	pop	r0
  56:	0f 90       	pop	r0
  58:	0f 90       	pop	r0
  5a:	cf 91       	pop	r28
  5c:	df 91       	pop	r29
  5e:	08 95       	ret

Disassembly of section .text.H_LCD_void_creatCustomChar:

00000000 <H_LCD_void_creatCustomChar>:
void H_LCD_void_displayCustomChar(u8 copy_u8charCode)
{

}
static void H_LCD_void_writeNlatch(u8 copy_u8Byte)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	00 d0       	rcall	.+0      	; 0x6 <H_LCD_void_creatCustomChar+0x6>
   6:	0f 92       	push	r0
   8:	cd b7       	in	r28, 0x3d	; 61
   a:	de b7       	in	r29, 0x3e	; 62
   c:	9a 83       	std	Y+2, r25	; 0x02
   e:	89 83       	std	Y+1, r24	; 0x01
  10:	6b 83       	std	Y+3, r22	; 0x03
  12:	0f 90       	pop	r0
  14:	0f 90       	pop	r0
 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
  // step 5 : delay to allow LCD to process
 	_delay_ms(5);
#elif(LCD_MODE ==  LCD_4BIT_MODE_)
 	// EN = 0 disabled
 	M_Dio_void_setPinValue(LCD_EN_PORT,LCD_EN_PIN,LOW);
  16:	0f 90       	pop	r0
  18:	cf 91       	pop	r28
  1a:	df 91       	pop	r29
  1c:	08 95       	ret

Disassembly of section .text.H_LCD_void_displayCustomChar:

00000000 <H_LCD_void_displayCustomChar>:
void H_LCD_void_displayCustomChar(u8 copy_u8charCode)
{

}
static void H_LCD_void_writeNlatch(u8 copy_u8Byte)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	0f 92       	push	r0
   6:	cd b7       	in	r28, 0x3d	; 61
   8:	de b7       	in	r29, 0x3e	; 62
   a:	89 83       	std	Y+1, r24	; 0x01
   c:	0f 90       	pop	r0
   e:	cf 91       	pop	r28
  10:	df 91       	pop	r29
  12:	08 95       	ret

Disassembly of section .text.H_LCD_void_writeNlatch:

00000000 <H_LCD_void_writeNlatch>:
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	e9 97       	sbiw	r28, 0x39	; 57
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
  14:	89 af       	std	Y+57, r24	; 0x39
 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
  // step 5 : delay to allow LCD to process
 	_delay_ms(5);
#elif(LCD_MODE ==  LCD_4BIT_MODE_)
 	// EN = 0 disabled
 	M_Dio_void_setPinValue(LCD_EN_PORT,LCD_EN_PIN,LOW);
  16:	81 e0       	ldi	r24, 0x01	; 1
  18:	62 e0       	ldi	r22, 0x02	; 2
  1a:	40 e0       	ldi	r20, 0x00	; 0
  1c:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 	// devide Byte to 2 (4 bits )
 	// step 1 :send high order bits on pins (D7 .. D4)
 	M_Dio_void_setPinValue(LCD_D4_PORT ,LCD_D4_PIN  , GET_BIT(copy_u8Byte,4));
  20:	89 ad       	ldd	r24, Y+57	; 0x39
  22:	82 95       	swap	r24
  24:	8f 70       	andi	r24, 0x0F	; 15
  26:	98 2f       	mov	r25, r24
  28:	91 70       	andi	r25, 0x01	; 1
  2a:	81 e0       	ldi	r24, 0x01	; 1
  2c:	63 e0       	ldi	r22, 0x03	; 3
  2e:	49 2f       	mov	r20, r25
  30:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 	M_Dio_void_setPinValue(LCD_D5_PORT ,LCD_D5_PIN  , GET_BIT(copy_u8Byte,5));
  34:	89 ad       	ldd	r24, Y+57	; 0x39
  36:	82 95       	swap	r24
  38:	86 95       	lsr	r24
  3a:	87 70       	andi	r24, 0x07	; 7
  3c:	98 2f       	mov	r25, r24
  3e:	91 70       	andi	r25, 0x01	; 1
  40:	81 e0       	ldi	r24, 0x01	; 1
  42:	64 e0       	ldi	r22, 0x04	; 4
  44:	49 2f       	mov	r20, r25
  46:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 	M_Dio_void_setPinValue(LCD_D6_PORT ,LCD_D6_PIN  , GET_BIT(copy_u8Byte,6));
  4a:	89 ad       	ldd	r24, Y+57	; 0x39
  4c:	82 95       	swap	r24
  4e:	86 95       	lsr	r24
  50:	86 95       	lsr	r24
  52:	83 70       	andi	r24, 0x03	; 3
  54:	98 2f       	mov	r25, r24
  56:	91 70       	andi	r25, 0x01	; 1
  58:	81 e0       	ldi	r24, 0x01	; 1
  5a:	65 e0       	ldi	r22, 0x05	; 5
  5c:	49 2f       	mov	r20, r25
  5e:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 	M_Dio_void_setPinValue(LCD_D7_PORT ,LCD_D7_PIN  , GET_BIT(copy_u8Byte,7));
  62:	89 ad       	ldd	r24, Y+57	; 0x39
  64:	98 2f       	mov	r25, r24
  66:	99 1f       	adc	r25, r25
  68:	99 27       	eor	r25, r25
  6a:	99 1f       	adc	r25, r25
  6c:	81 e0       	ldi	r24, 0x01	; 1
  6e:	66 e0       	ldi	r22, 0x06	; 6
  70:	49 2f       	mov	r20, r25
  72:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 	  //step 2 : Activate Enable ,( E = 1)
 	 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,HIGH);
  76:	81 e0       	ldi	r24, 0x01	; 1
  78:	62 e0       	ldi	r22, 0x02	; 2
  7a:	41 e0       	ldi	r20, 0x01	; 1
  7c:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
  80:	80 e0       	ldi	r24, 0x00	; 0
  82:	90 e0       	ldi	r25, 0x00	; 0
  84:	a0 e8       	ldi	r26, 0x80	; 128
  86:	bf e3       	ldi	r27, 0x3F	; 63
  88:	8d ab       	std	Y+53, r24	; 0x35
  8a:	9e ab       	std	Y+54, r25	; 0x36
  8c:	af ab       	std	Y+55, r26	; 0x37
  8e:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  90:	6d a9       	ldd	r22, Y+53	; 0x35
  92:	7e a9       	ldd	r23, Y+54	; 0x36
  94:	8f a9       	ldd	r24, Y+55	; 0x37
  96:	98 ad       	ldd	r25, Y+56	; 0x38
  98:	20 e0       	ldi	r18, 0x00	; 0
  9a:	30 e0       	ldi	r19, 0x00	; 0
  9c:	4a e7       	ldi	r20, 0x7A	; 122
  9e:	55 e4       	ldi	r21, 0x45	; 69
  a0:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
  a4:	dc 01       	movw	r26, r24
  a6:	cb 01       	movw	r24, r22
  a8:	89 ab       	std	Y+49, r24	; 0x31
  aa:	9a ab       	std	Y+50, r25	; 0x32
  ac:	ab ab       	std	Y+51, r26	; 0x33
  ae:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
  b0:	69 a9       	ldd	r22, Y+49	; 0x31
  b2:	7a a9       	ldd	r23, Y+50	; 0x32
  b4:	8b a9       	ldd	r24, Y+51	; 0x33
  b6:	9c a9       	ldd	r25, Y+52	; 0x34
  b8:	20 e0       	ldi	r18, 0x00	; 0
  ba:	30 e0       	ldi	r19, 0x00	; 0
  bc:	40 e8       	ldi	r20, 0x80	; 128
  be:	5f e3       	ldi	r21, 0x3F	; 63
  c0:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
  c4:	88 23       	and	r24, r24
  c6:	04 f4       	brge	.+0      	; 0xc8 <H_LCD_void_writeNlatch+0xc8>
		__ticks = 1;
  c8:	81 e0       	ldi	r24, 0x01	; 1
  ca:	90 e0       	ldi	r25, 0x00	; 0
  cc:	98 ab       	std	Y+48, r25	; 0x30
  ce:	8f a7       	std	Y+47, r24	; 0x2f
  d0:	00 c0       	rjmp	.+0      	; 0xd2 <H_LCD_void_writeNlatch+0xd2>
	else if (__tmp > 65535)
  d2:	69 a9       	ldd	r22, Y+49	; 0x31
  d4:	7a a9       	ldd	r23, Y+50	; 0x32
  d6:	8b a9       	ldd	r24, Y+51	; 0x33
  d8:	9c a9       	ldd	r25, Y+52	; 0x34
  da:	20 e0       	ldi	r18, 0x00	; 0
  dc:	3f ef       	ldi	r19, 0xFF	; 255
  de:	4f e7       	ldi	r20, 0x7F	; 127
  e0:	57 e4       	ldi	r21, 0x47	; 71
  e2:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
  e6:	18 16       	cp	r1, r24
  e8:	04 f4       	brge	.+0      	; 0xea <H_LCD_void_writeNlatch+0xea>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  ea:	6d a9       	ldd	r22, Y+53	; 0x35
  ec:	7e a9       	ldd	r23, Y+54	; 0x36
  ee:	8f a9       	ldd	r24, Y+55	; 0x37
  f0:	98 ad       	ldd	r25, Y+56	; 0x38
  f2:	20 e0       	ldi	r18, 0x00	; 0
  f4:	30 e0       	ldi	r19, 0x00	; 0
  f6:	40 e2       	ldi	r20, 0x20	; 32
  f8:	51 e4       	ldi	r21, 0x41	; 65
  fa:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
  fe:	dc 01       	movw	r26, r24
 100:	cb 01       	movw	r24, r22
 102:	bc 01       	movw	r22, r24
 104:	cd 01       	movw	r24, r26
 106:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 10a:	dc 01       	movw	r26, r24
 10c:	cb 01       	movw	r24, r22
 10e:	98 ab       	std	Y+48, r25	; 0x30
 110:	8f a7       	std	Y+47, r24	; 0x2f
 112:	00 c0       	rjmp	.+0      	; 0x114 <H_LCD_void_writeNlatch+0x114>
 114:	80 e9       	ldi	r24, 0x90	; 144
 116:	91 e0       	ldi	r25, 0x01	; 1
 118:	9e a7       	std	Y+46, r25	; 0x2e
 11a:	8d a7       	std	Y+45, r24	; 0x2d
 11c:	8d a5       	ldd	r24, Y+45	; 0x2d
 11e:	9e a5       	ldd	r25, Y+46	; 0x2e
 120:	01 97       	sbiw	r24, 0x01	; 1
 122:	01 f4       	brne	.+0      	; 0x124 <H_LCD_void_writeNlatch+0x124>
 124:	9e a7       	std	Y+46, r25	; 0x2e
 126:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 128:	8f a5       	ldd	r24, Y+47	; 0x2f
 12a:	98 a9       	ldd	r25, Y+48	; 0x30
 12c:	01 97       	sbiw	r24, 0x01	; 1
 12e:	98 ab       	std	Y+48, r25	; 0x30
 130:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 132:	8f a5       	ldd	r24, Y+47	; 0x2f
 134:	98 a9       	ldd	r25, Y+48	; 0x30
 136:	00 97       	sbiw	r24, 0x00	; 0
 138:	01 f4       	brne	.+0      	; 0x13a <H_LCD_void_writeNlatch+0x13a>
 13a:	00 c0       	rjmp	.+0      	; 0x13c <H_LCD_void_writeNlatch+0x13c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 13c:	69 a9       	ldd	r22, Y+49	; 0x31
 13e:	7a a9       	ldd	r23, Y+50	; 0x32
 140:	8b a9       	ldd	r24, Y+51	; 0x33
 142:	9c a9       	ldd	r25, Y+52	; 0x34
 144:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 148:	dc 01       	movw	r26, r24
 14a:	cb 01       	movw	r24, r22
 14c:	98 ab       	std	Y+48, r25	; 0x30
 14e:	8f a7       	std	Y+47, r24	; 0x2f
 150:	8f a5       	ldd	r24, Y+47	; 0x2f
 152:	98 a9       	ldd	r25, Y+48	; 0x30
 154:	9c a7       	std	Y+44, r25	; 0x2c
 156:	8b a7       	std	Y+43, r24	; 0x2b
 158:	8b a5       	ldd	r24, Y+43	; 0x2b
 15a:	9c a5       	ldd	r25, Y+44	; 0x2c
 15c:	01 97       	sbiw	r24, 0x01	; 1
 15e:	01 f4       	brne	.+0      	; 0x160 <H_LCD_void_writeNlatch+0x160>
 160:	9c a7       	std	Y+44, r25	; 0x2c
 162:	8b a7       	std	Y+43, r24	; 0x2b
 	  // step 3 : delay for 1 msec 	to allow latching
 	 	_delay_ms(1);
 	  // step 4 : deactivate Enable (E = 0)
 	 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
 164:	81 e0       	ldi	r24, 0x01	; 1
 166:	62 e0       	ldi	r22, 0x02	; 2
 168:	40 e0       	ldi	r20, 0x00	; 0
 16a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 16e:	80 e0       	ldi	r24, 0x00	; 0
 170:	90 e0       	ldi	r25, 0x00	; 0
 172:	a0 ea       	ldi	r26, 0xA0	; 160
 174:	b0 e4       	ldi	r27, 0x40	; 64
 176:	8f a3       	std	Y+39, r24	; 0x27
 178:	98 a7       	std	Y+40, r25	; 0x28
 17a:	a9 a7       	std	Y+41, r26	; 0x29
 17c:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 17e:	6f a1       	ldd	r22, Y+39	; 0x27
 180:	78 a5       	ldd	r23, Y+40	; 0x28
 182:	89 a5       	ldd	r24, Y+41	; 0x29
 184:	9a a5       	ldd	r25, Y+42	; 0x2a
 186:	20 e0       	ldi	r18, 0x00	; 0
 188:	30 e0       	ldi	r19, 0x00	; 0
 18a:	4a e7       	ldi	r20, 0x7A	; 122
 18c:	55 e4       	ldi	r21, 0x45	; 69
 18e:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 192:	dc 01       	movw	r26, r24
 194:	cb 01       	movw	r24, r22
 196:	8b a3       	std	Y+35, r24	; 0x23
 198:	9c a3       	std	Y+36, r25	; 0x24
 19a:	ad a3       	std	Y+37, r26	; 0x25
 19c:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
 19e:	6b a1       	ldd	r22, Y+35	; 0x23
 1a0:	7c a1       	ldd	r23, Y+36	; 0x24
 1a2:	8d a1       	ldd	r24, Y+37	; 0x25
 1a4:	9e a1       	ldd	r25, Y+38	; 0x26
 1a6:	20 e0       	ldi	r18, 0x00	; 0
 1a8:	30 e0       	ldi	r19, 0x00	; 0
 1aa:	40 e8       	ldi	r20, 0x80	; 128
 1ac:	5f e3       	ldi	r21, 0x3F	; 63
 1ae:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 1b2:	88 23       	and	r24, r24
 1b4:	04 f4       	brge	.+0      	; 0x1b6 <H_LCD_void_writeNlatch+0x1b6>
		__ticks = 1;
 1b6:	81 e0       	ldi	r24, 0x01	; 1
 1b8:	90 e0       	ldi	r25, 0x00	; 0
 1ba:	9a a3       	std	Y+34, r25	; 0x22
 1bc:	89 a3       	std	Y+33, r24	; 0x21
 1be:	00 c0       	rjmp	.+0      	; 0x1c0 <H_LCD_void_writeNlatch+0x1c0>
	else if (__tmp > 65535)
 1c0:	6b a1       	ldd	r22, Y+35	; 0x23
 1c2:	7c a1       	ldd	r23, Y+36	; 0x24
 1c4:	8d a1       	ldd	r24, Y+37	; 0x25
 1c6:	9e a1       	ldd	r25, Y+38	; 0x26
 1c8:	20 e0       	ldi	r18, 0x00	; 0
 1ca:	3f ef       	ldi	r19, 0xFF	; 255
 1cc:	4f e7       	ldi	r20, 0x7F	; 127
 1ce:	57 e4       	ldi	r21, 0x47	; 71
 1d0:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 1d4:	18 16       	cp	r1, r24
 1d6:	04 f4       	brge	.+0      	; 0x1d8 <H_LCD_void_writeNlatch+0x1d8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 1d8:	6f a1       	ldd	r22, Y+39	; 0x27
 1da:	78 a5       	ldd	r23, Y+40	; 0x28
 1dc:	89 a5       	ldd	r24, Y+41	; 0x29
 1de:	9a a5       	ldd	r25, Y+42	; 0x2a
 1e0:	20 e0       	ldi	r18, 0x00	; 0
 1e2:	30 e0       	ldi	r19, 0x00	; 0
 1e4:	40 e2       	ldi	r20, 0x20	; 32
 1e6:	51 e4       	ldi	r21, 0x41	; 65
 1e8:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 1ec:	dc 01       	movw	r26, r24
 1ee:	cb 01       	movw	r24, r22
 1f0:	bc 01       	movw	r22, r24
 1f2:	cd 01       	movw	r24, r26
 1f4:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 1f8:	dc 01       	movw	r26, r24
 1fa:	cb 01       	movw	r24, r22
 1fc:	9a a3       	std	Y+34, r25	; 0x22
 1fe:	89 a3       	std	Y+33, r24	; 0x21
 200:	00 c0       	rjmp	.+0      	; 0x202 <H_LCD_void_writeNlatch+0x202>
 202:	80 e9       	ldi	r24, 0x90	; 144
 204:	91 e0       	ldi	r25, 0x01	; 1
 206:	98 a3       	std	Y+32, r25	; 0x20
 208:	8f 8f       	std	Y+31, r24	; 0x1f
 20a:	8f 8d       	ldd	r24, Y+31	; 0x1f
 20c:	98 a1       	ldd	r25, Y+32	; 0x20
 20e:	01 97       	sbiw	r24, 0x01	; 1
 210:	01 f4       	brne	.+0      	; 0x212 <H_LCD_void_writeNlatch+0x212>
 212:	98 a3       	std	Y+32, r25	; 0x20
 214:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 216:	89 a1       	ldd	r24, Y+33	; 0x21
 218:	9a a1       	ldd	r25, Y+34	; 0x22
 21a:	01 97       	sbiw	r24, 0x01	; 1
 21c:	9a a3       	std	Y+34, r25	; 0x22
 21e:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 220:	89 a1       	ldd	r24, Y+33	; 0x21
 222:	9a a1       	ldd	r25, Y+34	; 0x22
 224:	00 97       	sbiw	r24, 0x00	; 0
 226:	01 f4       	brne	.+0      	; 0x228 <H_LCD_void_writeNlatch+0x228>
 228:	00 c0       	rjmp	.+0      	; 0x22a <H_LCD_void_writeNlatch+0x22a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 22a:	6b a1       	ldd	r22, Y+35	; 0x23
 22c:	7c a1       	ldd	r23, Y+36	; 0x24
 22e:	8d a1       	ldd	r24, Y+37	; 0x25
 230:	9e a1       	ldd	r25, Y+38	; 0x26
 232:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 236:	dc 01       	movw	r26, r24
 238:	cb 01       	movw	r24, r22
 23a:	9a a3       	std	Y+34, r25	; 0x22
 23c:	89 a3       	std	Y+33, r24	; 0x21
 23e:	89 a1       	ldd	r24, Y+33	; 0x21
 240:	9a a1       	ldd	r25, Y+34	; 0x22
 242:	9e 8f       	std	Y+30, r25	; 0x1e
 244:	8d 8f       	std	Y+29, r24	; 0x1d
 246:	8d 8d       	ldd	r24, Y+29	; 0x1d
 248:	9e 8d       	ldd	r25, Y+30	; 0x1e
 24a:	01 97       	sbiw	r24, 0x01	; 1
 24c:	01 f4       	brne	.+0      	; 0x24e <H_LCD_void_writeNlatch+0x24e>
 24e:	9e 8f       	std	Y+30, r25	; 0x1e
 250:	8d 8f       	std	Y+29, r24	; 0x1d
 	  // step 5 : delay to allow LCD to process
 	 	_delay_ms(5);
 	 	// step 6 :send Low order bits on pins (D7 .. D4)
 	 	M_Dio_void_setPinValue(LCD_D4_PORT ,LCD_D4_PIN  , GET_BIT(copy_u8Byte,0));
 252:	89 ad       	ldd	r24, Y+57	; 0x39
 254:	98 2f       	mov	r25, r24
 256:	91 70       	andi	r25, 0x01	; 1
 258:	81 e0       	ldi	r24, 0x01	; 1
 25a:	63 e0       	ldi	r22, 0x03	; 3
 25c:	49 2f       	mov	r20, r25
 25e:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 	 	M_Dio_void_setPinValue(LCD_D5_PORT ,LCD_D5_PIN  , GET_BIT(copy_u8Byte,1));
 262:	89 ad       	ldd	r24, Y+57	; 0x39
 264:	86 95       	lsr	r24
 266:	98 2f       	mov	r25, r24
 268:	91 70       	andi	r25, 0x01	; 1
 26a:	81 e0       	ldi	r24, 0x01	; 1
 26c:	64 e0       	ldi	r22, 0x04	; 4
 26e:	49 2f       	mov	r20, r25
 270:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 	 	M_Dio_void_setPinValue(LCD_D6_PORT ,LCD_D6_PIN  , GET_BIT(copy_u8Byte,2));
 274:	89 ad       	ldd	r24, Y+57	; 0x39
 276:	86 95       	lsr	r24
 278:	86 95       	lsr	r24
 27a:	98 2f       	mov	r25, r24
 27c:	91 70       	andi	r25, 0x01	; 1
 27e:	81 e0       	ldi	r24, 0x01	; 1
 280:	65 e0       	ldi	r22, 0x05	; 5
 282:	49 2f       	mov	r20, r25
 284:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 	 	M_Dio_void_setPinValue(LCD_D7_PORT ,LCD_D7_PIN  , GET_BIT(copy_u8Byte,3));
 288:	89 ad       	ldd	r24, Y+57	; 0x39
 28a:	86 95       	lsr	r24
 28c:	86 95       	lsr	r24
 28e:	86 95       	lsr	r24
 290:	98 2f       	mov	r25, r24
 292:	91 70       	andi	r25, 0x01	; 1
 294:	81 e0       	ldi	r24, 0x01	; 1
 296:	66 e0       	ldi	r22, 0x06	; 6
 298:	49 2f       	mov	r20, r25
 29a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 	 	 //step 7 : Activate Enable ,( E = 1)
 	 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,HIGH);
 29e:	81 e0       	ldi	r24, 0x01	; 1
 2a0:	62 e0       	ldi	r22, 0x02	; 2
 2a2:	41 e0       	ldi	r20, 0x01	; 1
 2a4:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 2a8:	80 e0       	ldi	r24, 0x00	; 0
 2aa:	90 e0       	ldi	r25, 0x00	; 0
 2ac:	a0 e8       	ldi	r26, 0x80	; 128
 2ae:	bf e3       	ldi	r27, 0x3F	; 63
 2b0:	89 8f       	std	Y+25, r24	; 0x19
 2b2:	9a 8f       	std	Y+26, r25	; 0x1a
 2b4:	ab 8f       	std	Y+27, r26	; 0x1b
 2b6:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 2b8:	69 8d       	ldd	r22, Y+25	; 0x19
 2ba:	7a 8d       	ldd	r23, Y+26	; 0x1a
 2bc:	8b 8d       	ldd	r24, Y+27	; 0x1b
 2be:	9c 8d       	ldd	r25, Y+28	; 0x1c
 2c0:	20 e0       	ldi	r18, 0x00	; 0
 2c2:	30 e0       	ldi	r19, 0x00	; 0
 2c4:	4a e7       	ldi	r20, 0x7A	; 122
 2c6:	55 e4       	ldi	r21, 0x45	; 69
 2c8:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 2cc:	dc 01       	movw	r26, r24
 2ce:	cb 01       	movw	r24, r22
 2d0:	8d 8b       	std	Y+21, r24	; 0x15
 2d2:	9e 8b       	std	Y+22, r25	; 0x16
 2d4:	af 8b       	std	Y+23, r26	; 0x17
 2d6:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
 2d8:	6d 89       	ldd	r22, Y+21	; 0x15
 2da:	7e 89       	ldd	r23, Y+22	; 0x16
 2dc:	8f 89       	ldd	r24, Y+23	; 0x17
 2de:	98 8d       	ldd	r25, Y+24	; 0x18
 2e0:	20 e0       	ldi	r18, 0x00	; 0
 2e2:	30 e0       	ldi	r19, 0x00	; 0
 2e4:	40 e8       	ldi	r20, 0x80	; 128
 2e6:	5f e3       	ldi	r21, 0x3F	; 63
 2e8:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 2ec:	88 23       	and	r24, r24
 2ee:	04 f4       	brge	.+0      	; 0x2f0 <H_LCD_void_writeNlatch+0x2f0>
		__ticks = 1;
 2f0:	81 e0       	ldi	r24, 0x01	; 1
 2f2:	90 e0       	ldi	r25, 0x00	; 0
 2f4:	9c 8b       	std	Y+20, r25	; 0x14
 2f6:	8b 8b       	std	Y+19, r24	; 0x13
 2f8:	00 c0       	rjmp	.+0      	; 0x2fa <H_LCD_void_writeNlatch+0x2fa>
	else if (__tmp > 65535)
 2fa:	6d 89       	ldd	r22, Y+21	; 0x15
 2fc:	7e 89       	ldd	r23, Y+22	; 0x16
 2fe:	8f 89       	ldd	r24, Y+23	; 0x17
 300:	98 8d       	ldd	r25, Y+24	; 0x18
 302:	20 e0       	ldi	r18, 0x00	; 0
 304:	3f ef       	ldi	r19, 0xFF	; 255
 306:	4f e7       	ldi	r20, 0x7F	; 127
 308:	57 e4       	ldi	r21, 0x47	; 71
 30a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 30e:	18 16       	cp	r1, r24
 310:	04 f4       	brge	.+0      	; 0x312 <H_LCD_void_writeNlatch+0x312>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 312:	69 8d       	ldd	r22, Y+25	; 0x19
 314:	7a 8d       	ldd	r23, Y+26	; 0x1a
 316:	8b 8d       	ldd	r24, Y+27	; 0x1b
 318:	9c 8d       	ldd	r25, Y+28	; 0x1c
 31a:	20 e0       	ldi	r18, 0x00	; 0
 31c:	30 e0       	ldi	r19, 0x00	; 0
 31e:	40 e2       	ldi	r20, 0x20	; 32
 320:	51 e4       	ldi	r21, 0x41	; 65
 322:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 326:	dc 01       	movw	r26, r24
 328:	cb 01       	movw	r24, r22
 32a:	bc 01       	movw	r22, r24
 32c:	cd 01       	movw	r24, r26
 32e:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 332:	dc 01       	movw	r26, r24
 334:	cb 01       	movw	r24, r22
 336:	9c 8b       	std	Y+20, r25	; 0x14
 338:	8b 8b       	std	Y+19, r24	; 0x13
 33a:	00 c0       	rjmp	.+0      	; 0x33c <H_LCD_void_writeNlatch+0x33c>
 33c:	80 e9       	ldi	r24, 0x90	; 144
 33e:	91 e0       	ldi	r25, 0x01	; 1
 340:	9a 8b       	std	Y+18, r25	; 0x12
 342:	89 8b       	std	Y+17, r24	; 0x11
 344:	89 89       	ldd	r24, Y+17	; 0x11
 346:	9a 89       	ldd	r25, Y+18	; 0x12
 348:	01 97       	sbiw	r24, 0x01	; 1
 34a:	01 f4       	brne	.+0      	; 0x34c <H_LCD_void_writeNlatch+0x34c>
 34c:	9a 8b       	std	Y+18, r25	; 0x12
 34e:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 350:	8b 89       	ldd	r24, Y+19	; 0x13
 352:	9c 89       	ldd	r25, Y+20	; 0x14
 354:	01 97       	sbiw	r24, 0x01	; 1
 356:	9c 8b       	std	Y+20, r25	; 0x14
 358:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 35a:	8b 89       	ldd	r24, Y+19	; 0x13
 35c:	9c 89       	ldd	r25, Y+20	; 0x14
 35e:	00 97       	sbiw	r24, 0x00	; 0
 360:	01 f4       	brne	.+0      	; 0x362 <H_LCD_void_writeNlatch+0x362>
 362:	00 c0       	rjmp	.+0      	; 0x364 <H_LCD_void_writeNlatch+0x364>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 364:	6d 89       	ldd	r22, Y+21	; 0x15
 366:	7e 89       	ldd	r23, Y+22	; 0x16
 368:	8f 89       	ldd	r24, Y+23	; 0x17
 36a:	98 8d       	ldd	r25, Y+24	; 0x18
 36c:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 370:	dc 01       	movw	r26, r24
 372:	cb 01       	movw	r24, r22
 374:	9c 8b       	std	Y+20, r25	; 0x14
 376:	8b 8b       	std	Y+19, r24	; 0x13
 378:	8b 89       	ldd	r24, Y+19	; 0x13
 37a:	9c 89       	ldd	r25, Y+20	; 0x14
 37c:	98 8b       	std	Y+16, r25	; 0x10
 37e:	8f 87       	std	Y+15, r24	; 0x0f
 380:	8f 85       	ldd	r24, Y+15	; 0x0f
 382:	98 89       	ldd	r25, Y+16	; 0x10
 384:	01 97       	sbiw	r24, 0x01	; 1
 386:	01 f4       	brne	.+0      	; 0x388 <H_LCD_void_writeNlatch+0x388>
 388:	98 8b       	std	Y+16, r25	; 0x10
 38a:	8f 87       	std	Y+15, r24	; 0x0f
 	 	 // step 8 : delay for 1 msec 	to allow latching
 	 	_delay_ms(1);
 	 	 // step 9 : deactivate Enable (E = 0)
 	 	M_Dio_void_setPinValue(LCD_EN_PORT, LCD_EN_PIN,LOW);
 38c:	81 e0       	ldi	r24, 0x01	; 1
 38e:	62 e0       	ldi	r22, 0x02	; 2
 390:	40 e0       	ldi	r20, 0x00	; 0
 392:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 396:	80 e0       	ldi	r24, 0x00	; 0
 398:	90 e0       	ldi	r25, 0x00	; 0
 39a:	a0 ea       	ldi	r26, 0xA0	; 160
 39c:	b0 e4       	ldi	r27, 0x40	; 64
 39e:	8b 87       	std	Y+11, r24	; 0x0b
 3a0:	9c 87       	std	Y+12, r25	; 0x0c
 3a2:	ad 87       	std	Y+13, r26	; 0x0d
 3a4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
 3a6:	6b 85       	ldd	r22, Y+11	; 0x0b
 3a8:	7c 85       	ldd	r23, Y+12	; 0x0c
 3aa:	8d 85       	ldd	r24, Y+13	; 0x0d
 3ac:	9e 85       	ldd	r25, Y+14	; 0x0e
 3ae:	20 e0       	ldi	r18, 0x00	; 0
 3b0:	30 e0       	ldi	r19, 0x00	; 0
 3b2:	4a e7       	ldi	r20, 0x7A	; 122
 3b4:	55 e4       	ldi	r21, 0x45	; 69
 3b6:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 3ba:	dc 01       	movw	r26, r24
 3bc:	cb 01       	movw	r24, r22
 3be:	8f 83       	std	Y+7, r24	; 0x07
 3c0:	98 87       	std	Y+8, r25	; 0x08
 3c2:	a9 87       	std	Y+9, r26	; 0x09
 3c4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
 3c6:	6f 81       	ldd	r22, Y+7	; 0x07
 3c8:	78 85       	ldd	r23, Y+8	; 0x08
 3ca:	89 85       	ldd	r24, Y+9	; 0x09
 3cc:	9a 85       	ldd	r25, Y+10	; 0x0a
 3ce:	20 e0       	ldi	r18, 0x00	; 0
 3d0:	30 e0       	ldi	r19, 0x00	; 0
 3d2:	40 e8       	ldi	r20, 0x80	; 128
 3d4:	5f e3       	ldi	r21, 0x3F	; 63
 3d6:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 3da:	88 23       	and	r24, r24
 3dc:	04 f4       	brge	.+0      	; 0x3de <H_LCD_void_writeNlatch+0x3de>
		__ticks = 1;
 3de:	81 e0       	ldi	r24, 0x01	; 1
 3e0:	90 e0       	ldi	r25, 0x00	; 0
 3e2:	9e 83       	std	Y+6, r25	; 0x06
 3e4:	8d 83       	std	Y+5, r24	; 0x05
 3e6:	00 c0       	rjmp	.+0      	; 0x3e8 <H_LCD_void_writeNlatch+0x3e8>
	else if (__tmp > 65535)
 3e8:	6f 81       	ldd	r22, Y+7	; 0x07
 3ea:	78 85       	ldd	r23, Y+8	; 0x08
 3ec:	89 85       	ldd	r24, Y+9	; 0x09
 3ee:	9a 85       	ldd	r25, Y+10	; 0x0a
 3f0:	20 e0       	ldi	r18, 0x00	; 0
 3f2:	3f ef       	ldi	r19, 0xFF	; 255
 3f4:	4f e7       	ldi	r20, 0x7F	; 127
 3f6:	57 e4       	ldi	r21, 0x47	; 71
 3f8:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 3fc:	18 16       	cp	r1, r24
 3fe:	04 f4       	brge	.+0      	; 0x400 <H_LCD_void_writeNlatch+0x400>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 400:	6b 85       	ldd	r22, Y+11	; 0x0b
 402:	7c 85       	ldd	r23, Y+12	; 0x0c
 404:	8d 85       	ldd	r24, Y+13	; 0x0d
 406:	9e 85       	ldd	r25, Y+14	; 0x0e
 408:	20 e0       	ldi	r18, 0x00	; 0
 40a:	30 e0       	ldi	r19, 0x00	; 0
 40c:	40 e2       	ldi	r20, 0x20	; 32
 40e:	51 e4       	ldi	r21, 0x41	; 65
 410:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 414:	dc 01       	movw	r26, r24
 416:	cb 01       	movw	r24, r22
 418:	bc 01       	movw	r22, r24
 41a:	cd 01       	movw	r24, r26
 41c:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 420:	dc 01       	movw	r26, r24
 422:	cb 01       	movw	r24, r22
 424:	9e 83       	std	Y+6, r25	; 0x06
 426:	8d 83       	std	Y+5, r24	; 0x05
 428:	00 c0       	rjmp	.+0      	; 0x42a <H_LCD_void_writeNlatch+0x42a>
 42a:	80 e9       	ldi	r24, 0x90	; 144
 42c:	91 e0       	ldi	r25, 0x01	; 1
 42e:	9c 83       	std	Y+4, r25	; 0x04
 430:	8b 83       	std	Y+3, r24	; 0x03
 432:	8b 81       	ldd	r24, Y+3	; 0x03
 434:	9c 81       	ldd	r25, Y+4	; 0x04
 436:	01 97       	sbiw	r24, 0x01	; 1
 438:	01 f4       	brne	.+0      	; 0x43a <H_LCD_void_writeNlatch+0x43a>
 43a:	9c 83       	std	Y+4, r25	; 0x04
 43c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 43e:	8d 81       	ldd	r24, Y+5	; 0x05
 440:	9e 81       	ldd	r25, Y+6	; 0x06
 442:	01 97       	sbiw	r24, 0x01	; 1
 444:	9e 83       	std	Y+6, r25	; 0x06
 446:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 448:	8d 81       	ldd	r24, Y+5	; 0x05
 44a:	9e 81       	ldd	r25, Y+6	; 0x06
 44c:	00 97       	sbiw	r24, 0x00	; 0
 44e:	01 f4       	brne	.+0      	; 0x450 <H_LCD_void_writeNlatch+0x450>
 450:	00 c0       	rjmp	.+0      	; 0x452 <H_LCD_void_writeNlatch+0x452>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
 452:	6f 81       	ldd	r22, Y+7	; 0x07
 454:	78 85       	ldd	r23, Y+8	; 0x08
 456:	89 85       	ldd	r24, Y+9	; 0x09
 458:	9a 85       	ldd	r25, Y+10	; 0x0a
 45a:	0e 94 00 00 	call	0	; 0x0 <H_LCD_void_writeNlatch>
 45e:	dc 01       	movw	r26, r24
 460:	cb 01       	movw	r24, r22
 462:	9e 83       	std	Y+6, r25	; 0x06
 464:	8d 83       	std	Y+5, r24	; 0x05
 466:	8d 81       	ldd	r24, Y+5	; 0x05
 468:	9e 81       	ldd	r25, Y+6	; 0x06
 46a:	9a 83       	std	Y+2, r25	; 0x02
 46c:	89 83       	std	Y+1, r24	; 0x01
 46e:	89 81       	ldd	r24, Y+1	; 0x01
 470:	9a 81       	ldd	r25, Y+2	; 0x02
 472:	01 97       	sbiw	r24, 0x01	; 1
 474:	01 f4       	brne	.+0      	; 0x476 <H_LCD_void_writeNlatch+0x476>
 476:	9a 83       	std	Y+2, r25	; 0x02
 478:	89 83       	std	Y+1, r24	; 0x01
 	 	_delay_ms(5);
#else
  #error("Wrong LCD mode")
#endif

}
 47a:	e9 96       	adiw	r28, 0x39	; 57
 47c:	0f b6       	in	r0, 0x3f	; 63
 47e:	f8 94       	cli
 480:	de bf       	out	0x3e, r29	; 62
 482:	0f be       	out	0x3f, r0	; 63
 484:	cd bf       	out	0x3d, r28	; 61
 486:	cf 91       	pop	r28
 488:	df 91       	pop	r29
 48a:	08 95       	ret

Keypad_prg.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000600  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000008b1  00000000  00000000  00000634  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.H_KEYPAD_void_init 000000ae  00000000  00000000  00000ee5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .rodata.C.0.1302 00000010  00000000  00000000  00000f93  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .text.H_KEYPAD_void_getPressesKey 00000210  00000000  00000000  00000fa3  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.H_KEYPAD_void_init:

00000000 <H_KEYPAD_void_init>:

#include "Keypad_priv.h"
#include "Keypad_config.h"
#include "Keypad_int.h"
void H_KEYPAD_void_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
    // set all rows direction as output
	M_Dio_void_setPinDir(KEYPAD_R0_PORT,KEYPAD_R0_PIN,OUPUT);
   8:	82 e0       	ldi	r24, 0x02	; 2
   a:	64 e0       	ldi	r22, 0x04	; 4
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
	M_Dio_void_setPinDir(KEYPAD_R1_PORT,KEYPAD_R1_PIN,OUPUT);
  12:	82 e0       	ldi	r24, 0x02	; 2
  14:	65 e0       	ldi	r22, 0x05	; 5
  16:	41 e0       	ldi	r20, 0x01	; 1
  18:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
	M_Dio_void_setPinDir(KEYPAD_R2_PORT,KEYPAD_R2_PIN,OUPUT);
  1c:	82 e0       	ldi	r24, 0x02	; 2
  1e:	66 e0       	ldi	r22, 0x06	; 6
  20:	41 e0       	ldi	r20, 0x01	; 1
  22:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
	M_Dio_void_setPinDir(KEYPAD_R3_PORT,KEYPAD_R3_PIN,OUPUT);
  26:	82 e0       	ldi	r24, 0x02	; 2
  28:	67 e0       	ldi	r22, 0x07	; 7
  2a:	41 e0       	ldi	r20, 0x01	; 1
  2c:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
    // set all coloumns direction as inputs
    M_Dio_void_setPinDir(KEYPAD_C0_PORT,KEYPAD_C0_PIN, INPUT);
  30:	84 e0       	ldi	r24, 0x04	; 4
  32:	62 e0       	ldi	r22, 0x02	; 2
  34:	40 e0       	ldi	r20, 0x00	; 0
  36:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
    M_Dio_void_setPinDir(KEYPAD_C1_PORT,KEYPAD_C1_PIN, INPUT);
  3a:	84 e0       	ldi	r24, 0x04	; 4
  3c:	63 e0       	ldi	r22, 0x03	; 3
  3e:	40 e0       	ldi	r20, 0x00	; 0
  40:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
    M_Dio_void_setPinDir(KEYPAD_C2_PORT,KEYPAD_C2_PIN, INPUT);
  44:	84 e0       	ldi	r24, 0x04	; 4
  46:	64 e0       	ldi	r22, 0x04	; 4
  48:	40 e0       	ldi	r20, 0x00	; 0
  4a:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
    M_Dio_void_setPinDir(KEYPAD_C3_PORT,KEYPAD_C3_PIN, INPUT);
  4e:	84 e0       	ldi	r24, 0x04	; 4
  50:	65 e0       	ldi	r22, 0x05	; 5
  52:	40 e0       	ldi	r20, 0x00	; 0
  54:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
    // deactivate rows (HIGH)
    M_Dio_void_setPinValue(KEYPAD_R0_PORT,KEYPAD_R0_PIN,HIGH);
  58:	82 e0       	ldi	r24, 0x02	; 2
  5a:	64 e0       	ldi	r22, 0x04	; 4
  5c:	41 e0       	ldi	r20, 0x01	; 1
  5e:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
    M_Dio_void_setPinValue(KEYPAD_R1_PORT,KEYPAD_R1_PIN,HIGH);
  62:	82 e0       	ldi	r24, 0x02	; 2
  64:	65 e0       	ldi	r22, 0x05	; 5
  66:	41 e0       	ldi	r20, 0x01	; 1
  68:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
    M_Dio_void_setPinValue(KEYPAD_R2_PORT,KEYPAD_R2_PIN,HIGH);
  6c:	82 e0       	ldi	r24, 0x02	; 2
  6e:	66 e0       	ldi	r22, 0x06	; 6
  70:	41 e0       	ldi	r20, 0x01	; 1
  72:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
    M_Dio_void_setPinValue(KEYPAD_R3_PORT,KEYPAD_R3_PIN,HIGH);
  76:	82 e0       	ldi	r24, 0x02	; 2
  78:	67 e0       	ldi	r22, 0x07	; 7
  7a:	41 e0       	ldi	r20, 0x01	; 1
  7c:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
#if(KEYPAD_TYPE == KEYPAD_TYPE_KIT)
    M_Dio_void_setPinValue(KEYPAD_C0_PORT,KEYPAD_C0_PIN, HIGH);
  80:	84 e0       	ldi	r24, 0x04	; 4
  82:	62 e0       	ldi	r22, 0x02	; 2
  84:	41 e0       	ldi	r20, 0x01	; 1
  86:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
	M_Dio_void_setPinValue(KEYPAD_C1_PORT,KEYPAD_C1_PIN, HIGH);
  8a:	84 e0       	ldi	r24, 0x04	; 4
  8c:	63 e0       	ldi	r22, 0x03	; 3
  8e:	41 e0       	ldi	r20, 0x01	; 1
  90:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
	M_Dio_void_setPinValue(KEYPAD_C2_PORT,KEYPAD_C2_PIN, HIGH);
  94:	84 e0       	ldi	r24, 0x04	; 4
  96:	64 e0       	ldi	r22, 0x04	; 4
  98:	41 e0       	ldi	r20, 0x01	; 1
  9a:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
	M_Dio_void_setPinValue(KEYPAD_C3_PORT,KEYPAD_C3_PIN, HIGH);
  9e:	84 e0       	ldi	r24, 0x04	; 4
  a0:	65 e0       	ldi	r22, 0x05	; 5
  a2:	41 e0       	ldi	r20, 0x01	; 1
  a4:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_init>
#endif
}
  a8:	cf 91       	pop	r28
  aa:	df 91       	pop	r29
  ac:	08 95       	ret

Disassembly of section .text.H_KEYPAD_void_getPressesKey:

00000000 <H_KEYPAD_void_getPressesKey>:

#include "Keypad_priv.h"
#include "Keypad_config.h"
#include "Keypad_int.h"
void H_KEYPAD_void_init(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
    // set all rows direction as output
	M_Dio_void_setPinDir(KEYPAD_R0_PORT,KEYPAD_R0_PIN,OUPUT);
   8:	a8 97       	sbiw	r28, 0x28	; 40
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
	M_Dio_void_setPinDir(KEYPAD_R1_PORT,KEYPAD_R1_PIN,OUPUT);
  12:	cd bf       	out	0x3d, r28	; 61
  14:	8f ef       	ldi	r24, 0xFF	; 255
  16:	89 8b       	std	Y+17, r24	; 0x11
  18:	ce 01       	movw	r24, r28
  1a:	42 96       	adiw	r24, 0x12	; 18
	M_Dio_void_setPinDir(KEYPAD_R2_PORT,KEYPAD_R2_PIN,OUPUT);
  1c:	9d a3       	std	Y+37, r25	; 0x25
  1e:	8c a3       	std	Y+36, r24	; 0x24
  20:	e0 e0       	ldi	r30, 0x00	; 0
  22:	f0 e0       	ldi	r31, 0x00	; 0
  24:	ff a3       	std	Y+39, r31	; 0x27
	M_Dio_void_setPinDir(KEYPAD_R3_PORT,KEYPAD_R3_PIN,OUPUT);
  26:	ee a3       	std	Y+38, r30	; 0x26
  28:	f0 e1       	ldi	r31, 0x10	; 16
  2a:	f8 a7       	std	Y+40, r31	; 0x28
  2c:	ee a1       	ldd	r30, Y+38	; 0x26
  2e:	ff a1       	ldd	r31, Y+39	; 0x27
    // set all coloumns direction as inputs
    M_Dio_void_setPinDir(KEYPAD_C0_PORT,KEYPAD_C0_PIN, INPUT);
  30:	00 80       	ld	r0, Z
  32:	8e a1       	ldd	r24, Y+38	; 0x26
  34:	9f a1       	ldd	r25, Y+39	; 0x27
  36:	01 96       	adiw	r24, 0x01	; 1
  38:	9f a3       	std	Y+39, r25	; 0x27
    M_Dio_void_setPinDir(KEYPAD_C1_PORT,KEYPAD_C1_PIN, INPUT);
  3a:	8e a3       	std	Y+38, r24	; 0x26
  3c:	ec a1       	ldd	r30, Y+36	; 0x24
  3e:	fd a1       	ldd	r31, Y+37	; 0x25
  40:	00 82       	st	Z, r0
  42:	8c a1       	ldd	r24, Y+36	; 0x24
    M_Dio_void_setPinDir(KEYPAD_C2_PORT,KEYPAD_C2_PIN, INPUT);
  44:	9d a1       	ldd	r25, Y+37	; 0x25
  46:	01 96       	adiw	r24, 0x01	; 1
  48:	9d a3       	std	Y+37, r25	; 0x25
  4a:	8c a3       	std	Y+36, r24	; 0x24
  4c:	98 a5       	ldd	r25, Y+40	; 0x28
    M_Dio_void_setPinDir(KEYPAD_C3_PORT,KEYPAD_C3_PIN, INPUT);
  4e:	91 50       	subi	r25, 0x01	; 1
  50:	98 a7       	std	Y+40, r25	; 0x28
  52:	e8 a5       	ldd	r30, Y+40	; 0x28
  54:	ee 23       	and	r30, r30
  56:	01 f4       	brne	.+0      	; 0x58 <H_KEYPAD_void_getPressesKey+0x58>
    // deactivate rows (HIGH)
    M_Dio_void_setPinValue(KEYPAD_R0_PORT,KEYPAD_R0_PIN,HIGH);
  58:	84 e0       	ldi	r24, 0x04	; 4
  5a:	88 8b       	std	Y+16, r24	; 0x10
  5c:	00 c0       	rjmp	.+0      	; 0x5e <H_KEYPAD_void_getPressesKey+0x5e>
  5e:	82 e0       	ldi	r24, 0x02	; 2
  60:	68 89       	ldd	r22, Y+16	; 0x10
    M_Dio_void_setPinValue(KEYPAD_R1_PORT,KEYPAD_R1_PIN,HIGH);
  62:	40 e0       	ldi	r20, 0x00	; 0
  64:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
  68:	82 e0       	ldi	r24, 0x02	; 2
  6a:	8f 87       	std	Y+15, r24	; 0x0f
    M_Dio_void_setPinValue(KEYPAD_R2_PORT,KEYPAD_R2_PIN,HIGH);
  6c:	00 c0       	rjmp	.+0      	; 0x6e <H_KEYPAD_void_getPressesKey+0x6e>
  6e:	9e 01       	movw	r18, r28
  70:	2e 5d       	subi	r18, 0xDE	; 222
  72:	3f 4f       	sbci	r19, 0xFF	; 255
  74:	84 e0       	ldi	r24, 0x04	; 4
    M_Dio_void_setPinValue(KEYPAD_R3_PORT,KEYPAD_R3_PIN,HIGH);
  76:	6f 85       	ldd	r22, Y+15	; 0x0f
  78:	a9 01       	movw	r20, r18
  7a:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
  7e:	8a a1       	ldd	r24, Y+34	; 0x22
#if(KEYPAD_TYPE == KEYPAD_TYPE_KIT)
    M_Dio_void_setPinValue(KEYPAD_C0_PORT,KEYPAD_C0_PIN, HIGH);
  80:	88 23       	and	r24, r24
  82:	01 f0       	breq	.+0      	; 0x84 <H_KEYPAD_void_getPressesKey+0x84>
  84:	00 c0       	rjmp	.+0      	; 0x86 <H_KEYPAD_void_getPressesKey+0x86>
  86:	80 e0       	ldi	r24, 0x00	; 0
  88:	90 e0       	ldi	r25, 0x00	; 0
	M_Dio_void_setPinValue(KEYPAD_C1_PORT,KEYPAD_C1_PIN, HIGH);
  8a:	a8 ec       	ldi	r26, 0xC8	; 200
  8c:	b2 e4       	ldi	r27, 0x42	; 66
  8e:	8b 87       	std	Y+11, r24	; 0x0b
  90:	9c 87       	std	Y+12, r25	; 0x0c
  92:	ad 87       	std	Y+13, r26	; 0x0d
	M_Dio_void_setPinValue(KEYPAD_C2_PORT,KEYPAD_C2_PIN, HIGH);
  94:	be 87       	std	Y+14, r27	; 0x0e
  96:	6b 85       	ldd	r22, Y+11	; 0x0b
  98:	7c 85       	ldd	r23, Y+12	; 0x0c
  9a:	8d 85       	ldd	r24, Y+13	; 0x0d
  9c:	9e 85       	ldd	r25, Y+14	; 0x0e
	M_Dio_void_setPinValue(KEYPAD_C3_PORT,KEYPAD_C3_PIN, HIGH);
  9e:	20 e0       	ldi	r18, 0x00	; 0
  a0:	30 e0       	ldi	r19, 0x00	; 0
  a2:	4a e7       	ldi	r20, 0x7A	; 122
  a4:	55 e4       	ldi	r21, 0x45	; 69
  a6:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
#endif
}
  aa:	dc 01       	movw	r26, r24
  ac:	cb 01       	movw	r24, r22
  ae:	8f 83       	std	Y+7, r24	; 0x07
  b0:	98 87       	std	Y+8, r25	; 0x08
  b2:	a9 87       	std	Y+9, r26	; 0x09
  b4:	ba 87       	std	Y+10, r27	; 0x0a
  b6:	6f 81       	ldd	r22, Y+7	; 0x07
  b8:	78 85       	ldd	r23, Y+8	; 0x08
  ba:	89 85       	ldd	r24, Y+9	; 0x09
  bc:	9a 85       	ldd	r25, Y+10	; 0x0a
  be:	20 e0       	ldi	r18, 0x00	; 0
  c0:	30 e0       	ldi	r19, 0x00	; 0
  c2:	40 e8       	ldi	r20, 0x80	; 128
  c4:	5f e3       	ldi	r21, 0x3F	; 63
  c6:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
  ca:	88 23       	and	r24, r24
  cc:	04 f4       	brge	.+0      	; 0xce <H_KEYPAD_void_getPressesKey+0xce>
  ce:	81 e0       	ldi	r24, 0x01	; 1
  d0:	90 e0       	ldi	r25, 0x00	; 0
  d2:	9e 83       	std	Y+6, r25	; 0x06
  d4:	8d 83       	std	Y+5, r24	; 0x05
  d6:	00 c0       	rjmp	.+0      	; 0xd8 <H_KEYPAD_void_getPressesKey+0xd8>
  d8:	6f 81       	ldd	r22, Y+7	; 0x07
  da:	78 85       	ldd	r23, Y+8	; 0x08
  dc:	89 85       	ldd	r24, Y+9	; 0x09
  de:	9a 85       	ldd	r25, Y+10	; 0x0a
  e0:	20 e0       	ldi	r18, 0x00	; 0
  e2:	3f ef       	ldi	r19, 0xFF	; 255
  e4:	4f e7       	ldi	r20, 0x7F	; 127
  e6:	57 e4       	ldi	r21, 0x47	; 71
  e8:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
  ec:	18 16       	cp	r1, r24
  ee:	04 f4       	brge	.+0      	; 0xf0 <H_KEYPAD_void_getPressesKey+0xf0>
  f0:	6b 85       	ldd	r22, Y+11	; 0x0b
  f2:	7c 85       	ldd	r23, Y+12	; 0x0c
  f4:	8d 85       	ldd	r24, Y+13	; 0x0d
  f6:	9e 85       	ldd	r25, Y+14	; 0x0e
  f8:	20 e0       	ldi	r18, 0x00	; 0
  fa:	30 e0       	ldi	r19, 0x00	; 0
  fc:	40 e2       	ldi	r20, 0x20	; 32
  fe:	51 e4       	ldi	r21, 0x41	; 65
 100:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
 104:	dc 01       	movw	r26, r24
 106:	cb 01       	movw	r24, r22
 108:	bc 01       	movw	r22, r24
 10a:	cd 01       	movw	r24, r26
 10c:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
 110:	dc 01       	movw	r26, r24
 112:	cb 01       	movw	r24, r22
 114:	9e 83       	std	Y+6, r25	; 0x06
 116:	8d 83       	std	Y+5, r24	; 0x05
 118:	00 c0       	rjmp	.+0      	; 0x11a <H_KEYPAD_void_getPressesKey+0x11a>
 11a:	80 e9       	ldi	r24, 0x90	; 144
 11c:	91 e0       	ldi	r25, 0x01	; 1
 11e:	9c 83       	std	Y+4, r25	; 0x04
 120:	8b 83       	std	Y+3, r24	; 0x03
 122:	8b 81       	ldd	r24, Y+3	; 0x03
 124:	9c 81       	ldd	r25, Y+4	; 0x04
 126:	01 97       	sbiw	r24, 0x01	; 1
 128:	01 f4       	brne	.+0      	; 0x12a <H_KEYPAD_void_getPressesKey+0x12a>
 12a:	9c 83       	std	Y+4, r25	; 0x04
 12c:	8b 83       	std	Y+3, r24	; 0x03
 12e:	8d 81       	ldd	r24, Y+5	; 0x05
 130:	9e 81       	ldd	r25, Y+6	; 0x06
 132:	01 97       	sbiw	r24, 0x01	; 1
 134:	9e 83       	std	Y+6, r25	; 0x06
 136:	8d 83       	std	Y+5, r24	; 0x05
 138:	8d 81       	ldd	r24, Y+5	; 0x05
 13a:	9e 81       	ldd	r25, Y+6	; 0x06
 13c:	00 97       	sbiw	r24, 0x00	; 0
 13e:	01 f4       	brne	.+0      	; 0x140 <H_KEYPAD_void_getPressesKey+0x140>
 140:	00 c0       	rjmp	.+0      	; 0x142 <H_KEYPAD_void_getPressesKey+0x142>
 142:	6f 81       	ldd	r22, Y+7	; 0x07
 144:	78 85       	ldd	r23, Y+8	; 0x08
 146:	89 85       	ldd	r24, Y+9	; 0x09
 148:	9a 85       	ldd	r25, Y+10	; 0x0a
 14a:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
 14e:	dc 01       	movw	r26, r24
 150:	cb 01       	movw	r24, r22
 152:	9e 83       	std	Y+6, r25	; 0x06
 154:	8d 83       	std	Y+5, r24	; 0x05
 156:	8d 81       	ldd	r24, Y+5	; 0x05
 158:	9e 81       	ldd	r25, Y+6	; 0x06
 15a:	9a 83       	std	Y+2, r25	; 0x02
 15c:	89 83       	std	Y+1, r24	; 0x01
 15e:	89 81       	ldd	r24, Y+1	; 0x01
 160:	9a 81       	ldd	r25, Y+2	; 0x02
 162:	01 97       	sbiw	r24, 0x01	; 1
 164:	01 f4       	brne	.+0      	; 0x166 <H_KEYPAD_void_getPressesKey+0x166>
 166:	9a 83       	std	Y+2, r25	; 0x02
 168:	89 83       	std	Y+1, r24	; 0x01
 16a:	9e 01       	movw	r18, r28
 16c:	2e 5d       	subi	r18, 0xDE	; 222
 16e:	3f 4f       	sbci	r19, 0xFF	; 255
 170:	84 e0       	ldi	r24, 0x04	; 4
 172:	6f 85       	ldd	r22, Y+15	; 0x0f
 174:	a9 01       	movw	r20, r18
 176:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
 17a:	8a a1       	ldd	r24, Y+34	; 0x22
 17c:	88 23       	and	r24, r24
 17e:	01 f4       	brne	.+0      	; 0x180 <H_KEYPAD_void_getPressesKey+0x180>
 180:	00 c0       	rjmp	.+0      	; 0x182 <H_KEYPAD_void_getPressesKey+0x182>
 182:	9e 01       	movw	r18, r28
 184:	2e 5d       	subi	r18, 0xDE	; 222
 186:	3f 4f       	sbci	r19, 0xFF	; 255
 188:	84 e0       	ldi	r24, 0x04	; 4
 18a:	6f 85       	ldd	r22, Y+15	; 0x0f
 18c:	a9 01       	movw	r20, r18
 18e:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
 192:	8a a1       	ldd	r24, Y+34	; 0x22
 194:	88 23       	and	r24, r24
 196:	01 f0       	breq	.+0      	; 0x198 <H_KEYPAD_void_getPressesKey+0x198>
 198:	88 89       	ldd	r24, Y+16	; 0x10
 19a:	88 2f       	mov	r24, r24
 19c:	90 e0       	ldi	r25, 0x00	; 0
 19e:	9c 01       	movw	r18, r24
 1a0:	24 50       	subi	r18, 0x04	; 4
 1a2:	30 40       	sbci	r19, 0x00	; 0
 1a4:	8f 85       	ldd	r24, Y+15	; 0x0f
 1a6:	88 2f       	mov	r24, r24
 1a8:	90 e0       	ldi	r25, 0x00	; 0
 1aa:	ac 01       	movw	r20, r24
 1ac:	42 50       	subi	r20, 0x02	; 2
 1ae:	50 40       	sbci	r21, 0x00	; 0
 1b0:	22 0f       	add	r18, r18
 1b2:	33 1f       	adc	r19, r19
 1b4:	22 0f       	add	r18, r18
 1b6:	33 1f       	adc	r19, r19
 1b8:	ce 01       	movw	r24, r28
 1ba:	01 96       	adiw	r24, 0x01	; 1
 1bc:	82 0f       	add	r24, r18
 1be:	93 1f       	adc	r25, r19
 1c0:	84 0f       	add	r24, r20
 1c2:	95 1f       	adc	r25, r21
 1c4:	fc 01       	movw	r30, r24
 1c6:	71 96       	adiw	r30, 0x11	; 17
 1c8:	80 81       	ld	r24, Z
 1ca:	89 8b       	std	Y+17, r24	; 0x11
 1cc:	f9 89       	ldd	r31, Y+17	; 0x11
 1ce:	fb a3       	std	Y+35, r31	; 0x23
 1d0:	00 c0       	rjmp	.+0      	; 0x1d2 <H_KEYPAD_void_getPressesKey+0x1d2>
 1d2:	8f 85       	ldd	r24, Y+15	; 0x0f
 1d4:	8f 5f       	subi	r24, 0xFF	; 255
 1d6:	8f 87       	std	Y+15, r24	; 0x0f
 1d8:	8f 85       	ldd	r24, Y+15	; 0x0f
 1da:	86 30       	cpi	r24, 0x06	; 6
 1dc:	00 f4       	brcc	.+0      	; 0x1de <H_KEYPAD_void_getPressesKey+0x1de>
 1de:	00 c0       	rjmp	.+0      	; 0x1e0 <H_KEYPAD_void_getPressesKey+0x1e0>
 1e0:	82 e0       	ldi	r24, 0x02	; 2
 1e2:	68 89       	ldd	r22, Y+16	; 0x10
 1e4:	41 e0       	ldi	r20, 0x01	; 1
 1e6:	0e 94 00 00 	call	0	; 0x0 <H_KEYPAD_void_getPressesKey>
 1ea:	88 89       	ldd	r24, Y+16	; 0x10
 1ec:	8f 5f       	subi	r24, 0xFF	; 255
 1ee:	88 8b       	std	Y+16, r24	; 0x10
 1f0:	88 89       	ldd	r24, Y+16	; 0x10
 1f2:	88 30       	cpi	r24, 0x08	; 8
 1f4:	00 f4       	brcc	.+0      	; 0x1f6 <H_KEYPAD_void_getPressesKey+0x1f6>
 1f6:	00 c0       	rjmp	.+0      	; 0x1f8 <H_KEYPAD_void_getPressesKey+0x1f8>
 1f8:	89 89       	ldd	r24, Y+17	; 0x11
 1fa:	8b a3       	std	Y+35, r24	; 0x23
 1fc:	8b a1       	ldd	r24, Y+35	; 0x23
 1fe:	a8 96       	adiw	r28, 0x28	; 40
 200:	0f b6       	in	r0, 0x3f	; 63
 202:	f8 94       	cli
 204:	de bf       	out	0x3e, r29	; 62
 206:	0f be       	out	0x3f, r0	; 63
 208:	cd bf       	out	0x3d, r28	; 61
 20a:	cf 91       	pop	r28
 20c:	df 91       	pop	r29
 20e:	08 95       	ret

Buzzer_program.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000750  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      00000c21  00000000  00000000  00000784  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.H_Buzzer_void_BuzzerInit 00000018  00000000  00000000  000013a5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  6 .text.H_Buzzer_void_BuzzerOn 00000018  00000000  00000000  000013bd  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  7 .text.H_Buzzer_void_BuzzerOff 00000018  00000000  00000000  000013d5  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  8 .text.H_Buzzer_void_BuzzerTog 0000000e  00000000  00000000  000013ed  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  9 .text.H_Buzzer_void_BuzzerShortSound 0000011e  00000000  00000000  000013fb  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
 10 .text.H_Buzzer_void_BuzzerDoubleSound 000002fa  00000000  00000000  00001519  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.H_Buzzer_void_BuzzerInit:

00000000 <H_Buzzer_void_BuzzerInit>:
 */

#include "Buzzer_interface.h"

void H_Buzzer_void_BuzzerInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	M_Dio_void_setPinDir(BUZZER_PORT,BUZZER_PIN,OUPUT);
   8:	83 e0       	ldi	r24, 0x03	; 3
   a:	60 e0       	ldi	r22, 0x00	; 0
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerInit>
}
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.H_Buzzer_void_BuzzerOn:

00000000 <H_Buzzer_void_BuzzerOn>:
 */

#include "Buzzer_interface.h"

void H_Buzzer_void_BuzzerInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	M_Dio_void_setPinDir(BUZZER_PORT,BUZZER_PIN,OUPUT);
   8:	83 e0       	ldi	r24, 0x03	; 3
   a:	60 e0       	ldi	r22, 0x00	; 0
   c:	41 e0       	ldi	r20, 0x01	; 1
   e:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerOn>
}
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.H_Buzzer_void_BuzzerOff:

00000000 <H_Buzzer_void_BuzzerOff>:
 */

#include "Buzzer_interface.h"

void H_Buzzer_void_BuzzerInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	M_Dio_void_setPinDir(BUZZER_PORT,BUZZER_PIN,OUPUT);
   8:	83 e0       	ldi	r24, 0x03	; 3
   a:	60 e0       	ldi	r22, 0x00	; 0
   c:	40 e0       	ldi	r20, 0x00	; 0
   e:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerOff>
}
  12:	cf 91       	pop	r28
  14:	df 91       	pop	r29
  16:	08 95       	ret

Disassembly of section .text.H_Buzzer_void_BuzzerTog:

00000000 <H_Buzzer_void_BuzzerTog>:
 */

#include "Buzzer_interface.h"

void H_Buzzer_void_BuzzerInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	M_Dio_void_setPinDir(BUZZER_PORT,BUZZER_PIN,OUPUT);
   8:	cf 91       	pop	r28
   a:	df 91       	pop	r29
   c:	08 95       	ret

Disassembly of section .text.H_Buzzer_void_BuzzerShortSound:

00000000 <H_Buzzer_void_BuzzerShortSound>:
 */

#include "Buzzer_interface.h"

void H_Buzzer_void_BuzzerInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	M_Dio_void_setPinDir(BUZZER_PORT,BUZZER_PIN,OUPUT);
   8:	2e 97       	sbiw	r28, 0x0e	; 14
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
}
  12:	cd bf       	out	0x3d, r28	; 61
  14:	83 e0       	ldi	r24, 0x03	; 3
  16:	60 e0       	ldi	r22, 0x00	; 0
  18:	41 e0       	ldi	r20, 0x01	; 1
  1a:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerShortSound>
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	a0 e2       	ldi	r26, 0x20	; 32
  24:	b2 e4       	ldi	r27, 0x42	; 66
  26:	8b 87       	std	Y+11, r24	; 0x0b
  28:	9c 87       	std	Y+12, r25	; 0x0c
  2a:	ad 87       	std	Y+13, r26	; 0x0d
  2c:	be 87       	std	Y+14, r27	; 0x0e
  2e:	6b 85       	ldd	r22, Y+11	; 0x0b
  30:	7c 85       	ldd	r23, Y+12	; 0x0c
  32:	8d 85       	ldd	r24, Y+13	; 0x0d
  34:	9e 85       	ldd	r25, Y+14	; 0x0e
  36:	20 e0       	ldi	r18, 0x00	; 0
  38:	30 e0       	ldi	r19, 0x00	; 0
  3a:	4a e7       	ldi	r20, 0x7A	; 122
  3c:	55 e4       	ldi	r21, 0x45	; 69
  3e:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerShortSound>
  42:	dc 01       	movw	r26, r24
  44:	cb 01       	movw	r24, r22
  46:	8f 83       	std	Y+7, r24	; 0x07
  48:	98 87       	std	Y+8, r25	; 0x08
  4a:	a9 87       	std	Y+9, r26	; 0x09
  4c:	ba 87       	std	Y+10, r27	; 0x0a
  4e:	6f 81       	ldd	r22, Y+7	; 0x07
  50:	78 85       	ldd	r23, Y+8	; 0x08
  52:	89 85       	ldd	r24, Y+9	; 0x09
  54:	9a 85       	ldd	r25, Y+10	; 0x0a
  56:	20 e0       	ldi	r18, 0x00	; 0
  58:	30 e0       	ldi	r19, 0x00	; 0
  5a:	40 e8       	ldi	r20, 0x80	; 128
  5c:	5f e3       	ldi	r21, 0x3F	; 63
  5e:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerShortSound>
  62:	88 23       	and	r24, r24
  64:	04 f4       	brge	.+0      	; 0x66 <H_Buzzer_void_BuzzerShortSound+0x66>
  66:	81 e0       	ldi	r24, 0x01	; 1
  68:	90 e0       	ldi	r25, 0x00	; 0
  6a:	9e 83       	std	Y+6, r25	; 0x06
  6c:	8d 83       	std	Y+5, r24	; 0x05
  6e:	00 c0       	rjmp	.+0      	; 0x70 <H_Buzzer_void_BuzzerShortSound+0x70>
  70:	6f 81       	ldd	r22, Y+7	; 0x07
  72:	78 85       	ldd	r23, Y+8	; 0x08
  74:	89 85       	ldd	r24, Y+9	; 0x09
  76:	9a 85       	ldd	r25, Y+10	; 0x0a
  78:	20 e0       	ldi	r18, 0x00	; 0
  7a:	3f ef       	ldi	r19, 0xFF	; 255
  7c:	4f e7       	ldi	r20, 0x7F	; 127
  7e:	57 e4       	ldi	r21, 0x47	; 71
  80:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerShortSound>
  84:	18 16       	cp	r1, r24
  86:	04 f4       	brge	.+0      	; 0x88 <H_Buzzer_void_BuzzerShortSound+0x88>
  88:	6b 85       	ldd	r22, Y+11	; 0x0b
  8a:	7c 85       	ldd	r23, Y+12	; 0x0c
  8c:	8d 85       	ldd	r24, Y+13	; 0x0d
  8e:	9e 85       	ldd	r25, Y+14	; 0x0e
  90:	20 e0       	ldi	r18, 0x00	; 0
  92:	30 e0       	ldi	r19, 0x00	; 0
  94:	40 e2       	ldi	r20, 0x20	; 32
  96:	51 e4       	ldi	r21, 0x41	; 65
  98:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerShortSound>
  9c:	dc 01       	movw	r26, r24
  9e:	cb 01       	movw	r24, r22
  a0:	bc 01       	movw	r22, r24
  a2:	cd 01       	movw	r24, r26
  a4:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerShortSound>
  a8:	dc 01       	movw	r26, r24
  aa:	cb 01       	movw	r24, r22
  ac:	9e 83       	std	Y+6, r25	; 0x06
  ae:	8d 83       	std	Y+5, r24	; 0x05
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <H_Buzzer_void_BuzzerShortSound+0xb2>
  b2:	80 e9       	ldi	r24, 0x90	; 144
  b4:	91 e0       	ldi	r25, 0x01	; 1
  b6:	9c 83       	std	Y+4, r25	; 0x04
  b8:	8b 83       	std	Y+3, r24	; 0x03
  ba:	8b 81       	ldd	r24, Y+3	; 0x03
  bc:	9c 81       	ldd	r25, Y+4	; 0x04
  be:	01 97       	sbiw	r24, 0x01	; 1
  c0:	01 f4       	brne	.+0      	; 0xc2 <H_Buzzer_void_BuzzerShortSound+0xc2>
  c2:	9c 83       	std	Y+4, r25	; 0x04
  c4:	8b 83       	std	Y+3, r24	; 0x03
  c6:	8d 81       	ldd	r24, Y+5	; 0x05
  c8:	9e 81       	ldd	r25, Y+6	; 0x06
  ca:	01 97       	sbiw	r24, 0x01	; 1
  cc:	9e 83       	std	Y+6, r25	; 0x06
  ce:	8d 83       	std	Y+5, r24	; 0x05
  d0:	8d 81       	ldd	r24, Y+5	; 0x05
  d2:	9e 81       	ldd	r25, Y+6	; 0x06
  d4:	00 97       	sbiw	r24, 0x00	; 0
  d6:	01 f4       	brne	.+0      	; 0xd8 <H_Buzzer_void_BuzzerShortSound+0xd8>
  d8:	00 c0       	rjmp	.+0      	; 0xda <H_Buzzer_void_BuzzerShortSound+0xda>
  da:	6f 81       	ldd	r22, Y+7	; 0x07
  dc:	78 85       	ldd	r23, Y+8	; 0x08
  de:	89 85       	ldd	r24, Y+9	; 0x09
  e0:	9a 85       	ldd	r25, Y+10	; 0x0a
  e2:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerShortSound>
  e6:	dc 01       	movw	r26, r24
  e8:	cb 01       	movw	r24, r22
  ea:	9e 83       	std	Y+6, r25	; 0x06
  ec:	8d 83       	std	Y+5, r24	; 0x05
  ee:	8d 81       	ldd	r24, Y+5	; 0x05
  f0:	9e 81       	ldd	r25, Y+6	; 0x06
  f2:	9a 83       	std	Y+2, r25	; 0x02
  f4:	89 83       	std	Y+1, r24	; 0x01
  f6:	89 81       	ldd	r24, Y+1	; 0x01
  f8:	9a 81       	ldd	r25, Y+2	; 0x02
  fa:	01 97       	sbiw	r24, 0x01	; 1
  fc:	01 f4       	brne	.+0      	; 0xfe <H_Buzzer_void_BuzzerShortSound+0xfe>
  fe:	9a 83       	std	Y+2, r25	; 0x02
 100:	89 83       	std	Y+1, r24	; 0x01
 102:	83 e0       	ldi	r24, 0x03	; 3
 104:	60 e0       	ldi	r22, 0x00	; 0
 106:	40 e0       	ldi	r20, 0x00	; 0
 108:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerShortSound>
 10c:	2e 96       	adiw	r28, 0x0e	; 14
 10e:	0f b6       	in	r0, 0x3f	; 63
 110:	f8 94       	cli
 112:	de bf       	out	0x3e, r29	; 62
 114:	0f be       	out	0x3f, r0	; 63
 116:	cd bf       	out	0x3d, r28	; 61
 118:	cf 91       	pop	r28
 11a:	df 91       	pop	r29
 11c:	08 95       	ret

Disassembly of section .text.H_Buzzer_void_BuzzerDoubleSound:

00000000 <H_Buzzer_void_BuzzerDoubleSound>:
 */

#include "Buzzer_interface.h"

void H_Buzzer_void_BuzzerInit(void)
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
	M_Dio_void_setPinDir(BUZZER_PORT,BUZZER_PIN,OUPUT);
   8:	aa 97       	sbiw	r28, 0x2a	; 42
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
}
  12:	cd bf       	out	0x3d, r28	; 61
  14:	83 e0       	ldi	r24, 0x03	; 3
  16:	60 e0       	ldi	r22, 0x00	; 0
  18:	41 e0       	ldi	r20, 0x01	; 1
  1a:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
  1e:	80 e0       	ldi	r24, 0x00	; 0
  20:	90 e0       	ldi	r25, 0x00	; 0
  22:	a0 e2       	ldi	r26, 0x20	; 32
  24:	b2 e4       	ldi	r27, 0x42	; 66
  26:	8f a3       	std	Y+39, r24	; 0x27
  28:	98 a7       	std	Y+40, r25	; 0x28
  2a:	a9 a7       	std	Y+41, r26	; 0x29
  2c:	ba a7       	std	Y+42, r27	; 0x2a
  2e:	6f a1       	ldd	r22, Y+39	; 0x27
  30:	78 a5       	ldd	r23, Y+40	; 0x28
  32:	89 a5       	ldd	r24, Y+41	; 0x29
  34:	9a a5       	ldd	r25, Y+42	; 0x2a
  36:	20 e0       	ldi	r18, 0x00	; 0
  38:	30 e0       	ldi	r19, 0x00	; 0
  3a:	4a e7       	ldi	r20, 0x7A	; 122
  3c:	55 e4       	ldi	r21, 0x45	; 69
  3e:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
  42:	dc 01       	movw	r26, r24
  44:	cb 01       	movw	r24, r22
  46:	8b a3       	std	Y+35, r24	; 0x23
  48:	9c a3       	std	Y+36, r25	; 0x24
  4a:	ad a3       	std	Y+37, r26	; 0x25
  4c:	be a3       	std	Y+38, r27	; 0x26
  4e:	6b a1       	ldd	r22, Y+35	; 0x23
  50:	7c a1       	ldd	r23, Y+36	; 0x24
  52:	8d a1       	ldd	r24, Y+37	; 0x25
  54:	9e a1       	ldd	r25, Y+38	; 0x26
  56:	20 e0       	ldi	r18, 0x00	; 0
  58:	30 e0       	ldi	r19, 0x00	; 0
  5a:	40 e8       	ldi	r20, 0x80	; 128
  5c:	5f e3       	ldi	r21, 0x3F	; 63
  5e:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
  62:	88 23       	and	r24, r24
  64:	04 f4       	brge	.+0      	; 0x66 <H_Buzzer_void_BuzzerDoubleSound+0x66>
  66:	81 e0       	ldi	r24, 0x01	; 1
  68:	90 e0       	ldi	r25, 0x00	; 0
  6a:	9a a3       	std	Y+34, r25	; 0x22
  6c:	89 a3       	std	Y+33, r24	; 0x21
  6e:	00 c0       	rjmp	.+0      	; 0x70 <H_Buzzer_void_BuzzerDoubleSound+0x70>
  70:	6b a1       	ldd	r22, Y+35	; 0x23
  72:	7c a1       	ldd	r23, Y+36	; 0x24
  74:	8d a1       	ldd	r24, Y+37	; 0x25
  76:	9e a1       	ldd	r25, Y+38	; 0x26
  78:	20 e0       	ldi	r18, 0x00	; 0
  7a:	3f ef       	ldi	r19, 0xFF	; 255
  7c:	4f e7       	ldi	r20, 0x7F	; 127
  7e:	57 e4       	ldi	r21, 0x47	; 71
  80:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
  84:	18 16       	cp	r1, r24
  86:	04 f4       	brge	.+0      	; 0x88 <H_Buzzer_void_BuzzerDoubleSound+0x88>
  88:	6f a1       	ldd	r22, Y+39	; 0x27
  8a:	78 a5       	ldd	r23, Y+40	; 0x28
  8c:	89 a5       	ldd	r24, Y+41	; 0x29
  8e:	9a a5       	ldd	r25, Y+42	; 0x2a
  90:	20 e0       	ldi	r18, 0x00	; 0
  92:	30 e0       	ldi	r19, 0x00	; 0
  94:	40 e2       	ldi	r20, 0x20	; 32
  96:	51 e4       	ldi	r21, 0x41	; 65
  98:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
  9c:	dc 01       	movw	r26, r24
  9e:	cb 01       	movw	r24, r22
  a0:	bc 01       	movw	r22, r24
  a2:	cd 01       	movw	r24, r26
  a4:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
  a8:	dc 01       	movw	r26, r24
  aa:	cb 01       	movw	r24, r22
  ac:	9a a3       	std	Y+34, r25	; 0x22
  ae:	89 a3       	std	Y+33, r24	; 0x21
  b0:	00 c0       	rjmp	.+0      	; 0xb2 <H_Buzzer_void_BuzzerDoubleSound+0xb2>
  b2:	80 e9       	ldi	r24, 0x90	; 144
  b4:	91 e0       	ldi	r25, 0x01	; 1
  b6:	98 a3       	std	Y+32, r25	; 0x20
  b8:	8f 8f       	std	Y+31, r24	; 0x1f
  ba:	8f 8d       	ldd	r24, Y+31	; 0x1f
  bc:	98 a1       	ldd	r25, Y+32	; 0x20
  be:	01 97       	sbiw	r24, 0x01	; 1
  c0:	01 f4       	brne	.+0      	; 0xc2 <H_Buzzer_void_BuzzerDoubleSound+0xc2>
  c2:	98 a3       	std	Y+32, r25	; 0x20
  c4:	8f 8f       	std	Y+31, r24	; 0x1f
  c6:	89 a1       	ldd	r24, Y+33	; 0x21
  c8:	9a a1       	ldd	r25, Y+34	; 0x22
  ca:	01 97       	sbiw	r24, 0x01	; 1
  cc:	9a a3       	std	Y+34, r25	; 0x22
  ce:	89 a3       	std	Y+33, r24	; 0x21
  d0:	89 a1       	ldd	r24, Y+33	; 0x21
  d2:	9a a1       	ldd	r25, Y+34	; 0x22
  d4:	00 97       	sbiw	r24, 0x00	; 0
  d6:	01 f4       	brne	.+0      	; 0xd8 <H_Buzzer_void_BuzzerDoubleSound+0xd8>
  d8:	00 c0       	rjmp	.+0      	; 0xda <H_Buzzer_void_BuzzerDoubleSound+0xda>
  da:	6b a1       	ldd	r22, Y+35	; 0x23
  dc:	7c a1       	ldd	r23, Y+36	; 0x24
  de:	8d a1       	ldd	r24, Y+37	; 0x25
  e0:	9e a1       	ldd	r25, Y+38	; 0x26
  e2:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
  e6:	dc 01       	movw	r26, r24
  e8:	cb 01       	movw	r24, r22
  ea:	9a a3       	std	Y+34, r25	; 0x22
  ec:	89 a3       	std	Y+33, r24	; 0x21
  ee:	89 a1       	ldd	r24, Y+33	; 0x21
  f0:	9a a1       	ldd	r25, Y+34	; 0x22
  f2:	9e 8f       	std	Y+30, r25	; 0x1e
  f4:	8d 8f       	std	Y+29, r24	; 0x1d
  f6:	8d 8d       	ldd	r24, Y+29	; 0x1d
  f8:	9e 8d       	ldd	r25, Y+30	; 0x1e
  fa:	01 97       	sbiw	r24, 0x01	; 1
  fc:	01 f4       	brne	.+0      	; 0xfe <H_Buzzer_void_BuzzerDoubleSound+0xfe>
  fe:	9e 8f       	std	Y+30, r25	; 0x1e
 100:	8d 8f       	std	Y+29, r24	; 0x1d
 102:	83 e0       	ldi	r24, 0x03	; 3
 104:	60 e0       	ldi	r22, 0x00	; 0
 106:	40 e0       	ldi	r20, 0x00	; 0
 108:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 10c:	80 e0       	ldi	r24, 0x00	; 0
 10e:	90 e0       	ldi	r25, 0x00	; 0
 110:	a0 e7       	ldi	r26, 0x70	; 112
 112:	b2 e4       	ldi	r27, 0x42	; 66
 114:	89 8f       	std	Y+25, r24	; 0x19
 116:	9a 8f       	std	Y+26, r25	; 0x1a
 118:	ab 8f       	std	Y+27, r26	; 0x1b
 11a:	bc 8f       	std	Y+28, r27	; 0x1c
 11c:	69 8d       	ldd	r22, Y+25	; 0x19
 11e:	7a 8d       	ldd	r23, Y+26	; 0x1a
 120:	8b 8d       	ldd	r24, Y+27	; 0x1b
 122:	9c 8d       	ldd	r25, Y+28	; 0x1c
 124:	20 e0       	ldi	r18, 0x00	; 0
 126:	30 e0       	ldi	r19, 0x00	; 0
 128:	4a e7       	ldi	r20, 0x7A	; 122
 12a:	55 e4       	ldi	r21, 0x45	; 69
 12c:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 130:	dc 01       	movw	r26, r24
 132:	cb 01       	movw	r24, r22
 134:	8d 8b       	std	Y+21, r24	; 0x15
 136:	9e 8b       	std	Y+22, r25	; 0x16
 138:	af 8b       	std	Y+23, r26	; 0x17
 13a:	b8 8f       	std	Y+24, r27	; 0x18
 13c:	6d 89       	ldd	r22, Y+21	; 0x15
 13e:	7e 89       	ldd	r23, Y+22	; 0x16
 140:	8f 89       	ldd	r24, Y+23	; 0x17
 142:	98 8d       	ldd	r25, Y+24	; 0x18
 144:	20 e0       	ldi	r18, 0x00	; 0
 146:	30 e0       	ldi	r19, 0x00	; 0
 148:	40 e8       	ldi	r20, 0x80	; 128
 14a:	5f e3       	ldi	r21, 0x3F	; 63
 14c:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 150:	88 23       	and	r24, r24
 152:	04 f4       	brge	.+0      	; 0x154 <H_Buzzer_void_BuzzerDoubleSound+0x154>
 154:	81 e0       	ldi	r24, 0x01	; 1
 156:	90 e0       	ldi	r25, 0x00	; 0
 158:	9c 8b       	std	Y+20, r25	; 0x14
 15a:	8b 8b       	std	Y+19, r24	; 0x13
 15c:	00 c0       	rjmp	.+0      	; 0x15e <H_Buzzer_void_BuzzerDoubleSound+0x15e>
 15e:	6d 89       	ldd	r22, Y+21	; 0x15
 160:	7e 89       	ldd	r23, Y+22	; 0x16
 162:	8f 89       	ldd	r24, Y+23	; 0x17
 164:	98 8d       	ldd	r25, Y+24	; 0x18
 166:	20 e0       	ldi	r18, 0x00	; 0
 168:	3f ef       	ldi	r19, 0xFF	; 255
 16a:	4f e7       	ldi	r20, 0x7F	; 127
 16c:	57 e4       	ldi	r21, 0x47	; 71
 16e:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 172:	18 16       	cp	r1, r24
 174:	04 f4       	brge	.+0      	; 0x176 <H_Buzzer_void_BuzzerDoubleSound+0x176>
 176:	69 8d       	ldd	r22, Y+25	; 0x19
 178:	7a 8d       	ldd	r23, Y+26	; 0x1a
 17a:	8b 8d       	ldd	r24, Y+27	; 0x1b
 17c:	9c 8d       	ldd	r25, Y+28	; 0x1c
 17e:	20 e0       	ldi	r18, 0x00	; 0
 180:	30 e0       	ldi	r19, 0x00	; 0
 182:	40 e2       	ldi	r20, 0x20	; 32
 184:	51 e4       	ldi	r21, 0x41	; 65
 186:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 18a:	dc 01       	movw	r26, r24
 18c:	cb 01       	movw	r24, r22
 18e:	bc 01       	movw	r22, r24
 190:	cd 01       	movw	r24, r26
 192:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 196:	dc 01       	movw	r26, r24
 198:	cb 01       	movw	r24, r22
 19a:	9c 8b       	std	Y+20, r25	; 0x14
 19c:	8b 8b       	std	Y+19, r24	; 0x13
 19e:	00 c0       	rjmp	.+0      	; 0x1a0 <H_Buzzer_void_BuzzerDoubleSound+0x1a0>
 1a0:	80 e9       	ldi	r24, 0x90	; 144
 1a2:	91 e0       	ldi	r25, 0x01	; 1
 1a4:	9a 8b       	std	Y+18, r25	; 0x12
 1a6:	89 8b       	std	Y+17, r24	; 0x11
 1a8:	89 89       	ldd	r24, Y+17	; 0x11
 1aa:	9a 89       	ldd	r25, Y+18	; 0x12
 1ac:	01 97       	sbiw	r24, 0x01	; 1
 1ae:	01 f4       	brne	.+0      	; 0x1b0 <H_Buzzer_void_BuzzerDoubleSound+0x1b0>
 1b0:	9a 8b       	std	Y+18, r25	; 0x12
 1b2:	89 8b       	std	Y+17, r24	; 0x11
 1b4:	8b 89       	ldd	r24, Y+19	; 0x13
 1b6:	9c 89       	ldd	r25, Y+20	; 0x14
 1b8:	01 97       	sbiw	r24, 0x01	; 1
 1ba:	9c 8b       	std	Y+20, r25	; 0x14
 1bc:	8b 8b       	std	Y+19, r24	; 0x13
 1be:	8b 89       	ldd	r24, Y+19	; 0x13
 1c0:	9c 89       	ldd	r25, Y+20	; 0x14
 1c2:	00 97       	sbiw	r24, 0x00	; 0
 1c4:	01 f4       	brne	.+0      	; 0x1c6 <H_Buzzer_void_BuzzerDoubleSound+0x1c6>
 1c6:	00 c0       	rjmp	.+0      	; 0x1c8 <H_Buzzer_void_BuzzerDoubleSound+0x1c8>
 1c8:	6d 89       	ldd	r22, Y+21	; 0x15
 1ca:	7e 89       	ldd	r23, Y+22	; 0x16
 1cc:	8f 89       	ldd	r24, Y+23	; 0x17
 1ce:	98 8d       	ldd	r25, Y+24	; 0x18
 1d0:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 1d4:	dc 01       	movw	r26, r24
 1d6:	cb 01       	movw	r24, r22
 1d8:	9c 8b       	std	Y+20, r25	; 0x14
 1da:	8b 8b       	std	Y+19, r24	; 0x13
 1dc:	8b 89       	ldd	r24, Y+19	; 0x13
 1de:	9c 89       	ldd	r25, Y+20	; 0x14
 1e0:	98 8b       	std	Y+16, r25	; 0x10
 1e2:	8f 87       	std	Y+15, r24	; 0x0f
 1e4:	8f 85       	ldd	r24, Y+15	; 0x0f
 1e6:	98 89       	ldd	r25, Y+16	; 0x10
 1e8:	01 97       	sbiw	r24, 0x01	; 1
 1ea:	01 f4       	brne	.+0      	; 0x1ec <H_Buzzer_void_BuzzerDoubleSound+0x1ec>
 1ec:	98 8b       	std	Y+16, r25	; 0x10
 1ee:	8f 87       	std	Y+15, r24	; 0x0f
 1f0:	83 e0       	ldi	r24, 0x03	; 3
 1f2:	60 e0       	ldi	r22, 0x00	; 0
 1f4:	41 e0       	ldi	r20, 0x01	; 1
 1f6:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 1fa:	80 e0       	ldi	r24, 0x00	; 0
 1fc:	90 e0       	ldi	r25, 0x00	; 0
 1fe:	a0 e2       	ldi	r26, 0x20	; 32
 200:	b2 e4       	ldi	r27, 0x42	; 66
 202:	8b 87       	std	Y+11, r24	; 0x0b
 204:	9c 87       	std	Y+12, r25	; 0x0c
 206:	ad 87       	std	Y+13, r26	; 0x0d
 208:	be 87       	std	Y+14, r27	; 0x0e
 20a:	6b 85       	ldd	r22, Y+11	; 0x0b
 20c:	7c 85       	ldd	r23, Y+12	; 0x0c
 20e:	8d 85       	ldd	r24, Y+13	; 0x0d
 210:	9e 85       	ldd	r25, Y+14	; 0x0e
 212:	20 e0       	ldi	r18, 0x00	; 0
 214:	30 e0       	ldi	r19, 0x00	; 0
 216:	4a e7       	ldi	r20, 0x7A	; 122
 218:	55 e4       	ldi	r21, 0x45	; 69
 21a:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 21e:	dc 01       	movw	r26, r24
 220:	cb 01       	movw	r24, r22
 222:	8f 83       	std	Y+7, r24	; 0x07
 224:	98 87       	std	Y+8, r25	; 0x08
 226:	a9 87       	std	Y+9, r26	; 0x09
 228:	ba 87       	std	Y+10, r27	; 0x0a
 22a:	6f 81       	ldd	r22, Y+7	; 0x07
 22c:	78 85       	ldd	r23, Y+8	; 0x08
 22e:	89 85       	ldd	r24, Y+9	; 0x09
 230:	9a 85       	ldd	r25, Y+10	; 0x0a
 232:	20 e0       	ldi	r18, 0x00	; 0
 234:	30 e0       	ldi	r19, 0x00	; 0
 236:	40 e8       	ldi	r20, 0x80	; 128
 238:	5f e3       	ldi	r21, 0x3F	; 63
 23a:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 23e:	88 23       	and	r24, r24
 240:	04 f4       	brge	.+0      	; 0x242 <H_Buzzer_void_BuzzerDoubleSound+0x242>
 242:	81 e0       	ldi	r24, 0x01	; 1
 244:	90 e0       	ldi	r25, 0x00	; 0
 246:	9e 83       	std	Y+6, r25	; 0x06
 248:	8d 83       	std	Y+5, r24	; 0x05
 24a:	00 c0       	rjmp	.+0      	; 0x24c <H_Buzzer_void_BuzzerDoubleSound+0x24c>
 24c:	6f 81       	ldd	r22, Y+7	; 0x07
 24e:	78 85       	ldd	r23, Y+8	; 0x08
 250:	89 85       	ldd	r24, Y+9	; 0x09
 252:	9a 85       	ldd	r25, Y+10	; 0x0a
 254:	20 e0       	ldi	r18, 0x00	; 0
 256:	3f ef       	ldi	r19, 0xFF	; 255
 258:	4f e7       	ldi	r20, 0x7F	; 127
 25a:	57 e4       	ldi	r21, 0x47	; 71
 25c:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 260:	18 16       	cp	r1, r24
 262:	04 f4       	brge	.+0      	; 0x264 <H_Buzzer_void_BuzzerDoubleSound+0x264>
 264:	6b 85       	ldd	r22, Y+11	; 0x0b
 266:	7c 85       	ldd	r23, Y+12	; 0x0c
 268:	8d 85       	ldd	r24, Y+13	; 0x0d
 26a:	9e 85       	ldd	r25, Y+14	; 0x0e
 26c:	20 e0       	ldi	r18, 0x00	; 0
 26e:	30 e0       	ldi	r19, 0x00	; 0
 270:	40 e2       	ldi	r20, 0x20	; 32
 272:	51 e4       	ldi	r21, 0x41	; 65
 274:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 278:	dc 01       	movw	r26, r24
 27a:	cb 01       	movw	r24, r22
 27c:	bc 01       	movw	r22, r24
 27e:	cd 01       	movw	r24, r26
 280:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 284:	dc 01       	movw	r26, r24
 286:	cb 01       	movw	r24, r22
 288:	9e 83       	std	Y+6, r25	; 0x06
 28a:	8d 83       	std	Y+5, r24	; 0x05
 28c:	00 c0       	rjmp	.+0      	; 0x28e <H_Buzzer_void_BuzzerDoubleSound+0x28e>
 28e:	80 e9       	ldi	r24, 0x90	; 144
 290:	91 e0       	ldi	r25, 0x01	; 1
 292:	9c 83       	std	Y+4, r25	; 0x04
 294:	8b 83       	std	Y+3, r24	; 0x03
 296:	8b 81       	ldd	r24, Y+3	; 0x03
 298:	9c 81       	ldd	r25, Y+4	; 0x04
 29a:	01 97       	sbiw	r24, 0x01	; 1
 29c:	01 f4       	brne	.+0      	; 0x29e <H_Buzzer_void_BuzzerDoubleSound+0x29e>
 29e:	9c 83       	std	Y+4, r25	; 0x04
 2a0:	8b 83       	std	Y+3, r24	; 0x03
 2a2:	8d 81       	ldd	r24, Y+5	; 0x05
 2a4:	9e 81       	ldd	r25, Y+6	; 0x06
 2a6:	01 97       	sbiw	r24, 0x01	; 1
 2a8:	9e 83       	std	Y+6, r25	; 0x06
 2aa:	8d 83       	std	Y+5, r24	; 0x05
 2ac:	8d 81       	ldd	r24, Y+5	; 0x05
 2ae:	9e 81       	ldd	r25, Y+6	; 0x06
 2b0:	00 97       	sbiw	r24, 0x00	; 0
 2b2:	01 f4       	brne	.+0      	; 0x2b4 <H_Buzzer_void_BuzzerDoubleSound+0x2b4>
 2b4:	00 c0       	rjmp	.+0      	; 0x2b6 <H_Buzzer_void_BuzzerDoubleSound+0x2b6>
 2b6:	6f 81       	ldd	r22, Y+7	; 0x07
 2b8:	78 85       	ldd	r23, Y+8	; 0x08
 2ba:	89 85       	ldd	r24, Y+9	; 0x09
 2bc:	9a 85       	ldd	r25, Y+10	; 0x0a
 2be:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 2c2:	dc 01       	movw	r26, r24
 2c4:	cb 01       	movw	r24, r22
 2c6:	9e 83       	std	Y+6, r25	; 0x06
 2c8:	8d 83       	std	Y+5, r24	; 0x05
 2ca:	8d 81       	ldd	r24, Y+5	; 0x05
 2cc:	9e 81       	ldd	r25, Y+6	; 0x06
 2ce:	9a 83       	std	Y+2, r25	; 0x02
 2d0:	89 83       	std	Y+1, r24	; 0x01
 2d2:	89 81       	ldd	r24, Y+1	; 0x01
 2d4:	9a 81       	ldd	r25, Y+2	; 0x02
 2d6:	01 97       	sbiw	r24, 0x01	; 1
 2d8:	01 f4       	brne	.+0      	; 0x2da <H_Buzzer_void_BuzzerDoubleSound+0x2da>
 2da:	9a 83       	std	Y+2, r25	; 0x02
 2dc:	89 83       	std	Y+1, r24	; 0x01
 2de:	83 e0       	ldi	r24, 0x03	; 3
 2e0:	60 e0       	ldi	r22, 0x00	; 0
 2e2:	40 e0       	ldi	r20, 0x00	; 0
 2e4:	0e 94 00 00 	call	0	; 0x0 <H_Buzzer_void_BuzzerDoubleSound>
 2e8:	aa 96       	adiw	r28, 0x2a	; 42
 2ea:	0f b6       	in	r0, 0x3f	; 63
 2ec:	f8 94       	cli
 2ee:	de bf       	out	0x3e, r29	; 62
 2f0:	0f be       	out	0x3f, r0	; 63
 2f2:	cd bf       	out	0x3d, r28	; 61
 2f4:	cf 91       	pop	r28
 2f6:	df 91       	pop	r29
 2f8:	08 95       	ret

main.o:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00000000  00000000  00000034  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  00000034  2**0
                  ALLOC
  3 .stab         00000444  00000000  00000000  00000034  2**2
                  CONTENTS, RELOC, READONLY, DEBUGGING
  4 .stabstr      000007ac  00000000  00000000  00000478  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .text.main    00000124  00000000  00000000  00000c24  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE

Disassembly of section .text.main:

00000000 <main>:
		}
}
#endif
#if 1
void main()
{
   0:	df 93       	push	r29
   2:	cf 93       	push	r28
   4:	cd b7       	in	r28, 0x3d	; 61
   6:	de b7       	in	r29, 0x3e	; 62
   8:	60 97       	sbiw	r28, 0x10	; 16
   a:	0f b6       	in	r0, 0x3f	; 63
   c:	f8 94       	cli
   e:	de bf       	out	0x3e, r29	; 62
  10:	0f be       	out	0x3f, r0	; 63
  12:	cd bf       	out	0x3d, r28	; 61
	u16 Distance;
	// enable GIE
	M_GIE_void_enable();
  14:	0e 94 00 00 	call	0	; 0x0 <main>
	// init LCD
	H_LCD_void_Init();
  18:	0e 94 00 00 	call	0	; 0x0 <main>
	// Ultrasonic init
	H_ULTRASONIC_void_init();
  1c:	0e 94 00 00 	call	0	; 0x0 <main>
	while(1)
	{
		Distance = H_ULTRASONIC_void_getDistance();
  20:	0e 94 00 00 	call	0	; 0x0 <main>
  24:	98 8b       	std	Y+16, r25	; 0x10
  26:	8f 87       	std	Y+15, r24	; 0x0f

		// display Duty cycle
	//	H_LCD_void_sendString("Distance= ");
		H_LCD_void_sendIntNum(Distance);
  28:	8f 85       	ldd	r24, Y+15	; 0x0f
  2a:	98 89       	ldd	r25, Y+16	; 0x10
  2c:	cc 01       	movw	r24, r24
  2e:	a0 e0       	ldi	r26, 0x00	; 0
  30:	b0 e0       	ldi	r27, 0x00	; 0
  32:	bc 01       	movw	r22, r24
  34:	cd 01       	movw	r24, r26
  36:	0e 94 00 00 	call	0	; 0x0 <main>
  3a:	80 e0       	ldi	r24, 0x00	; 0
  3c:	90 e0       	ldi	r25, 0x00	; 0
  3e:	aa e7       	ldi	r26, 0x7A	; 122
  40:	b4 e4       	ldi	r27, 0x44	; 68
  42:	8b 87       	std	Y+11, r24	; 0x0b
  44:	9c 87       	std	Y+12, r25	; 0x0c
  46:	ad 87       	std	Y+13, r26	; 0x0d
  48:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
  4a:	6b 85       	ldd	r22, Y+11	; 0x0b
  4c:	7c 85       	ldd	r23, Y+12	; 0x0c
  4e:	8d 85       	ldd	r24, Y+13	; 0x0d
  50:	9e 85       	ldd	r25, Y+14	; 0x0e
  52:	20 e0       	ldi	r18, 0x00	; 0
  54:	30 e0       	ldi	r19, 0x00	; 0
  56:	4a e7       	ldi	r20, 0x7A	; 122
  58:	55 e4       	ldi	r21, 0x45	; 69
  5a:	0e 94 00 00 	call	0	; 0x0 <main>
  5e:	dc 01       	movw	r26, r24
  60:	cb 01       	movw	r24, r22
  62:	8f 83       	std	Y+7, r24	; 0x07
  64:	98 87       	std	Y+8, r25	; 0x08
  66:	a9 87       	std	Y+9, r26	; 0x09
  68:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
  6a:	6f 81       	ldd	r22, Y+7	; 0x07
  6c:	78 85       	ldd	r23, Y+8	; 0x08
  6e:	89 85       	ldd	r24, Y+9	; 0x09
  70:	9a 85       	ldd	r25, Y+10	; 0x0a
  72:	20 e0       	ldi	r18, 0x00	; 0
  74:	30 e0       	ldi	r19, 0x00	; 0
  76:	40 e8       	ldi	r20, 0x80	; 128
  78:	5f e3       	ldi	r21, 0x3F	; 63
  7a:	0e 94 00 00 	call	0	; 0x0 <main>
  7e:	88 23       	and	r24, r24
  80:	04 f4       	brge	.+0      	; 0x82 <main+0x82>
		__ticks = 1;
  82:	81 e0       	ldi	r24, 0x01	; 1
  84:	90 e0       	ldi	r25, 0x00	; 0
  86:	9e 83       	std	Y+6, r25	; 0x06
  88:	8d 83       	std	Y+5, r24	; 0x05
  8a:	00 c0       	rjmp	.+0      	; 0x8c <main+0x8c>
	else if (__tmp > 65535)
  8c:	6f 81       	ldd	r22, Y+7	; 0x07
  8e:	78 85       	ldd	r23, Y+8	; 0x08
  90:	89 85       	ldd	r24, Y+9	; 0x09
  92:	9a 85       	ldd	r25, Y+10	; 0x0a
  94:	20 e0       	ldi	r18, 0x00	; 0
  96:	3f ef       	ldi	r19, 0xFF	; 255
  98:	4f e7       	ldi	r20, 0x7F	; 127
  9a:	57 e4       	ldi	r21, 0x47	; 71
  9c:	0e 94 00 00 	call	0	; 0x0 <main>
  a0:	18 16       	cp	r1, r24
  a2:	04 f4       	brge	.+0      	; 0xa4 <main+0xa4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
  a4:	6b 85       	ldd	r22, Y+11	; 0x0b
  a6:	7c 85       	ldd	r23, Y+12	; 0x0c
  a8:	8d 85       	ldd	r24, Y+13	; 0x0d
  aa:	9e 85       	ldd	r25, Y+14	; 0x0e
  ac:	20 e0       	ldi	r18, 0x00	; 0
  ae:	30 e0       	ldi	r19, 0x00	; 0
  b0:	40 e2       	ldi	r20, 0x20	; 32
  b2:	51 e4       	ldi	r21, 0x41	; 65
  b4:	0e 94 00 00 	call	0	; 0x0 <main>
  b8:	dc 01       	movw	r26, r24
  ba:	cb 01       	movw	r24, r22
  bc:	bc 01       	movw	r22, r24
  be:	cd 01       	movw	r24, r26
  c0:	0e 94 00 00 	call	0	; 0x0 <main>
  c4:	dc 01       	movw	r26, r24
  c6:	cb 01       	movw	r24, r22
  c8:	9e 83       	std	Y+6, r25	; 0x06
  ca:	8d 83       	std	Y+5, r24	; 0x05
  cc:	00 c0       	rjmp	.+0      	; 0xce <main+0xce>
  ce:	80 e9       	ldi	r24, 0x90	; 144
  d0:	91 e0       	ldi	r25, 0x01	; 1
  d2:	9c 83       	std	Y+4, r25	; 0x04
  d4:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  d6:	8b 81       	ldd	r24, Y+3	; 0x03
  d8:	9c 81       	ldd	r25, Y+4	; 0x04
  da:	01 97       	sbiw	r24, 0x01	; 1
  dc:	01 f4       	brne	.+0      	; 0xde <main+0xde>
  de:	9c 83       	std	Y+4, r25	; 0x04
  e0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
  e2:	8d 81       	ldd	r24, Y+5	; 0x05
  e4:	9e 81       	ldd	r25, Y+6	; 0x06
  e6:	01 97       	sbiw	r24, 0x01	; 1
  e8:	9e 83       	std	Y+6, r25	; 0x06
  ea:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
  ec:	8d 81       	ldd	r24, Y+5	; 0x05
  ee:	9e 81       	ldd	r25, Y+6	; 0x06
  f0:	00 97       	sbiw	r24, 0x00	; 0
  f2:	01 f4       	brne	.+0      	; 0xf4 <main+0xf4>
  f4:	00 c0       	rjmp	.+0      	; 0xf6 <main+0xf6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
  f6:	6f 81       	ldd	r22, Y+7	; 0x07
  f8:	78 85       	ldd	r23, Y+8	; 0x08
  fa:	89 85       	ldd	r24, Y+9	; 0x09
  fc:	9a 85       	ldd	r25, Y+10	; 0x0a
  fe:	0e 94 00 00 	call	0	; 0x0 <main>
 102:	dc 01       	movw	r26, r24
 104:	cb 01       	movw	r24, r22
 106:	9e 83       	std	Y+6, r25	; 0x06
 108:	8d 83       	std	Y+5, r24	; 0x05
 10a:	8d 81       	ldd	r24, Y+5	; 0x05
 10c:	9e 81       	ldd	r25, Y+6	; 0x06
 10e:	9a 83       	std	Y+2, r25	; 0x02
 110:	89 83       	std	Y+1, r24	; 0x01
 112:	89 81       	ldd	r24, Y+1	; 0x01
 114:	9a 81       	ldd	r25, Y+2	; 0x02
 116:	01 97       	sbiw	r24, 0x01	; 1
 118:	01 f4       	brne	.+0      	; 0x11a <main+0x11a>
 11a:	9a 83       	std	Y+2, r25	; 0x02
 11c:	89 83       	std	Y+1, r24	; 0x01
		//H_LCD_void_sendString(" cm");
		_delay_ms(1000);
		H_LCD_void_clear();
 11e:	0e 94 00 00 	call	0	; 0x0 <main>
 122:	00 c0       	rjmp	.+0      	; 0x124 <__SREG__+0xe5>
